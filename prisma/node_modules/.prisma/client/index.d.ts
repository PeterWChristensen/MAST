
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Area
 */

export type Area = {
  areaID: number
  requirementID: number
  name: string | null
}

/**
 * Model AreaRequirement
 */

export type AreaRequirement = {
  areaID: number
  nSubAreas: number | null
  nCourses: number | null
  nCredits: number | null
}

/**
 * Model Comments
 */

export type Comments = {
  studentID: number
  GPDID: number
  comment: string
  date: Date | null
}

/**
 * Model Course
 */

export type Course = {
  courseID: string
  departID: string | null
  name: string | null
  description: string | null
  credits: number | null
  courseNum: number | null
}

/**
 * Model CourseOffering
 */

export type CourseOffering = {
  courseOfferingID: string
  courseID: string | null
  semester: CourseOffering_semester | null
  year: number | null
  section: string | null
}

/**
 * Model CoursePlan
 */

export type CoursePlan = {
  studentID: number
  valid: boolean | null
  complete: boolean | null
}

/**
 * Model DegreeRequirement
 */

export type DegreeRequirement = {
  requirementID: number
  departID: string | null
  track: string | null
  versionSemester: DegreeRequirement_versionSemester | null
  versionYear: number | null
  totalCredit: number | null
  project: string | null
  thesis: string | null
  timeLimit: number | null
  finalRecommended: number | null
  minGPA: number | null
}

/**
 * Model Department
 */

export type Department = {
  departmentID: string
  departmentName: string | null
}

/**
 * Model ElectiveStatus
 */

export type ElectiveStatus = {
  studentID: number
  areaID: number
  status: ElectiveStatus_status | null
}

/**
 * Model GPD
 */

export type GPD = {
  GPDID: number
  departmentID: string
}

/**
 * Model Grades
 */

export type Grades = {
  studentID: number
  courseOfferingID: string
  grade: string | null
}

/**
 * Model prerequisite
 */

export type prerequisite = {
  courseID: string
  prerequisiteID: string
}

/**
 * Model proficiencyRequirement
 */

export type proficiencyRequirement = {
  requirementID: number
  courseID: string
}

/**
 * Model requiredCourse
 */

export type requiredCourse = {
  requirementID: number
  courseID: string
}

/**
 * Model RequiredStatus
 */

export type RequiredStatus = {
  studentID: number
  courseID: string
  status: RequiredStatus_status | null
}

/**
 * Model Student
 */

export type Student = {
  studentID: number
  firstName: string
  lastName: string
  requirementID: number | null
  entrySemester: Student_entrySemester
  entryYear: number
  gradSemester: Student_gradSemester | null
  gradYear: number | null
  nSemestersInProgram: number
  gpa: Prisma.Decimal | null
  totalCredits: number | null
  projectOption: string | null
  advisor: string | null
  hasGraduated: boolean | null
}

/**
 * Model SubArea
 */

export type SubArea = {
  areaID: number
  minCourses: number | null
  minCredit: number | null
  maxCredit: number | null
  maxCourse: number | null
  name: string | null
}

/**
 * Model TimeSlotDay
 */

export type TimeSlotDay = {
  CourseOfferingID: string
  day: TimeSlotDay_day
}

/**
 * Model TimeSlotTime
 */

export type TimeSlotTime = {
  courseOfferingID: string
  startTime: Date | null
  endTime: Date | null
}

/**
 * Model User
 */

export type User = {
  userID: number
  username: string
  password: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CourseOffering_semester: {
  Fall: 'Fall',
  Winter: 'Winter',
  Spring: 'Spring',
  Summer1: 'Summer1',
  Summer2: 'Summer2'
};

export type CourseOffering_semester = (typeof CourseOffering_semester)[keyof typeof CourseOffering_semester]


export const DegreeRequirement_versionSemester: {
  Fall: 'Fall',
  Winter: 'Winter',
  Spring: 'Spring',
  SummerI: 'SummerI',
  SummerII: 'SummerII'
};

export type DegreeRequirement_versionSemester = (typeof DegreeRequirement_versionSemester)[keyof typeof DegreeRequirement_versionSemester]


export const ElectiveStatus_status: {
  Satisfied: 'Satisfied',
  Pending: 'Pending',
  Unsatisfied: 'Unsatisfied'
};

export type ElectiveStatus_status = (typeof ElectiveStatus_status)[keyof typeof ElectiveStatus_status]


export const RequiredStatus_status: {
  Satisfied: 'Satisfied',
  Pending: 'Pending',
  Unsatisfied: 'Unsatisfied'
};

export type RequiredStatus_status = (typeof RequiredStatus_status)[keyof typeof RequiredStatus_status]


export const Student_entrySemester: {
  Fall: 'Fall',
  Winter: 'Winter',
  Spring: 'Spring',
  Summer1: 'Summer1',
  Summer2: 'Summer2'
};

export type Student_entrySemester = (typeof Student_entrySemester)[keyof typeof Student_entrySemester]


export const Student_gradSemester: {
  Fall: 'Fall',
  Winter: 'Winter',
  Spring: 'Spring',
  Summer1: 'Summer1',
  Summer2: 'Summer2'
};

export type Student_gradSemester = (typeof Student_gradSemester)[keyof typeof Student_gradSemester]


export const TimeSlotDay_day: {
  Monday: 'Monday',
  Tuesday: 'Tuesday',
  Wednesday: 'Wednesday',
  Thursday: 'Thursday',
  Friday: 'Friday',
  Saturday: 'Saturday',
  Sunday: 'Sunday'
};

export type TimeSlotDay_day = (typeof TimeSlotDay_day)[keyof typeof TimeSlotDay_day]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Areas
 * const areas = await prisma.area.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Areas
   * const areas = await prisma.area.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<GlobalReject>;

  /**
   * `prisma.areaRequirement`: Exposes CRUD operations for the **AreaRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaRequirements
    * const areaRequirements = await prisma.areaRequirement.findMany()
    * ```
    */
  get areaRequirement(): Prisma.AreaRequirementDelegate<GlobalReject>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<GlobalReject>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<GlobalReject>;

  /**
   * `prisma.courseOffering`: Exposes CRUD operations for the **CourseOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseOfferings
    * const courseOfferings = await prisma.courseOffering.findMany()
    * ```
    */
  get courseOffering(): Prisma.CourseOfferingDelegate<GlobalReject>;

  /**
   * `prisma.coursePlan`: Exposes CRUD operations for the **CoursePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoursePlans
    * const coursePlans = await prisma.coursePlan.findMany()
    * ```
    */
  get coursePlan(): Prisma.CoursePlanDelegate<GlobalReject>;

  /**
   * `prisma.degreeRequirement`: Exposes CRUD operations for the **DegreeRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DegreeRequirements
    * const degreeRequirements = await prisma.degreeRequirement.findMany()
    * ```
    */
  get degreeRequirement(): Prisma.DegreeRequirementDelegate<GlobalReject>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<GlobalReject>;

  /**
   * `prisma.electiveStatus`: Exposes CRUD operations for the **ElectiveStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElectiveStatuses
    * const electiveStatuses = await prisma.electiveStatus.findMany()
    * ```
    */
  get electiveStatus(): Prisma.ElectiveStatusDelegate<GlobalReject>;

  /**
   * `prisma.gPD`: Exposes CRUD operations for the **GPD** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPDS
    * const gPDS = await prisma.gPD.findMany()
    * ```
    */
  get gPD(): Prisma.GPDDelegate<GlobalReject>;

  /**
   * `prisma.grades`: Exposes CRUD operations for the **Grades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grades.findMany()
    * ```
    */
  get grades(): Prisma.GradesDelegate<GlobalReject>;

  /**
   * `prisma.prerequisite`: Exposes CRUD operations for the **prerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prerequisites
    * const prerequisites = await prisma.prerequisite.findMany()
    * ```
    */
  get prerequisite(): Prisma.prerequisiteDelegate<GlobalReject>;

  /**
   * `prisma.proficiencyRequirement`: Exposes CRUD operations for the **proficiencyRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProficiencyRequirements
    * const proficiencyRequirements = await prisma.proficiencyRequirement.findMany()
    * ```
    */
  get proficiencyRequirement(): Prisma.proficiencyRequirementDelegate<GlobalReject>;

  /**
   * `prisma.requiredCourse`: Exposes CRUD operations for the **requiredCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequiredCourses
    * const requiredCourses = await prisma.requiredCourse.findMany()
    * ```
    */
  get requiredCourse(): Prisma.requiredCourseDelegate<GlobalReject>;

  /**
   * `prisma.requiredStatus`: Exposes CRUD operations for the **RequiredStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequiredStatuses
    * const requiredStatuses = await prisma.requiredStatus.findMany()
    * ```
    */
  get requiredStatus(): Prisma.RequiredStatusDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<GlobalReject>;

  /**
   * `prisma.subArea`: Exposes CRUD operations for the **SubArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAreas
    * const subAreas = await prisma.subArea.findMany()
    * ```
    */
  get subArea(): Prisma.SubAreaDelegate<GlobalReject>;

  /**
   * `prisma.timeSlotDay`: Exposes CRUD operations for the **TimeSlotDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlotDays
    * const timeSlotDays = await prisma.timeSlotDay.findMany()
    * ```
    */
  get timeSlotDay(): Prisma.TimeSlotDayDelegate<GlobalReject>;

  /**
   * `prisma.timeSlotTime`: Exposes CRUD operations for the **TimeSlotTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlotTimes
    * const timeSlotTimes = await prisma.timeSlotTime.findMany()
    * ```
    */
  get timeSlotTime(): Prisma.TimeSlotTimeDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.19.0
   * Query Engine version: c1455d0b443d66b0d9db9bcb1bb9ee0d5bbc511d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Area: 'Area',
    AreaRequirement: 'AreaRequirement',
    Comments: 'Comments',
    Course: 'Course',
    CourseOffering: 'CourseOffering',
    CoursePlan: 'CoursePlan',
    DegreeRequirement: 'DegreeRequirement',
    Department: 'Department',
    ElectiveStatus: 'ElectiveStatus',
    GPD: 'GPD',
    Grades: 'Grades',
    prerequisite: 'prerequisite',
    proficiencyRequirement: 'proficiencyRequirement',
    requiredCourse: 'requiredCourse',
    RequiredStatus: 'RequiredStatus',
    Student: 'Student',
    SubArea: 'SubArea',
    TimeSlotDay: 'TimeSlotDay',
    TimeSlotTime: 'TimeSlotTime',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Area
   */


  export type AggregateArea = {
    count: AreaCountAggregateOutputType | null
    avg: AreaAvgAggregateOutputType | null
    sum: AreaSumAggregateOutputType | null
    min: AreaMinAggregateOutputType | null
    max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    areaID: number
    requirementID: number
  }

  export type AreaSumAggregateOutputType = {
    areaID: number
    requirementID: number
  }

  export type AreaMinAggregateOutputType = {
    areaID: number
    requirementID: number
    name: string | null
  }

  export type AreaMaxAggregateOutputType = {
    areaID: number
    requirementID: number
    name: string | null
  }

  export type AreaCountAggregateOutputType = {
    areaID: number
    requirementID: number
    name: number | null
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    areaID?: true
    requirementID?: true
  }

  export type AreaSumAggregateInputType = {
    areaID?: true
    requirementID?: true
  }

  export type AreaMinAggregateInputType = {
    areaID?: true
    requirementID?: true
    name?: true
  }

  export type AreaMaxAggregateInputType = {
    areaID?: true
    requirementID?: true
    name?: true
  }

  export type AreaCountAggregateInputType = {
    areaID?: true
    requirementID?: true
    name?: true
    _all?: true
  }

  export type AreaAggregateArgs = {
    /**
     * Filter which Area to aggregate.
    **/
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
    **/
    orderBy?: Enumerable<AreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
    [P in keyof T & keyof AggregateArea]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }



  export type AreaSelect = {
    areaID?: boolean
    requirementID?: boolean
    name?: boolean
    DegreeRequirement?: boolean | DegreeRequirementArgs
    AreaRequirement?: boolean | AreaRequirementArgs
    ElectiveStatus?: boolean | ElectiveStatusFindManyArgs
    SubArea?: boolean | SubAreaArgs
  }

  export type AreaInclude = {
    DegreeRequirement?: boolean | DegreeRequirementArgs
    AreaRequirement?: boolean | AreaRequirementArgs
    ElectiveStatus?: boolean | ElectiveStatusFindManyArgs
    SubArea?: boolean | SubAreaArgs
  }

  export type AreaGetPayload<
    S extends boolean | null | undefined | AreaArgs,
    U = keyof S
      > = S extends true
        ? Area
    : S extends undefined
    ? never
    : S extends AreaArgs | AreaFindManyArgs
    ?'include' extends U
    ? Area  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['include'][P]> :
        P extends 'AreaRequirement'
        ? AreaRequirementGetPayload<S['include'][P]> | null :
        P extends 'ElectiveStatus'
        ? Array < ElectiveStatusGetPayload<S['include'][P]>>  :
        P extends 'SubArea'
        ? SubAreaGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Area ?Area [P]
  : 
          P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['select'][P]> :
        P extends 'AreaRequirement'
        ? AreaRequirementGetPayload<S['select'][P]> | null :
        P extends 'ElectiveStatus'
        ? Array < ElectiveStatusGetPayload<S['select'][P]>>  :
        P extends 'SubArea'
        ? SubAreaGetPayload<S['select'][P]> | null : never
  } 
    : Area
  : Area


  type AreaCountArgs = Merge<
    Omit<AreaFindManyArgs, 'select' | 'include'> & {
      select?: AreaCountAggregateInputType | true
    }
  >

  export interface AreaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AreaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Area'> extends True ? CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>> : CheckSelect<T, Prisma__AreaClient<Area | null >, Prisma__AreaClient<AreaGetPayload<T> | null >>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AreaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Area'> extends True ? CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>> : CheckSelect<T, Prisma__AreaClient<Area | null >, Prisma__AreaClient<AreaGetPayload<T> | null >>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `areaID`
     * const areaWithAreaIDOnly = await prisma.area.findMany({ select: { areaID: true } })
     * 
    **/
    findMany<T extends AreaFindManyArgs>(
      args?: SelectSubset<T, AreaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Area>>, PrismaPromise<Array<AreaGetPayload<T>>>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
    **/
    create<T extends AreaCreateArgs>(
      args: SelectSubset<T, AreaCreateArgs>
    ): CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
    **/
    delete<T extends AreaDeleteArgs>(
      args: SelectSubset<T, AreaDeleteArgs>
    ): CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaUpdateArgs>(
      args: SelectSubset<T, AreaUpdateArgs>
    ): CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaDeleteManyArgs>(
      args?: SelectSubset<T, AreaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaUpdateManyArgs>(
      args: SelectSubset<T, AreaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
    **/
    upsert<T extends AreaUpsertArgs>(
      args: SelectSubset<T, AreaUpsertArgs>
    ): CheckSelect<T, Prisma__AreaClient<Area>, Prisma__AreaClient<AreaGetPayload<T>>>

    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): PrismaPromise<GetAreaAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AreaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DegreeRequirement<T extends DegreeRequirementArgs = {}>(args?: Subset<T, DegreeRequirementArgs>): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement | null >, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T> | null >>;

    AreaRequirement<T extends AreaRequirementArgs = {}>(args?: Subset<T, AreaRequirementArgs>): CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement | null >, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T> | null >>;

    ElectiveStatus<T extends ElectiveStatusFindManyArgs = {}>(args?: Subset<T, ElectiveStatusFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ElectiveStatus>>, PrismaPromise<Array<ElectiveStatusGetPayload<T>>>>;

    SubArea<T extends SubAreaArgs = {}>(args?: Subset<T, SubAreaArgs>): CheckSelect<T, Prisma__SubAreaClient<SubArea | null >, Prisma__SubAreaClient<SubAreaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * Throw an Error if a Area can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Area to fetch.
    **/
    where: AreaWhereUniqueInput
  }


  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * Throw an Error if a Area can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Area to fetch.
    **/
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
    **/
    orderBy?: Enumerable<AreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
    **/
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
    **/
    distinct?: Enumerable<AreaScalarFieldEnum>
  }


  /**
   * Area findMany
   */
  export type AreaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * Filter, which Areas to fetch.
    **/
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
    **/
    orderBy?: Enumerable<AreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
    **/
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
    **/
    skip?: number
    distinct?: Enumerable<AreaScalarFieldEnum>
  }


  /**
   * Area create
   */
  export type AreaCreateArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * The data needed to create a Area.
    **/
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }


  /**
   * Area update
   */
  export type AreaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * The data needed to update a Area.
    **/
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
    **/
    where: AreaWhereUniqueInput
  }


  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs = {
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    where?: AreaWhereInput
  }


  /**
   * Area upsert
   */
  export type AreaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * The filter to search for the Area to update in case it exists.
    **/
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
    **/
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }


  /**
   * Area delete
   */
  export type AreaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
    /**
     * Filter which Area to delete.
    **/
    where: AreaWhereUniqueInput
  }


  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs = {
    where?: AreaWhereInput
  }


  /**
   * Area without action
   */
  export type AreaArgs = {
    /**
     * Select specific fields to fetch from the Area
    **/
    select?: AreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaInclude | null
  }



  /**
   * Model AreaRequirement
   */


  export type AggregateAreaRequirement = {
    count: AreaRequirementCountAggregateOutputType | null
    avg: AreaRequirementAvgAggregateOutputType | null
    sum: AreaRequirementSumAggregateOutputType | null
    min: AreaRequirementMinAggregateOutputType | null
    max: AreaRequirementMaxAggregateOutputType | null
  }

  export type AreaRequirementAvgAggregateOutputType = {
    areaID: number
    nSubAreas: number | null
    nCourses: number | null
    nCredits: number | null
  }

  export type AreaRequirementSumAggregateOutputType = {
    areaID: number
    nSubAreas: number | null
    nCourses: number | null
    nCredits: number | null
  }

  export type AreaRequirementMinAggregateOutputType = {
    areaID: number
    nSubAreas: number | null
    nCourses: number | null
    nCredits: number | null
  }

  export type AreaRequirementMaxAggregateOutputType = {
    areaID: number
    nSubAreas: number | null
    nCourses: number | null
    nCredits: number | null
  }

  export type AreaRequirementCountAggregateOutputType = {
    areaID: number
    nSubAreas: number | null
    nCourses: number | null
    nCredits: number | null
    _all: number
  }


  export type AreaRequirementAvgAggregateInputType = {
    areaID?: true
    nSubAreas?: true
    nCourses?: true
    nCredits?: true
  }

  export type AreaRequirementSumAggregateInputType = {
    areaID?: true
    nSubAreas?: true
    nCourses?: true
    nCredits?: true
  }

  export type AreaRequirementMinAggregateInputType = {
    areaID?: true
    nSubAreas?: true
    nCourses?: true
    nCredits?: true
  }

  export type AreaRequirementMaxAggregateInputType = {
    areaID?: true
    nSubAreas?: true
    nCourses?: true
    nCredits?: true
  }

  export type AreaRequirementCountAggregateInputType = {
    areaID?: true
    nSubAreas?: true
    nCourses?: true
    nCredits?: true
    _all?: true
  }

  export type AreaRequirementAggregateArgs = {
    /**
     * Filter which AreaRequirement to aggregate.
    **/
    where?: AreaRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaRequirements to fetch.
    **/
    orderBy?: Enumerable<AreaRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AreaRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaRequirements
    **/
    count?: true | AreaRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AreaRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AreaRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AreaRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AreaRequirementMaxAggregateInputType
  }

  export type GetAreaRequirementAggregateType<T extends AreaRequirementAggregateArgs> = {
    [P in keyof T & keyof AggregateAreaRequirement]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaRequirement[P]>
      : GetScalarType<T[P], AggregateAreaRequirement[P]>
  }



  export type AreaRequirementSelect = {
    areaID?: boolean
    nSubAreas?: boolean
    nCourses?: boolean
    nCredits?: boolean
    Area?: boolean | AreaArgs
  }

  export type AreaRequirementInclude = {
    Area?: boolean | AreaArgs
  }

  export type AreaRequirementGetPayload<
    S extends boolean | null | undefined | AreaRequirementArgs,
    U = keyof S
      > = S extends true
        ? AreaRequirement
    : S extends undefined
    ? never
    : S extends AreaRequirementArgs | AreaRequirementFindManyArgs
    ?'include' extends U
    ? AreaRequirement  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Area'
        ? AreaGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AreaRequirement ?AreaRequirement [P]
  : 
          P extends 'Area'
        ? AreaGetPayload<S['select'][P]> : never
  } 
    : AreaRequirement
  : AreaRequirement


  type AreaRequirementCountArgs = Merge<
    Omit<AreaRequirementFindManyArgs, 'select' | 'include'> & {
      select?: AreaRequirementCountAggregateInputType | true
    }
  >

  export interface AreaRequirementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AreaRequirement that matches the filter.
     * @param {AreaRequirementFindUniqueArgs} args - Arguments to find a AreaRequirement
     * @example
     * // Get one AreaRequirement
     * const areaRequirement = await prisma.areaRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaRequirementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AreaRequirementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AreaRequirement'> extends True ? CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>> : CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement | null >, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T> | null >>

    /**
     * Find the first AreaRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaRequirementFindFirstArgs} args - Arguments to find a AreaRequirement
     * @example
     * // Get one AreaRequirement
     * const areaRequirement = await prisma.areaRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaRequirementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AreaRequirementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AreaRequirement'> extends True ? CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>> : CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement | null >, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T> | null >>

    /**
     * Find zero or more AreaRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaRequirementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaRequirements
     * const areaRequirements = await prisma.areaRequirement.findMany()
     * 
     * // Get first 10 AreaRequirements
     * const areaRequirements = await prisma.areaRequirement.findMany({ take: 10 })
     * 
     * // Only select the `areaID`
     * const areaRequirementWithAreaIDOnly = await prisma.areaRequirement.findMany({ select: { areaID: true } })
     * 
    **/
    findMany<T extends AreaRequirementFindManyArgs>(
      args?: SelectSubset<T, AreaRequirementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AreaRequirement>>, PrismaPromise<Array<AreaRequirementGetPayload<T>>>>

    /**
     * Create a AreaRequirement.
     * @param {AreaRequirementCreateArgs} args - Arguments to create a AreaRequirement.
     * @example
     * // Create one AreaRequirement
     * const AreaRequirement = await prisma.areaRequirement.create({
     *   data: {
     *     // ... data to create a AreaRequirement
     *   }
     * })
     * 
    **/
    create<T extends AreaRequirementCreateArgs>(
      args: SelectSubset<T, AreaRequirementCreateArgs>
    ): CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>>

    /**
     * Delete a AreaRequirement.
     * @param {AreaRequirementDeleteArgs} args - Arguments to delete one AreaRequirement.
     * @example
     * // Delete one AreaRequirement
     * const AreaRequirement = await prisma.areaRequirement.delete({
     *   where: {
     *     // ... filter to delete one AreaRequirement
     *   }
     * })
     * 
    **/
    delete<T extends AreaRequirementDeleteArgs>(
      args: SelectSubset<T, AreaRequirementDeleteArgs>
    ): CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>>

    /**
     * Update one AreaRequirement.
     * @param {AreaRequirementUpdateArgs} args - Arguments to update one AreaRequirement.
     * @example
     * // Update one AreaRequirement
     * const areaRequirement = await prisma.areaRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaRequirementUpdateArgs>(
      args: SelectSubset<T, AreaRequirementUpdateArgs>
    ): CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>>

    /**
     * Delete zero or more AreaRequirements.
     * @param {AreaRequirementDeleteManyArgs} args - Arguments to filter AreaRequirements to delete.
     * @example
     * // Delete a few AreaRequirements
     * const { count } = await prisma.areaRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaRequirementDeleteManyArgs>(
      args?: SelectSubset<T, AreaRequirementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaRequirements
     * const areaRequirement = await prisma.areaRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaRequirementUpdateManyArgs>(
      args: SelectSubset<T, AreaRequirementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AreaRequirement.
     * @param {AreaRequirementUpsertArgs} args - Arguments to update or create a AreaRequirement.
     * @example
     * // Update or create a AreaRequirement
     * const areaRequirement = await prisma.areaRequirement.upsert({
     *   create: {
     *     // ... data to create a AreaRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaRequirement we want to update
     *   }
     * })
    **/
    upsert<T extends AreaRequirementUpsertArgs>(
      args: SelectSubset<T, AreaRequirementUpsertArgs>
    ): CheckSelect<T, Prisma__AreaRequirementClient<AreaRequirement>, Prisma__AreaRequirementClient<AreaRequirementGetPayload<T>>>

    /**
     * Count the number of AreaRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaRequirementCountArgs} args - Arguments to filter AreaRequirements to count.
     * @example
     * // Count the number of AreaRequirements
     * const count = await prisma.areaRequirement.count({
     *   where: {
     *     // ... the filter for the AreaRequirements we want to count
     *   }
     * })
    **/
    count<T extends AreaRequirementCountArgs>(
      args?: Subset<T, AreaRequirementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaRequirementAggregateArgs>(args: Subset<T, AreaRequirementAggregateArgs>): PrismaPromise<GetAreaRequirementAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AreaRequirementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Area<T extends AreaArgs = {}>(args?: Subset<T, AreaArgs>): CheckSelect<T, Prisma__AreaClient<Area | null >, Prisma__AreaClient<AreaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AreaRequirement findUnique
   */
  export type AreaRequirementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * Throw an Error if a AreaRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AreaRequirement to fetch.
    **/
    where: AreaRequirementWhereUniqueInput
  }


  /**
   * AreaRequirement findFirst
   */
  export type AreaRequirementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * Throw an Error if a AreaRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AreaRequirement to fetch.
    **/
    where?: AreaRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaRequirements to fetch.
    **/
    orderBy?: Enumerable<AreaRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaRequirements.
    **/
    cursor?: AreaRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaRequirements.
    **/
    distinct?: Enumerable<AreaRequirementScalarFieldEnum>
  }


  /**
   * AreaRequirement findMany
   */
  export type AreaRequirementFindManyArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * Filter, which AreaRequirements to fetch.
    **/
    where?: AreaRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaRequirements to fetch.
    **/
    orderBy?: Enumerable<AreaRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaRequirements.
    **/
    cursor?: AreaRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaRequirements.
    **/
    skip?: number
    distinct?: Enumerable<AreaRequirementScalarFieldEnum>
  }


  /**
   * AreaRequirement create
   */
  export type AreaRequirementCreateArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * The data needed to create a AreaRequirement.
    **/
    data: XOR<AreaRequirementCreateInput, AreaRequirementUncheckedCreateInput>
  }


  /**
   * AreaRequirement update
   */
  export type AreaRequirementUpdateArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * The data needed to update a AreaRequirement.
    **/
    data: XOR<AreaRequirementUpdateInput, AreaRequirementUncheckedUpdateInput>
    /**
     * Choose, which AreaRequirement to update.
    **/
    where: AreaRequirementWhereUniqueInput
  }


  /**
   * AreaRequirement updateMany
   */
  export type AreaRequirementUpdateManyArgs = {
    data: XOR<AreaRequirementUpdateManyMutationInput, AreaRequirementUncheckedUpdateManyInput>
    where?: AreaRequirementWhereInput
  }


  /**
   * AreaRequirement upsert
   */
  export type AreaRequirementUpsertArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * The filter to search for the AreaRequirement to update in case it exists.
    **/
    where: AreaRequirementWhereUniqueInput
    /**
     * In case the AreaRequirement found by the `where` argument doesn't exist, create a new AreaRequirement with this data.
    **/
    create: XOR<AreaRequirementCreateInput, AreaRequirementUncheckedCreateInput>
    /**
     * In case the AreaRequirement was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AreaRequirementUpdateInput, AreaRequirementUncheckedUpdateInput>
  }


  /**
   * AreaRequirement delete
   */
  export type AreaRequirementDeleteArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
    /**
     * Filter which AreaRequirement to delete.
    **/
    where: AreaRequirementWhereUniqueInput
  }


  /**
   * AreaRequirement deleteMany
   */
  export type AreaRequirementDeleteManyArgs = {
    where?: AreaRequirementWhereInput
  }


  /**
   * AreaRequirement without action
   */
  export type AreaRequirementArgs = {
    /**
     * Select specific fields to fetch from the AreaRequirement
    **/
    select?: AreaRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaRequirementInclude | null
  }



  /**
   * Model Comments
   */


  export type AggregateComments = {
    count: CommentsCountAggregateOutputType | null
    avg: CommentsAvgAggregateOutputType | null
    sum: CommentsSumAggregateOutputType | null
    min: CommentsMinAggregateOutputType | null
    max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    studentID: number
    GPDID: number
  }

  export type CommentsSumAggregateOutputType = {
    studentID: number
    GPDID: number
  }

  export type CommentsMinAggregateOutputType = {
    studentID: number
    GPDID: number
    comment: string | null
    date: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    studentID: number
    GPDID: number
    comment: string | null
    date: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    studentID: number
    GPDID: number
    comment: number | null
    date: number | null
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    studentID?: true
    GPDID?: true
  }

  export type CommentsSumAggregateInputType = {
    studentID?: true
    GPDID?: true
  }

  export type CommentsMinAggregateInputType = {
    studentID?: true
    GPDID?: true
    comment?: true
    date?: true
  }

  export type CommentsMaxAggregateInputType = {
    studentID?: true
    GPDID?: true
    comment?: true
    date?: true
  }

  export type CommentsCountAggregateInputType = {
    studentID?: true
    GPDID?: true
    comment?: true
    date?: true
    _all?: true
  }

  export type CommentsAggregateArgs = {
    /**
     * Filter which Comments to aggregate.
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
    [P in keyof T & keyof AggregateComments]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }



  export type CommentsSelect = {
    studentID?: boolean
    GPDID?: boolean
    comment?: boolean
    date?: boolean
    GPD?: boolean | GPDArgs
    Student?: boolean | StudentArgs
  }

  export type CommentsInclude = {
    GPD?: boolean | GPDArgs
    Student?: boolean | StudentArgs
  }

  export type CommentsGetPayload<
    S extends boolean | null | undefined | CommentsArgs,
    U = keyof S
      > = S extends true
        ? Comments
    : S extends undefined
    ? never
    : S extends CommentsArgs | CommentsFindManyArgs
    ?'include' extends U
    ? Comments  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'GPD'
        ? GPDGetPayload<S['include'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Comments ?Comments [P]
  : 
          P extends 'GPD'
        ? GPDGetPayload<S['select'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : Comments
  : Comments


  type CommentsCountArgs = Merge<
    Omit<CommentsFindManyArgs, 'select' | 'include'> & {
      select?: CommentsCountAggregateInputType | true
    }
  >

  export interface CommentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comments'> extends True ? CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>> : CheckSelect<T, Prisma__CommentsClient<Comments | null >, Prisma__CommentsClient<CommentsGetPayload<T> | null >>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comments'> extends True ? CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>> : CheckSelect<T, Prisma__CommentsClient<Comments | null >, Prisma__CommentsClient<CommentsGetPayload<T> | null >>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const commentsWithStudentIDOnly = await prisma.comments.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends CommentsFindManyArgs>(
      args?: SelectSubset<T, CommentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
    **/
    create<T extends CommentsCreateArgs>(
      args: SelectSubset<T, CommentsCreateArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
    **/
    delete<T extends CommentsDeleteArgs>(
      args: SelectSubset<T, CommentsDeleteArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentsUpdateArgs>(
      args: SelectSubset<T, CommentsUpdateArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentsDeleteManyArgs>(
      args?: SelectSubset<T, CommentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentsUpdateManyArgs>(
      args: SelectSubset<T, CommentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
    **/
    upsert<T extends CommentsUpsertArgs>(
      args: SelectSubset<T, CommentsUpsertArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): PrismaPromise<GetCommentsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    GPD<T extends GPDArgs = {}>(args?: Subset<T, GPDArgs>): CheckSelect<T, Prisma__GPDClient<GPD | null >, Prisma__GPDClient<GPDGetPayload<T> | null >>;

    Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * Throw an Error if a Comments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comments to fetch.
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * Throw an Error if a Comments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comments to fetch.
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
    **/
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * Filter, which Comments to fetch.
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * Comments create
   */
  export type CommentsCreateArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * The data needed to create a Comments.
    **/
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }


  /**
   * Comments update
   */
  export type CommentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * The data needed to update a Comments.
    **/
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs = {
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    where?: CommentsWhereInput
  }


  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * The filter to search for the Comments to update in case it exists.
    **/
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
    **/
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }


  /**
   * Comments delete
   */
  export type CommentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
    /**
     * Filter which Comments to delete.
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs = {
    where?: CommentsWhereInput
  }


  /**
   * Comments without action
   */
  export type CommentsArgs = {
    /**
     * Select specific fields to fetch from the Comments
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentsInclude | null
  }



  /**
   * Model Course
   */


  export type AggregateCourse = {
    count: CourseCountAggregateOutputType | null
    avg: CourseAvgAggregateOutputType | null
    sum: CourseSumAggregateOutputType | null
    min: CourseMinAggregateOutputType | null
    max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
    courseNum: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
    courseNum: number | null
  }

  export type CourseMinAggregateOutputType = {
    courseID: string | null
    departID: string | null
    name: string | null
    description: string | null
    credits: number | null
    courseNum: number | null
  }

  export type CourseMaxAggregateOutputType = {
    courseID: string | null
    departID: string | null
    name: string | null
    description: string | null
    credits: number | null
    courseNum: number | null
  }

  export type CourseCountAggregateOutputType = {
    courseID: number | null
    departID: number | null
    name: number | null
    description: number | null
    credits: number | null
    courseNum: number | null
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
    courseNum?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
    courseNum?: true
  }

  export type CourseMinAggregateInputType = {
    courseID?: true
    departID?: true
    name?: true
    description?: true
    credits?: true
    courseNum?: true
  }

  export type CourseMaxAggregateInputType = {
    courseID?: true
    departID?: true
    name?: true
    description?: true
    credits?: true
    courseNum?: true
  }

  export type CourseCountAggregateInputType = {
    courseID?: true
    departID?: true
    name?: true
    description?: true
    credits?: true
    courseNum?: true
    _all?: true
  }

  export type CourseAggregateArgs = {
    /**
     * Filter which Course to aggregate.
    **/
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
    **/
    orderBy?: Enumerable<CourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
    [P in keyof T & keyof AggregateCourse]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }



  export type CourseSelect = {
    courseID?: boolean
    departID?: boolean
    name?: boolean
    description?: boolean
    credits?: boolean
    courseNum?: boolean
    Department?: boolean | DepartmentArgs
    CourseOffering?: boolean | CourseOfferingFindManyArgs
    prerequisite_CourseToprerequisite_courseID?: boolean | prerequisiteFindManyArgs
    prerequisite_CourseToprerequisite_prerequisiteID?: boolean | prerequisiteFindManyArgs
    proficiencyRequirement?: boolean | proficiencyRequirementFindManyArgs
    requiredCourse?: boolean | requiredCourseFindManyArgs
    RequiredStatus?: boolean | RequiredStatusFindManyArgs
  }

  export type CourseInclude = {
    Department?: boolean | DepartmentArgs
    CourseOffering?: boolean | CourseOfferingFindManyArgs
    prerequisite_CourseToprerequisite_courseID?: boolean | prerequisiteFindManyArgs
    prerequisite_CourseToprerequisite_prerequisiteID?: boolean | prerequisiteFindManyArgs
    proficiencyRequirement?: boolean | proficiencyRequirementFindManyArgs
    requiredCourse?: boolean | requiredCourseFindManyArgs
    RequiredStatus?: boolean | RequiredStatusFindManyArgs
  }

  export type CourseGetPayload<
    S extends boolean | null | undefined | CourseArgs,
    U = keyof S
      > = S extends true
        ? Course
    : S extends undefined
    ? never
    : S extends CourseArgs | CourseFindManyArgs
    ?'include' extends U
    ? Course  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Department'
        ? DepartmentGetPayload<S['include'][P]> | null :
        P extends 'CourseOffering'
        ? Array < CourseOfferingGetPayload<S['include'][P]>>  :
        P extends 'prerequisite_CourseToprerequisite_courseID'
        ? Array < prerequisiteGetPayload<S['include'][P]>>  :
        P extends 'prerequisite_CourseToprerequisite_prerequisiteID'
        ? Array < prerequisiteGetPayload<S['include'][P]>>  :
        P extends 'proficiencyRequirement'
        ? Array < proficiencyRequirementGetPayload<S['include'][P]>>  :
        P extends 'requiredCourse'
        ? Array < requiredCourseGetPayload<S['include'][P]>>  :
        P extends 'RequiredStatus'
        ? Array < RequiredStatusGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Course ?Course [P]
  : 
          P extends 'Department'
        ? DepartmentGetPayload<S['select'][P]> | null :
        P extends 'CourseOffering'
        ? Array < CourseOfferingGetPayload<S['select'][P]>>  :
        P extends 'prerequisite_CourseToprerequisite_courseID'
        ? Array < prerequisiteGetPayload<S['select'][P]>>  :
        P extends 'prerequisite_CourseToprerequisite_prerequisiteID'
        ? Array < prerequisiteGetPayload<S['select'][P]>>  :
        P extends 'proficiencyRequirement'
        ? Array < proficiencyRequirementGetPayload<S['select'][P]>>  :
        P extends 'requiredCourse'
        ? Array < requiredCourseGetPayload<S['select'][P]>>  :
        P extends 'RequiredStatus'
        ? Array < RequiredStatusGetPayload<S['select'][P]>>  : never
  } 
    : Course
  : Course


  type CourseCountArgs = Merge<
    Omit<CourseFindManyArgs, 'select' | 'include'> & {
      select?: CourseCountAggregateInputType | true
    }
  >

  export interface CourseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Course'> extends True ? CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>> : CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Course'> extends True ? CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>> : CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `courseID`
     * const courseWithCourseIDOnly = await prisma.course.findMany({ select: { courseID: true } })
     * 
    **/
    findMany<T extends CourseFindManyArgs>(
      args?: SelectSubset<T, CourseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Course>>, PrismaPromise<Array<CourseGetPayload<T>>>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
    **/
    create<T extends CourseCreateArgs>(
      args: SelectSubset<T, CourseCreateArgs>
    ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
    **/
    delete<T extends CourseDeleteArgs>(
      args: SelectSubset<T, CourseDeleteArgs>
    ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseUpdateArgs>(
      args: SelectSubset<T, CourseUpdateArgs>
    ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseDeleteManyArgs>(
      args?: SelectSubset<T, CourseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseUpdateManyArgs>(
      args: SelectSubset<T, CourseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
    **/
    upsert<T extends CourseUpsertArgs>(
      args: SelectSubset<T, CourseUpsertArgs>
    ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): PrismaPromise<GetCourseAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Department<T extends DepartmentArgs = {}>(args?: Subset<T, DepartmentArgs>): CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>;

    CourseOffering<T extends CourseOfferingFindManyArgs = {}>(args?: Subset<T, CourseOfferingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseOffering>>, PrismaPromise<Array<CourseOfferingGetPayload<T>>>>;

    prerequisite_CourseToprerequisite_courseID<T extends prerequisiteFindManyArgs = {}>(args?: Subset<T, prerequisiteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<prerequisite>>, PrismaPromise<Array<prerequisiteGetPayload<T>>>>;

    prerequisite_CourseToprerequisite_prerequisiteID<T extends prerequisiteFindManyArgs = {}>(args?: Subset<T, prerequisiteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<prerequisite>>, PrismaPromise<Array<prerequisiteGetPayload<T>>>>;

    proficiencyRequirement<T extends proficiencyRequirementFindManyArgs = {}>(args?: Subset<T, proficiencyRequirementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<proficiencyRequirement>>, PrismaPromise<Array<proficiencyRequirementGetPayload<T>>>>;

    requiredCourse<T extends requiredCourseFindManyArgs = {}>(args?: Subset<T, requiredCourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<requiredCourse>>, PrismaPromise<Array<requiredCourseGetPayload<T>>>>;

    RequiredStatus<T extends RequiredStatusFindManyArgs = {}>(args?: Subset<T, RequiredStatusFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequiredStatus>>, PrismaPromise<Array<RequiredStatusGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * Throw an Error if a Course can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Course to fetch.
    **/
    where: CourseWhereUniqueInput
  }


  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * Throw an Error if a Course can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Course to fetch.
    **/
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
    **/
    orderBy?: Enumerable<CourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
    **/
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
    **/
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * Course findMany
   */
  export type CourseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * Filter, which Courses to fetch.
    **/
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
    **/
    orderBy?: Enumerable<CourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
    **/
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
    **/
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * Course create
   */
  export type CourseCreateArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * The data needed to create a Course.
    **/
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }


  /**
   * Course update
   */
  export type CourseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * The data needed to update a Course.
    **/
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
    **/
    where: CourseWhereUniqueInput
  }


  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs = {
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    where?: CourseWhereInput
  }


  /**
   * Course upsert
   */
  export type CourseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * The filter to search for the Course to update in case it exists.
    **/
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
    **/
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }


  /**
   * Course delete
   */
  export type CourseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
    /**
     * Filter which Course to delete.
    **/
    where: CourseWhereUniqueInput
  }


  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs = {
    where?: CourseWhereInput
  }


  /**
   * Course without action
   */
  export type CourseArgs = {
    /**
     * Select specific fields to fetch from the Course
    **/
    select?: CourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseInclude | null
  }



  /**
   * Model CourseOffering
   */


  export type AggregateCourseOffering = {
    count: CourseOfferingCountAggregateOutputType | null
    avg: CourseOfferingAvgAggregateOutputType | null
    sum: CourseOfferingSumAggregateOutputType | null
    min: CourseOfferingMinAggregateOutputType | null
    max: CourseOfferingMaxAggregateOutputType | null
  }

  export type CourseOfferingAvgAggregateOutputType = {
    year: number | null
  }

  export type CourseOfferingSumAggregateOutputType = {
    year: number | null
  }

  export type CourseOfferingMinAggregateOutputType = {
    courseOfferingID: string | null
    courseID: string | null
    semester: CourseOffering_semester | null
    year: number | null
    section: string | null
  }

  export type CourseOfferingMaxAggregateOutputType = {
    courseOfferingID: string | null
    courseID: string | null
    semester: CourseOffering_semester | null
    year: number | null
    section: string | null
  }

  export type CourseOfferingCountAggregateOutputType = {
    courseOfferingID: number | null
    courseID: number | null
    semester: number | null
    year: number | null
    section: number | null
    _all: number
  }


  export type CourseOfferingAvgAggregateInputType = {
    year?: true
  }

  export type CourseOfferingSumAggregateInputType = {
    year?: true
  }

  export type CourseOfferingMinAggregateInputType = {
    courseOfferingID?: true
    courseID?: true
    semester?: true
    year?: true
    section?: true
  }

  export type CourseOfferingMaxAggregateInputType = {
    courseOfferingID?: true
    courseID?: true
    semester?: true
    year?: true
    section?: true
  }

  export type CourseOfferingCountAggregateInputType = {
    courseOfferingID?: true
    courseID?: true
    semester?: true
    year?: true
    section?: true
    _all?: true
  }

  export type CourseOfferingAggregateArgs = {
    /**
     * Filter which CourseOffering to aggregate.
    **/
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
    **/
    orderBy?: Enumerable<CourseOfferingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseOfferings
    **/
    count?: true | CourseOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CourseOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CourseOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CourseOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CourseOfferingMaxAggregateInputType
  }

  export type GetCourseOfferingAggregateType<T extends CourseOfferingAggregateArgs> = {
    [P in keyof T & keyof AggregateCourseOffering]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseOffering[P]>
      : GetScalarType<T[P], AggregateCourseOffering[P]>
  }



  export type CourseOfferingSelect = {
    courseOfferingID?: boolean
    courseID?: boolean
    semester?: boolean
    year?: boolean
    section?: boolean
    Course?: boolean | CourseArgs
    TimeSlotDay?: boolean | TimeSlotDayFindManyArgs
    TimeSlotTime?: boolean | TimeSlotTimeArgs
  }

  export type CourseOfferingInclude = {
    Course?: boolean | CourseArgs
    TimeSlotDay?: boolean | TimeSlotDayFindManyArgs
    TimeSlotTime?: boolean | TimeSlotTimeArgs
  }

  export type CourseOfferingGetPayload<
    S extends boolean | null | undefined | CourseOfferingArgs,
    U = keyof S
      > = S extends true
        ? CourseOffering
    : S extends undefined
    ? never
    : S extends CourseOfferingArgs | CourseOfferingFindManyArgs
    ?'include' extends U
    ? CourseOffering  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course'
        ? CourseGetPayload<S['include'][P]> | null :
        P extends 'TimeSlotDay'
        ? Array < TimeSlotDayGetPayload<S['include'][P]>>  :
        P extends 'TimeSlotTime'
        ? TimeSlotTimeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CourseOffering ?CourseOffering [P]
  : 
          P extends 'Course'
        ? CourseGetPayload<S['select'][P]> | null :
        P extends 'TimeSlotDay'
        ? Array < TimeSlotDayGetPayload<S['select'][P]>>  :
        P extends 'TimeSlotTime'
        ? TimeSlotTimeGetPayload<S['select'][P]> | null : never
  } 
    : CourseOffering
  : CourseOffering


  type CourseOfferingCountArgs = Merge<
    Omit<CourseOfferingFindManyArgs, 'select' | 'include'> & {
      select?: CourseOfferingCountAggregateInputType | true
    }
  >

  export interface CourseOfferingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CourseOffering that matches the filter.
     * @param {CourseOfferingFindUniqueArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseOfferingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseOfferingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CourseOffering'> extends True ? CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>> : CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering | null >, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T> | null >>

    /**
     * Find the first CourseOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindFirstArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseOfferingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseOfferingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CourseOffering'> extends True ? CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>> : CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering | null >, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T> | null >>

    /**
     * Find zero or more CourseOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany()
     * 
     * // Get first 10 CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany({ take: 10 })
     * 
     * // Only select the `courseOfferingID`
     * const courseOfferingWithCourseOfferingIDOnly = await prisma.courseOffering.findMany({ select: { courseOfferingID: true } })
     * 
    **/
    findMany<T extends CourseOfferingFindManyArgs>(
      args?: SelectSubset<T, CourseOfferingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CourseOffering>>, PrismaPromise<Array<CourseOfferingGetPayload<T>>>>

    /**
     * Create a CourseOffering.
     * @param {CourseOfferingCreateArgs} args - Arguments to create a CourseOffering.
     * @example
     * // Create one CourseOffering
     * const CourseOffering = await prisma.courseOffering.create({
     *   data: {
     *     // ... data to create a CourseOffering
     *   }
     * })
     * 
    **/
    create<T extends CourseOfferingCreateArgs>(
      args: SelectSubset<T, CourseOfferingCreateArgs>
    ): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>>

    /**
     * Delete a CourseOffering.
     * @param {CourseOfferingDeleteArgs} args - Arguments to delete one CourseOffering.
     * @example
     * // Delete one CourseOffering
     * const CourseOffering = await prisma.courseOffering.delete({
     *   where: {
     *     // ... filter to delete one CourseOffering
     *   }
     * })
     * 
    **/
    delete<T extends CourseOfferingDeleteArgs>(
      args: SelectSubset<T, CourseOfferingDeleteArgs>
    ): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>>

    /**
     * Update one CourseOffering.
     * @param {CourseOfferingUpdateArgs} args - Arguments to update one CourseOffering.
     * @example
     * // Update one CourseOffering
     * const courseOffering = await prisma.courseOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseOfferingUpdateArgs>(
      args: SelectSubset<T, CourseOfferingUpdateArgs>
    ): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>>

    /**
     * Delete zero or more CourseOfferings.
     * @param {CourseOfferingDeleteManyArgs} args - Arguments to filter CourseOfferings to delete.
     * @example
     * // Delete a few CourseOfferings
     * const { count } = await prisma.courseOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseOfferingDeleteManyArgs>(
      args?: SelectSubset<T, CourseOfferingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseOfferings
     * const courseOffering = await prisma.courseOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseOfferingUpdateManyArgs>(
      args: SelectSubset<T, CourseOfferingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseOffering.
     * @param {CourseOfferingUpsertArgs} args - Arguments to update or create a CourseOffering.
     * @example
     * // Update or create a CourseOffering
     * const courseOffering = await prisma.courseOffering.upsert({
     *   create: {
     *     // ... data to create a CourseOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseOffering we want to update
     *   }
     * })
    **/
    upsert<T extends CourseOfferingUpsertArgs>(
      args: SelectSubset<T, CourseOfferingUpsertArgs>
    ): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering>, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T>>>

    /**
     * Count the number of CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingCountArgs} args - Arguments to filter CourseOfferings to count.
     * @example
     * // Count the number of CourseOfferings
     * const count = await prisma.courseOffering.count({
     *   where: {
     *     // ... the filter for the CourseOfferings we want to count
     *   }
     * })
    **/
    count<T extends CourseOfferingCountArgs>(
      args?: Subset<T, CourseOfferingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseOfferingAggregateArgs>(args: Subset<T, CourseOfferingAggregateArgs>): PrismaPromise<GetCourseOfferingAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseOfferingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    TimeSlotDay<T extends TimeSlotDayFindManyArgs = {}>(args?: Subset<T, TimeSlotDayFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TimeSlotDay>>, PrismaPromise<Array<TimeSlotDayGetPayload<T>>>>;

    TimeSlotTime<T extends TimeSlotTimeArgs = {}>(args?: Subset<T, TimeSlotTimeArgs>): CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime | null >, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CourseOffering findUnique
   */
  export type CourseOfferingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * Throw an Error if a CourseOffering can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseOffering to fetch.
    **/
    where: CourseOfferingWhereUniqueInput
  }


  /**
   * CourseOffering findFirst
   */
  export type CourseOfferingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * Throw an Error if a CourseOffering can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseOffering to fetch.
    **/
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
    **/
    orderBy?: Enumerable<CourseOfferingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseOfferings.
    **/
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseOfferings.
    **/
    distinct?: Enumerable<CourseOfferingScalarFieldEnum>
  }


  /**
   * CourseOffering findMany
   */
  export type CourseOfferingFindManyArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * Filter, which CourseOfferings to fetch.
    **/
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
    **/
    orderBy?: Enumerable<CourseOfferingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseOfferings.
    **/
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
    **/
    skip?: number
    distinct?: Enumerable<CourseOfferingScalarFieldEnum>
  }


  /**
   * CourseOffering create
   */
  export type CourseOfferingCreateArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * The data needed to create a CourseOffering.
    **/
    data: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
  }


  /**
   * CourseOffering update
   */
  export type CourseOfferingUpdateArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * The data needed to update a CourseOffering.
    **/
    data: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
    /**
     * Choose, which CourseOffering to update.
    **/
    where: CourseOfferingWhereUniqueInput
  }


  /**
   * CourseOffering updateMany
   */
  export type CourseOfferingUpdateManyArgs = {
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyInput>
    where?: CourseOfferingWhereInput
  }


  /**
   * CourseOffering upsert
   */
  export type CourseOfferingUpsertArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * The filter to search for the CourseOffering to update in case it exists.
    **/
    where: CourseOfferingWhereUniqueInput
    /**
     * In case the CourseOffering found by the `where` argument doesn't exist, create a new CourseOffering with this data.
    **/
    create: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
    /**
     * In case the CourseOffering was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
  }


  /**
   * CourseOffering delete
   */
  export type CourseOfferingDeleteArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
    /**
     * Filter which CourseOffering to delete.
    **/
    where: CourseOfferingWhereUniqueInput
  }


  /**
   * CourseOffering deleteMany
   */
  export type CourseOfferingDeleteManyArgs = {
    where?: CourseOfferingWhereInput
  }


  /**
   * CourseOffering without action
   */
  export type CourseOfferingArgs = {
    /**
     * Select specific fields to fetch from the CourseOffering
    **/
    select?: CourseOfferingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CourseOfferingInclude | null
  }



  /**
   * Model CoursePlan
   */


  export type AggregateCoursePlan = {
    count: CoursePlanCountAggregateOutputType | null
    avg: CoursePlanAvgAggregateOutputType | null
    sum: CoursePlanSumAggregateOutputType | null
    min: CoursePlanMinAggregateOutputType | null
    max: CoursePlanMaxAggregateOutputType | null
  }

  export type CoursePlanAvgAggregateOutputType = {
    studentID: number
  }

  export type CoursePlanSumAggregateOutputType = {
    studentID: number
  }

  export type CoursePlanMinAggregateOutputType = {
    studentID: number
    valid: boolean | null
    complete: boolean | null
  }

  export type CoursePlanMaxAggregateOutputType = {
    studentID: number
    valid: boolean | null
    complete: boolean | null
  }

  export type CoursePlanCountAggregateOutputType = {
    studentID: number
    valid: number | null
    complete: number | null
    _all: number
  }


  export type CoursePlanAvgAggregateInputType = {
    studentID?: true
  }

  export type CoursePlanSumAggregateInputType = {
    studentID?: true
  }

  export type CoursePlanMinAggregateInputType = {
    studentID?: true
    valid?: true
    complete?: true
  }

  export type CoursePlanMaxAggregateInputType = {
    studentID?: true
    valid?: true
    complete?: true
  }

  export type CoursePlanCountAggregateInputType = {
    studentID?: true
    valid?: true
    complete?: true
    _all?: true
  }

  export type CoursePlanAggregateArgs = {
    /**
     * Filter which CoursePlan to aggregate.
    **/
    where?: CoursePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePlans to fetch.
    **/
    orderBy?: Enumerable<CoursePlanOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CoursePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePlans from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePlans.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoursePlans
    **/
    count?: true | CoursePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CoursePlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CoursePlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CoursePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CoursePlanMaxAggregateInputType
  }

  export type GetCoursePlanAggregateType<T extends CoursePlanAggregateArgs> = {
    [P in keyof T & keyof AggregateCoursePlan]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoursePlan[P]>
      : GetScalarType<T[P], AggregateCoursePlan[P]>
  }



  export type CoursePlanSelect = {
    studentID?: boolean
    valid?: boolean
    complete?: boolean
    Student?: boolean | StudentArgs
  }

  export type CoursePlanInclude = {
    Student?: boolean | StudentArgs
  }

  export type CoursePlanGetPayload<
    S extends boolean | null | undefined | CoursePlanArgs,
    U = keyof S
      > = S extends true
        ? CoursePlan
    : S extends undefined
    ? never
    : S extends CoursePlanArgs | CoursePlanFindManyArgs
    ?'include' extends U
    ? CoursePlan  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoursePlan ?CoursePlan [P]
  : 
          P extends 'Student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : CoursePlan
  : CoursePlan


  type CoursePlanCountArgs = Merge<
    Omit<CoursePlanFindManyArgs, 'select' | 'include'> & {
      select?: CoursePlanCountAggregateInputType | true
    }
  >

  export interface CoursePlanDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CoursePlan that matches the filter.
     * @param {CoursePlanFindUniqueArgs} args - Arguments to find a CoursePlan
     * @example
     * // Get one CoursePlan
     * const coursePlan = await prisma.coursePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoursePlanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoursePlanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CoursePlan'> extends True ? CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>> : CheckSelect<T, Prisma__CoursePlanClient<CoursePlan | null >, Prisma__CoursePlanClient<CoursePlanGetPayload<T> | null >>

    /**
     * Find the first CoursePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePlanFindFirstArgs} args - Arguments to find a CoursePlan
     * @example
     * // Get one CoursePlan
     * const coursePlan = await prisma.coursePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoursePlanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoursePlanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CoursePlan'> extends True ? CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>> : CheckSelect<T, Prisma__CoursePlanClient<CoursePlan | null >, Prisma__CoursePlanClient<CoursePlanGetPayload<T> | null >>

    /**
     * Find zero or more CoursePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoursePlans
     * const coursePlans = await prisma.coursePlan.findMany()
     * 
     * // Get first 10 CoursePlans
     * const coursePlans = await prisma.coursePlan.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const coursePlanWithStudentIDOnly = await prisma.coursePlan.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends CoursePlanFindManyArgs>(
      args?: SelectSubset<T, CoursePlanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CoursePlan>>, PrismaPromise<Array<CoursePlanGetPayload<T>>>>

    /**
     * Create a CoursePlan.
     * @param {CoursePlanCreateArgs} args - Arguments to create a CoursePlan.
     * @example
     * // Create one CoursePlan
     * const CoursePlan = await prisma.coursePlan.create({
     *   data: {
     *     // ... data to create a CoursePlan
     *   }
     * })
     * 
    **/
    create<T extends CoursePlanCreateArgs>(
      args: SelectSubset<T, CoursePlanCreateArgs>
    ): CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>>

    /**
     * Delete a CoursePlan.
     * @param {CoursePlanDeleteArgs} args - Arguments to delete one CoursePlan.
     * @example
     * // Delete one CoursePlan
     * const CoursePlan = await prisma.coursePlan.delete({
     *   where: {
     *     // ... filter to delete one CoursePlan
     *   }
     * })
     * 
    **/
    delete<T extends CoursePlanDeleteArgs>(
      args: SelectSubset<T, CoursePlanDeleteArgs>
    ): CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>>

    /**
     * Update one CoursePlan.
     * @param {CoursePlanUpdateArgs} args - Arguments to update one CoursePlan.
     * @example
     * // Update one CoursePlan
     * const coursePlan = await prisma.coursePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoursePlanUpdateArgs>(
      args: SelectSubset<T, CoursePlanUpdateArgs>
    ): CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>>

    /**
     * Delete zero or more CoursePlans.
     * @param {CoursePlanDeleteManyArgs} args - Arguments to filter CoursePlans to delete.
     * @example
     * // Delete a few CoursePlans
     * const { count } = await prisma.coursePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoursePlanDeleteManyArgs>(
      args?: SelectSubset<T, CoursePlanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoursePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoursePlans
     * const coursePlan = await prisma.coursePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoursePlanUpdateManyArgs>(
      args: SelectSubset<T, CoursePlanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CoursePlan.
     * @param {CoursePlanUpsertArgs} args - Arguments to update or create a CoursePlan.
     * @example
     * // Update or create a CoursePlan
     * const coursePlan = await prisma.coursePlan.upsert({
     *   create: {
     *     // ... data to create a CoursePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoursePlan we want to update
     *   }
     * })
    **/
    upsert<T extends CoursePlanUpsertArgs>(
      args: SelectSubset<T, CoursePlanUpsertArgs>
    ): CheckSelect<T, Prisma__CoursePlanClient<CoursePlan>, Prisma__CoursePlanClient<CoursePlanGetPayload<T>>>

    /**
     * Count the number of CoursePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePlanCountArgs} args - Arguments to filter CoursePlans to count.
     * @example
     * // Count the number of CoursePlans
     * const count = await prisma.coursePlan.count({
     *   where: {
     *     // ... the filter for the CoursePlans we want to count
     *   }
     * })
    **/
    count<T extends CoursePlanCountArgs>(
      args?: Subset<T, CoursePlanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoursePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursePlanAggregateArgs>(args: Subset<T, CoursePlanAggregateArgs>): PrismaPromise<GetCoursePlanAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CoursePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoursePlanClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CoursePlan findUnique
   */
  export type CoursePlanFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * Throw an Error if a CoursePlan can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoursePlan to fetch.
    **/
    where: CoursePlanWhereUniqueInput
  }


  /**
   * CoursePlan findFirst
   */
  export type CoursePlanFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * Throw an Error if a CoursePlan can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CoursePlan to fetch.
    **/
    where?: CoursePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePlans to fetch.
    **/
    orderBy?: Enumerable<CoursePlanOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePlans.
    **/
    cursor?: CoursePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePlans from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePlans.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePlans.
    **/
    distinct?: Enumerable<CoursePlanScalarFieldEnum>
  }


  /**
   * CoursePlan findMany
   */
  export type CoursePlanFindManyArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * Filter, which CoursePlans to fetch.
    **/
    where?: CoursePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePlans to fetch.
    **/
    orderBy?: Enumerable<CoursePlanOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoursePlans.
    **/
    cursor?: CoursePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePlans from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePlans.
    **/
    skip?: number
    distinct?: Enumerable<CoursePlanScalarFieldEnum>
  }


  /**
   * CoursePlan create
   */
  export type CoursePlanCreateArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * The data needed to create a CoursePlan.
    **/
    data: XOR<CoursePlanCreateInput, CoursePlanUncheckedCreateInput>
  }


  /**
   * CoursePlan update
   */
  export type CoursePlanUpdateArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * The data needed to update a CoursePlan.
    **/
    data: XOR<CoursePlanUpdateInput, CoursePlanUncheckedUpdateInput>
    /**
     * Choose, which CoursePlan to update.
    **/
    where: CoursePlanWhereUniqueInput
  }


  /**
   * CoursePlan updateMany
   */
  export type CoursePlanUpdateManyArgs = {
    data: XOR<CoursePlanUpdateManyMutationInput, CoursePlanUncheckedUpdateManyInput>
    where?: CoursePlanWhereInput
  }


  /**
   * CoursePlan upsert
   */
  export type CoursePlanUpsertArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * The filter to search for the CoursePlan to update in case it exists.
    **/
    where: CoursePlanWhereUniqueInput
    /**
     * In case the CoursePlan found by the `where` argument doesn't exist, create a new CoursePlan with this data.
    **/
    create: XOR<CoursePlanCreateInput, CoursePlanUncheckedCreateInput>
    /**
     * In case the CoursePlan was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CoursePlanUpdateInput, CoursePlanUncheckedUpdateInput>
  }


  /**
   * CoursePlan delete
   */
  export type CoursePlanDeleteArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
    /**
     * Filter which CoursePlan to delete.
    **/
    where: CoursePlanWhereUniqueInput
  }


  /**
   * CoursePlan deleteMany
   */
  export type CoursePlanDeleteManyArgs = {
    where?: CoursePlanWhereInput
  }


  /**
   * CoursePlan without action
   */
  export type CoursePlanArgs = {
    /**
     * Select specific fields to fetch from the CoursePlan
    **/
    select?: CoursePlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CoursePlanInclude | null
  }



  /**
   * Model DegreeRequirement
   */


  export type AggregateDegreeRequirement = {
    count: DegreeRequirementCountAggregateOutputType | null
    avg: DegreeRequirementAvgAggregateOutputType | null
    sum: DegreeRequirementSumAggregateOutputType | null
    min: DegreeRequirementMinAggregateOutputType | null
    max: DegreeRequirementMaxAggregateOutputType | null
  }

  export type DegreeRequirementAvgAggregateOutputType = {
    requirementID: number
    versionYear: number | null
    totalCredit: number | null
    timeLimit: number | null
    finalRecommended: number | null
    minGPA: number | null
  }

  export type DegreeRequirementSumAggregateOutputType = {
    requirementID: number
    versionYear: number | null
    totalCredit: number | null
    timeLimit: number | null
    finalRecommended: number | null
    minGPA: number | null
  }

  export type DegreeRequirementMinAggregateOutputType = {
    requirementID: number
    departID: string | null
    track: string | null
    versionSemester: DegreeRequirement_versionSemester | null
    versionYear: number | null
    totalCredit: number | null
    project: string | null
    thesis: string | null
    timeLimit: number | null
    finalRecommended: number | null
    minGPA: number | null
  }

  export type DegreeRequirementMaxAggregateOutputType = {
    requirementID: number
    departID: string | null
    track: string | null
    versionSemester: DegreeRequirement_versionSemester | null
    versionYear: number | null
    totalCredit: number | null
    project: string | null
    thesis: string | null
    timeLimit: number | null
    finalRecommended: number | null
    minGPA: number | null
  }

  export type DegreeRequirementCountAggregateOutputType = {
    requirementID: number
    departID: number | null
    track: number | null
    versionSemester: number | null
    versionYear: number | null
    totalCredit: number | null
    project: number | null
    thesis: number | null
    timeLimit: number | null
    finalRecommended: number | null
    minGPA: number | null
    _all: number
  }


  export type DegreeRequirementAvgAggregateInputType = {
    requirementID?: true
    versionYear?: true
    totalCredit?: true
    timeLimit?: true
    finalRecommended?: true
    minGPA?: true
  }

  export type DegreeRequirementSumAggregateInputType = {
    requirementID?: true
    versionYear?: true
    totalCredit?: true
    timeLimit?: true
    finalRecommended?: true
    minGPA?: true
  }

  export type DegreeRequirementMinAggregateInputType = {
    requirementID?: true
    departID?: true
    track?: true
    versionSemester?: true
    versionYear?: true
    totalCredit?: true
    project?: true
    thesis?: true
    timeLimit?: true
    finalRecommended?: true
    minGPA?: true
  }

  export type DegreeRequirementMaxAggregateInputType = {
    requirementID?: true
    departID?: true
    track?: true
    versionSemester?: true
    versionYear?: true
    totalCredit?: true
    project?: true
    thesis?: true
    timeLimit?: true
    finalRecommended?: true
    minGPA?: true
  }

  export type DegreeRequirementCountAggregateInputType = {
    requirementID?: true
    departID?: true
    track?: true
    versionSemester?: true
    versionYear?: true
    totalCredit?: true
    project?: true
    thesis?: true
    timeLimit?: true
    finalRecommended?: true
    minGPA?: true
    _all?: true
  }

  export type DegreeRequirementAggregateArgs = {
    /**
     * Filter which DegreeRequirement to aggregate.
    **/
    where?: DegreeRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DegreeRequirements to fetch.
    **/
    orderBy?: Enumerable<DegreeRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: DegreeRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DegreeRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DegreeRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DegreeRequirements
    **/
    count?: true | DegreeRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DegreeRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DegreeRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DegreeRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DegreeRequirementMaxAggregateInputType
  }

  export type GetDegreeRequirementAggregateType<T extends DegreeRequirementAggregateArgs> = {
    [P in keyof T & keyof AggregateDegreeRequirement]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDegreeRequirement[P]>
      : GetScalarType<T[P], AggregateDegreeRequirement[P]>
  }



  export type DegreeRequirementSelect = {
    requirementID?: boolean
    departID?: boolean
    track?: boolean
    versionSemester?: boolean
    versionYear?: boolean
    totalCredit?: boolean
    project?: boolean
    thesis?: boolean
    timeLimit?: boolean
    finalRecommended?: boolean
    minGPA?: boolean
    Department?: boolean | DepartmentArgs
    Area?: boolean | AreaFindManyArgs
    proficiencyRequirement?: boolean | proficiencyRequirementFindManyArgs
    requiredCourse?: boolean | requiredCourseFindManyArgs
  }

  export type DegreeRequirementInclude = {
    Department?: boolean | DepartmentArgs
    Area?: boolean | AreaFindManyArgs
    proficiencyRequirement?: boolean | proficiencyRequirementFindManyArgs
    requiredCourse?: boolean | requiredCourseFindManyArgs
  }

  export type DegreeRequirementGetPayload<
    S extends boolean | null | undefined | DegreeRequirementArgs,
    U = keyof S
      > = S extends true
        ? DegreeRequirement
    : S extends undefined
    ? never
    : S extends DegreeRequirementArgs | DegreeRequirementFindManyArgs
    ?'include' extends U
    ? DegreeRequirement  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Department'
        ? DepartmentGetPayload<S['include'][P]> | null :
        P extends 'Area'
        ? Array < AreaGetPayload<S['include'][P]>>  :
        P extends 'proficiencyRequirement'
        ? Array < proficiencyRequirementGetPayload<S['include'][P]>>  :
        P extends 'requiredCourse'
        ? Array < requiredCourseGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DegreeRequirement ?DegreeRequirement [P]
  : 
          P extends 'Department'
        ? DepartmentGetPayload<S['select'][P]> | null :
        P extends 'Area'
        ? Array < AreaGetPayload<S['select'][P]>>  :
        P extends 'proficiencyRequirement'
        ? Array < proficiencyRequirementGetPayload<S['select'][P]>>  :
        P extends 'requiredCourse'
        ? Array < requiredCourseGetPayload<S['select'][P]>>  : never
  } 
    : DegreeRequirement
  : DegreeRequirement


  type DegreeRequirementCountArgs = Merge<
    Omit<DegreeRequirementFindManyArgs, 'select' | 'include'> & {
      select?: DegreeRequirementCountAggregateInputType | true
    }
  >

  export interface DegreeRequirementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DegreeRequirement that matches the filter.
     * @param {DegreeRequirementFindUniqueArgs} args - Arguments to find a DegreeRequirement
     * @example
     * // Get one DegreeRequirement
     * const degreeRequirement = await prisma.degreeRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DegreeRequirementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DegreeRequirementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DegreeRequirement'> extends True ? CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>> : CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement | null >, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T> | null >>

    /**
     * Find the first DegreeRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DegreeRequirementFindFirstArgs} args - Arguments to find a DegreeRequirement
     * @example
     * // Get one DegreeRequirement
     * const degreeRequirement = await prisma.degreeRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DegreeRequirementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DegreeRequirementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DegreeRequirement'> extends True ? CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>> : CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement | null >, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T> | null >>

    /**
     * Find zero or more DegreeRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DegreeRequirementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DegreeRequirements
     * const degreeRequirements = await prisma.degreeRequirement.findMany()
     * 
     * // Get first 10 DegreeRequirements
     * const degreeRequirements = await prisma.degreeRequirement.findMany({ take: 10 })
     * 
     * // Only select the `requirementID`
     * const degreeRequirementWithRequirementIDOnly = await prisma.degreeRequirement.findMany({ select: { requirementID: true } })
     * 
    **/
    findMany<T extends DegreeRequirementFindManyArgs>(
      args?: SelectSubset<T, DegreeRequirementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DegreeRequirement>>, PrismaPromise<Array<DegreeRequirementGetPayload<T>>>>

    /**
     * Create a DegreeRequirement.
     * @param {DegreeRequirementCreateArgs} args - Arguments to create a DegreeRequirement.
     * @example
     * // Create one DegreeRequirement
     * const DegreeRequirement = await prisma.degreeRequirement.create({
     *   data: {
     *     // ... data to create a DegreeRequirement
     *   }
     * })
     * 
    **/
    create<T extends DegreeRequirementCreateArgs>(
      args: SelectSubset<T, DegreeRequirementCreateArgs>
    ): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>>

    /**
     * Delete a DegreeRequirement.
     * @param {DegreeRequirementDeleteArgs} args - Arguments to delete one DegreeRequirement.
     * @example
     * // Delete one DegreeRequirement
     * const DegreeRequirement = await prisma.degreeRequirement.delete({
     *   where: {
     *     // ... filter to delete one DegreeRequirement
     *   }
     * })
     * 
    **/
    delete<T extends DegreeRequirementDeleteArgs>(
      args: SelectSubset<T, DegreeRequirementDeleteArgs>
    ): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>>

    /**
     * Update one DegreeRequirement.
     * @param {DegreeRequirementUpdateArgs} args - Arguments to update one DegreeRequirement.
     * @example
     * // Update one DegreeRequirement
     * const degreeRequirement = await prisma.degreeRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DegreeRequirementUpdateArgs>(
      args: SelectSubset<T, DegreeRequirementUpdateArgs>
    ): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>>

    /**
     * Delete zero or more DegreeRequirements.
     * @param {DegreeRequirementDeleteManyArgs} args - Arguments to filter DegreeRequirements to delete.
     * @example
     * // Delete a few DegreeRequirements
     * const { count } = await prisma.degreeRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DegreeRequirementDeleteManyArgs>(
      args?: SelectSubset<T, DegreeRequirementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DegreeRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DegreeRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DegreeRequirements
     * const degreeRequirement = await prisma.degreeRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DegreeRequirementUpdateManyArgs>(
      args: SelectSubset<T, DegreeRequirementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DegreeRequirement.
     * @param {DegreeRequirementUpsertArgs} args - Arguments to update or create a DegreeRequirement.
     * @example
     * // Update or create a DegreeRequirement
     * const degreeRequirement = await prisma.degreeRequirement.upsert({
     *   create: {
     *     // ... data to create a DegreeRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DegreeRequirement we want to update
     *   }
     * })
    **/
    upsert<T extends DegreeRequirementUpsertArgs>(
      args: SelectSubset<T, DegreeRequirementUpsertArgs>
    ): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement>, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T>>>

    /**
     * Count the number of DegreeRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DegreeRequirementCountArgs} args - Arguments to filter DegreeRequirements to count.
     * @example
     * // Count the number of DegreeRequirements
     * const count = await prisma.degreeRequirement.count({
     *   where: {
     *     // ... the filter for the DegreeRequirements we want to count
     *   }
     * })
    **/
    count<T extends DegreeRequirementCountArgs>(
      args?: Subset<T, DegreeRequirementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DegreeRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DegreeRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DegreeRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DegreeRequirementAggregateArgs>(args: Subset<T, DegreeRequirementAggregateArgs>): PrismaPromise<GetDegreeRequirementAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for DegreeRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DegreeRequirementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Department<T extends DepartmentArgs = {}>(args?: Subset<T, DepartmentArgs>): CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>;

    Area<T extends AreaFindManyArgs = {}>(args?: Subset<T, AreaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Area>>, PrismaPromise<Array<AreaGetPayload<T>>>>;

    proficiencyRequirement<T extends proficiencyRequirementFindManyArgs = {}>(args?: Subset<T, proficiencyRequirementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<proficiencyRequirement>>, PrismaPromise<Array<proficiencyRequirementGetPayload<T>>>>;

    requiredCourse<T extends requiredCourseFindManyArgs = {}>(args?: Subset<T, requiredCourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<requiredCourse>>, PrismaPromise<Array<requiredCourseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DegreeRequirement findUnique
   */
  export type DegreeRequirementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * Throw an Error if a DegreeRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DegreeRequirement to fetch.
    **/
    where: DegreeRequirementWhereUniqueInput
  }


  /**
   * DegreeRequirement findFirst
   */
  export type DegreeRequirementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * Throw an Error if a DegreeRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DegreeRequirement to fetch.
    **/
    where?: DegreeRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DegreeRequirements to fetch.
    **/
    orderBy?: Enumerable<DegreeRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DegreeRequirements.
    **/
    cursor?: DegreeRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DegreeRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DegreeRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DegreeRequirements.
    **/
    distinct?: Enumerable<DegreeRequirementScalarFieldEnum>
  }


  /**
   * DegreeRequirement findMany
   */
  export type DegreeRequirementFindManyArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * Filter, which DegreeRequirements to fetch.
    **/
    where?: DegreeRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DegreeRequirements to fetch.
    **/
    orderBy?: Enumerable<DegreeRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DegreeRequirements.
    **/
    cursor?: DegreeRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DegreeRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DegreeRequirements.
    **/
    skip?: number
    distinct?: Enumerable<DegreeRequirementScalarFieldEnum>
  }


  /**
   * DegreeRequirement create
   */
  export type DegreeRequirementCreateArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * The data needed to create a DegreeRequirement.
    **/
    data: XOR<DegreeRequirementCreateInput, DegreeRequirementUncheckedCreateInput>
  }


  /**
   * DegreeRequirement update
   */
  export type DegreeRequirementUpdateArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * The data needed to update a DegreeRequirement.
    **/
    data: XOR<DegreeRequirementUpdateInput, DegreeRequirementUncheckedUpdateInput>
    /**
     * Choose, which DegreeRequirement to update.
    **/
    where: DegreeRequirementWhereUniqueInput
  }


  /**
   * DegreeRequirement updateMany
   */
  export type DegreeRequirementUpdateManyArgs = {
    data: XOR<DegreeRequirementUpdateManyMutationInput, DegreeRequirementUncheckedUpdateManyInput>
    where?: DegreeRequirementWhereInput
  }


  /**
   * DegreeRequirement upsert
   */
  export type DegreeRequirementUpsertArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * The filter to search for the DegreeRequirement to update in case it exists.
    **/
    where: DegreeRequirementWhereUniqueInput
    /**
     * In case the DegreeRequirement found by the `where` argument doesn't exist, create a new DegreeRequirement with this data.
    **/
    create: XOR<DegreeRequirementCreateInput, DegreeRequirementUncheckedCreateInput>
    /**
     * In case the DegreeRequirement was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<DegreeRequirementUpdateInput, DegreeRequirementUncheckedUpdateInput>
  }


  /**
   * DegreeRequirement delete
   */
  export type DegreeRequirementDeleteArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
    /**
     * Filter which DegreeRequirement to delete.
    **/
    where: DegreeRequirementWhereUniqueInput
  }


  /**
   * DegreeRequirement deleteMany
   */
  export type DegreeRequirementDeleteManyArgs = {
    where?: DegreeRequirementWhereInput
  }


  /**
   * DegreeRequirement without action
   */
  export type DegreeRequirementArgs = {
    /**
     * Select specific fields to fetch from the DegreeRequirement
    **/
    select?: DegreeRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DegreeRequirementInclude | null
  }



  /**
   * Model Department
   */


  export type AggregateDepartment = {
    count: DepartmentCountAggregateOutputType | null
    min: DepartmentMinAggregateOutputType | null
    max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    departmentID: string | null
    departmentName: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    departmentID: string | null
    departmentName: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    departmentID: number | null
    departmentName: number | null
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    departmentID?: true
    departmentName?: true
  }

  export type DepartmentMaxAggregateInputType = {
    departmentID?: true
    departmentName?: true
  }

  export type DepartmentCountAggregateInputType = {
    departmentID?: true
    departmentName?: true
    _all?: true
  }

  export type DepartmentAggregateArgs = {
    /**
     * Filter which Department to aggregate.
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
    **/
    orderBy?: Enumerable<DepartmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
    [P in keyof T & keyof AggregateDepartment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }



  export type DepartmentSelect = {
    departmentID?: boolean
    departmentName?: boolean
    Course?: boolean | CourseFindManyArgs
    DegreeRequirement?: boolean | DegreeRequirementFindManyArgs
    GPD?: boolean | GPDArgs
  }

  export type DepartmentInclude = {
    Course?: boolean | CourseFindManyArgs
    DegreeRequirement?: boolean | DegreeRequirementFindManyArgs
    GPD?: boolean | GPDArgs
  }

  export type DepartmentGetPayload<
    S extends boolean | null | undefined | DepartmentArgs,
    U = keyof S
      > = S extends true
        ? Department
    : S extends undefined
    ? never
    : S extends DepartmentArgs | DepartmentFindManyArgs
    ?'include' extends U
    ? Department  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course'
        ? Array < CourseGetPayload<S['include'][P]>>  :
        P extends 'DegreeRequirement'
        ? Array < DegreeRequirementGetPayload<S['include'][P]>>  :
        P extends 'GPD'
        ? GPDGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Department ?Department [P]
  : 
          P extends 'Course'
        ? Array < CourseGetPayload<S['select'][P]>>  :
        P extends 'DegreeRequirement'
        ? Array < DegreeRequirementGetPayload<S['select'][P]>>  :
        P extends 'GPD'
        ? GPDGetPayload<S['select'][P]> | null : never
  } 
    : Department
  : Department


  type DepartmentCountArgs = Merge<
    Omit<DepartmentFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentCountAggregateInputType | true
    }
  >

  export interface DepartmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DepartmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Department'> extends True ? CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>> : CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DepartmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Department'> extends True ? CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>> : CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `departmentID`
     * const departmentWithDepartmentIDOnly = await prisma.department.findMany({ select: { departmentID: true } })
     * 
    **/
    findMany<T extends DepartmentFindManyArgs>(
      args?: SelectSubset<T, DepartmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Department>>, PrismaPromise<Array<DepartmentGetPayload<T>>>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
    **/
    create<T extends DepartmentCreateArgs>(
      args: SelectSubset<T, DepartmentCreateArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
    **/
    delete<T extends DepartmentDeleteArgs>(
      args: SelectSubset<T, DepartmentDeleteArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartmentUpdateArgs>(
      args: SelectSubset<T, DepartmentUpdateArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartmentDeleteManyArgs>(
      args?: SelectSubset<T, DepartmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartmentUpdateManyArgs>(
      args: SelectSubset<T, DepartmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
    **/
    upsert<T extends DepartmentUpsertArgs>(
      args: SelectSubset<T, DepartmentUpsertArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): PrismaPromise<GetDepartmentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DepartmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course<T extends CourseFindManyArgs = {}>(args?: Subset<T, CourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Course>>, PrismaPromise<Array<CourseGetPayload<T>>>>;

    DegreeRequirement<T extends DegreeRequirementFindManyArgs = {}>(args?: Subset<T, DegreeRequirementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DegreeRequirement>>, PrismaPromise<Array<DegreeRequirementGetPayload<T>>>>;

    GPD<T extends GPDArgs = {}>(args?: Subset<T, GPDArgs>): CheckSelect<T, Prisma__GPDClient<GPD | null >, Prisma__GPDClient<GPDGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * Throw an Error if a Department can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Department to fetch.
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * Throw an Error if a Department can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Department to fetch.
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
    **/
    orderBy?: Enumerable<DepartmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
    **/
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * Filter, which Departments to fetch.
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
    **/
    orderBy?: Enumerable<DepartmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
    **/
    skip?: number
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department create
   */
  export type DepartmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * The data needed to create a Department.
    **/
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }


  /**
   * Department update
   */
  export type DepartmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * The data needed to update a Department.
    **/
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs = {
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    where?: DepartmentWhereInput
  }


  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * The filter to search for the Department to update in case it exists.
    **/
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
    **/
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }


  /**
   * Department delete
   */
  export type DepartmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
    /**
     * Filter which Department to delete.
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs = {
    where?: DepartmentWhereInput
  }


  /**
   * Department without action
   */
  export type DepartmentArgs = {
    /**
     * Select specific fields to fetch from the Department
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DepartmentInclude | null
  }



  /**
   * Model ElectiveStatus
   */


  export type AggregateElectiveStatus = {
    count: ElectiveStatusCountAggregateOutputType | null
    avg: ElectiveStatusAvgAggregateOutputType | null
    sum: ElectiveStatusSumAggregateOutputType | null
    min: ElectiveStatusMinAggregateOutputType | null
    max: ElectiveStatusMaxAggregateOutputType | null
  }

  export type ElectiveStatusAvgAggregateOutputType = {
    studentID: number
    areaID: number
  }

  export type ElectiveStatusSumAggregateOutputType = {
    studentID: number
    areaID: number
  }

  export type ElectiveStatusMinAggregateOutputType = {
    studentID: number
    areaID: number
    status: ElectiveStatus_status | null
  }

  export type ElectiveStatusMaxAggregateOutputType = {
    studentID: number
    areaID: number
    status: ElectiveStatus_status | null
  }

  export type ElectiveStatusCountAggregateOutputType = {
    studentID: number
    areaID: number
    status: number | null
    _all: number
  }


  export type ElectiveStatusAvgAggregateInputType = {
    studentID?: true
    areaID?: true
  }

  export type ElectiveStatusSumAggregateInputType = {
    studentID?: true
    areaID?: true
  }

  export type ElectiveStatusMinAggregateInputType = {
    studentID?: true
    areaID?: true
    status?: true
  }

  export type ElectiveStatusMaxAggregateInputType = {
    studentID?: true
    areaID?: true
    status?: true
  }

  export type ElectiveStatusCountAggregateInputType = {
    studentID?: true
    areaID?: true
    status?: true
    _all?: true
  }

  export type ElectiveStatusAggregateArgs = {
    /**
     * Filter which ElectiveStatus to aggregate.
    **/
    where?: ElectiveStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectiveStatuses to fetch.
    **/
    orderBy?: Enumerable<ElectiveStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ElectiveStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectiveStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectiveStatuses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElectiveStatuses
    **/
    count?: true | ElectiveStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ElectiveStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ElectiveStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ElectiveStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ElectiveStatusMaxAggregateInputType
  }

  export type GetElectiveStatusAggregateType<T extends ElectiveStatusAggregateArgs> = {
    [P in keyof T & keyof AggregateElectiveStatus]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElectiveStatus[P]>
      : GetScalarType<T[P], AggregateElectiveStatus[P]>
  }



  export type ElectiveStatusSelect = {
    studentID?: boolean
    areaID?: boolean
    status?: boolean
    Area?: boolean | AreaArgs
    Student?: boolean | StudentArgs
  }

  export type ElectiveStatusInclude = {
    Area?: boolean | AreaArgs
    Student?: boolean | StudentArgs
  }

  export type ElectiveStatusGetPayload<
    S extends boolean | null | undefined | ElectiveStatusArgs,
    U = keyof S
      > = S extends true
        ? ElectiveStatus
    : S extends undefined
    ? never
    : S extends ElectiveStatusArgs | ElectiveStatusFindManyArgs
    ?'include' extends U
    ? ElectiveStatus  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Area'
        ? AreaGetPayload<S['include'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ElectiveStatus ?ElectiveStatus [P]
  : 
          P extends 'Area'
        ? AreaGetPayload<S['select'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : ElectiveStatus
  : ElectiveStatus


  type ElectiveStatusCountArgs = Merge<
    Omit<ElectiveStatusFindManyArgs, 'select' | 'include'> & {
      select?: ElectiveStatusCountAggregateInputType | true
    }
  >

  export interface ElectiveStatusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ElectiveStatus that matches the filter.
     * @param {ElectiveStatusFindUniqueArgs} args - Arguments to find a ElectiveStatus
     * @example
     * // Get one ElectiveStatus
     * const electiveStatus = await prisma.electiveStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ElectiveStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ElectiveStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ElectiveStatus'> extends True ? CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>> : CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus | null >, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T> | null >>

    /**
     * Find the first ElectiveStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectiveStatusFindFirstArgs} args - Arguments to find a ElectiveStatus
     * @example
     * // Get one ElectiveStatus
     * const electiveStatus = await prisma.electiveStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ElectiveStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ElectiveStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ElectiveStatus'> extends True ? CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>> : CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus | null >, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T> | null >>

    /**
     * Find zero or more ElectiveStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectiveStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElectiveStatuses
     * const electiveStatuses = await prisma.electiveStatus.findMany()
     * 
     * // Get first 10 ElectiveStatuses
     * const electiveStatuses = await prisma.electiveStatus.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const electiveStatusWithStudentIDOnly = await prisma.electiveStatus.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends ElectiveStatusFindManyArgs>(
      args?: SelectSubset<T, ElectiveStatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ElectiveStatus>>, PrismaPromise<Array<ElectiveStatusGetPayload<T>>>>

    /**
     * Create a ElectiveStatus.
     * @param {ElectiveStatusCreateArgs} args - Arguments to create a ElectiveStatus.
     * @example
     * // Create one ElectiveStatus
     * const ElectiveStatus = await prisma.electiveStatus.create({
     *   data: {
     *     // ... data to create a ElectiveStatus
     *   }
     * })
     * 
    **/
    create<T extends ElectiveStatusCreateArgs>(
      args: SelectSubset<T, ElectiveStatusCreateArgs>
    ): CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>>

    /**
     * Delete a ElectiveStatus.
     * @param {ElectiveStatusDeleteArgs} args - Arguments to delete one ElectiveStatus.
     * @example
     * // Delete one ElectiveStatus
     * const ElectiveStatus = await prisma.electiveStatus.delete({
     *   where: {
     *     // ... filter to delete one ElectiveStatus
     *   }
     * })
     * 
    **/
    delete<T extends ElectiveStatusDeleteArgs>(
      args: SelectSubset<T, ElectiveStatusDeleteArgs>
    ): CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>>

    /**
     * Update one ElectiveStatus.
     * @param {ElectiveStatusUpdateArgs} args - Arguments to update one ElectiveStatus.
     * @example
     * // Update one ElectiveStatus
     * const electiveStatus = await prisma.electiveStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ElectiveStatusUpdateArgs>(
      args: SelectSubset<T, ElectiveStatusUpdateArgs>
    ): CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>>

    /**
     * Delete zero or more ElectiveStatuses.
     * @param {ElectiveStatusDeleteManyArgs} args - Arguments to filter ElectiveStatuses to delete.
     * @example
     * // Delete a few ElectiveStatuses
     * const { count } = await prisma.electiveStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ElectiveStatusDeleteManyArgs>(
      args?: SelectSubset<T, ElectiveStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElectiveStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectiveStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElectiveStatuses
     * const electiveStatus = await prisma.electiveStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ElectiveStatusUpdateManyArgs>(
      args: SelectSubset<T, ElectiveStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ElectiveStatus.
     * @param {ElectiveStatusUpsertArgs} args - Arguments to update or create a ElectiveStatus.
     * @example
     * // Update or create a ElectiveStatus
     * const electiveStatus = await prisma.electiveStatus.upsert({
     *   create: {
     *     // ... data to create a ElectiveStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElectiveStatus we want to update
     *   }
     * })
    **/
    upsert<T extends ElectiveStatusUpsertArgs>(
      args: SelectSubset<T, ElectiveStatusUpsertArgs>
    ): CheckSelect<T, Prisma__ElectiveStatusClient<ElectiveStatus>, Prisma__ElectiveStatusClient<ElectiveStatusGetPayload<T>>>

    /**
     * Count the number of ElectiveStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectiveStatusCountArgs} args - Arguments to filter ElectiveStatuses to count.
     * @example
     * // Count the number of ElectiveStatuses
     * const count = await prisma.electiveStatus.count({
     *   where: {
     *     // ... the filter for the ElectiveStatuses we want to count
     *   }
     * })
    **/
    count<T extends ElectiveStatusCountArgs>(
      args?: Subset<T, ElectiveStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElectiveStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElectiveStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectiveStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElectiveStatusAggregateArgs>(args: Subset<T, ElectiveStatusAggregateArgs>): PrismaPromise<GetElectiveStatusAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ElectiveStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ElectiveStatusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Area<T extends AreaArgs = {}>(args?: Subset<T, AreaArgs>): CheckSelect<T, Prisma__AreaClient<Area | null >, Prisma__AreaClient<AreaGetPayload<T> | null >>;

    Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ElectiveStatus findUnique
   */
  export type ElectiveStatusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * Throw an Error if a ElectiveStatus can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ElectiveStatus to fetch.
    **/
    where: ElectiveStatusWhereUniqueInput
  }


  /**
   * ElectiveStatus findFirst
   */
  export type ElectiveStatusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * Throw an Error if a ElectiveStatus can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ElectiveStatus to fetch.
    **/
    where?: ElectiveStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectiveStatuses to fetch.
    **/
    orderBy?: Enumerable<ElectiveStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElectiveStatuses.
    **/
    cursor?: ElectiveStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectiveStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectiveStatuses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElectiveStatuses.
    **/
    distinct?: Enumerable<ElectiveStatusScalarFieldEnum>
  }


  /**
   * ElectiveStatus findMany
   */
  export type ElectiveStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * Filter, which ElectiveStatuses to fetch.
    **/
    where?: ElectiveStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectiveStatuses to fetch.
    **/
    orderBy?: Enumerable<ElectiveStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElectiveStatuses.
    **/
    cursor?: ElectiveStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectiveStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectiveStatuses.
    **/
    skip?: number
    distinct?: Enumerable<ElectiveStatusScalarFieldEnum>
  }


  /**
   * ElectiveStatus create
   */
  export type ElectiveStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * The data needed to create a ElectiveStatus.
    **/
    data: XOR<ElectiveStatusCreateInput, ElectiveStatusUncheckedCreateInput>
  }


  /**
   * ElectiveStatus update
   */
  export type ElectiveStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * The data needed to update a ElectiveStatus.
    **/
    data: XOR<ElectiveStatusUpdateInput, ElectiveStatusUncheckedUpdateInput>
    /**
     * Choose, which ElectiveStatus to update.
    **/
    where: ElectiveStatusWhereUniqueInput
  }


  /**
   * ElectiveStatus updateMany
   */
  export type ElectiveStatusUpdateManyArgs = {
    data: XOR<ElectiveStatusUpdateManyMutationInput, ElectiveStatusUncheckedUpdateManyInput>
    where?: ElectiveStatusWhereInput
  }


  /**
   * ElectiveStatus upsert
   */
  export type ElectiveStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * The filter to search for the ElectiveStatus to update in case it exists.
    **/
    where: ElectiveStatusWhereUniqueInput
    /**
     * In case the ElectiveStatus found by the `where` argument doesn't exist, create a new ElectiveStatus with this data.
    **/
    create: XOR<ElectiveStatusCreateInput, ElectiveStatusUncheckedCreateInput>
    /**
     * In case the ElectiveStatus was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ElectiveStatusUpdateInput, ElectiveStatusUncheckedUpdateInput>
  }


  /**
   * ElectiveStatus delete
   */
  export type ElectiveStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
    /**
     * Filter which ElectiveStatus to delete.
    **/
    where: ElectiveStatusWhereUniqueInput
  }


  /**
   * ElectiveStatus deleteMany
   */
  export type ElectiveStatusDeleteManyArgs = {
    where?: ElectiveStatusWhereInput
  }


  /**
   * ElectiveStatus without action
   */
  export type ElectiveStatusArgs = {
    /**
     * Select specific fields to fetch from the ElectiveStatus
    **/
    select?: ElectiveStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ElectiveStatusInclude | null
  }



  /**
   * Model GPD
   */


  export type AggregateGPD = {
    count: GPDCountAggregateOutputType | null
    avg: GPDAvgAggregateOutputType | null
    sum: GPDSumAggregateOutputType | null
    min: GPDMinAggregateOutputType | null
    max: GPDMaxAggregateOutputType | null
  }

  export type GPDAvgAggregateOutputType = {
    GPDID: number
  }

  export type GPDSumAggregateOutputType = {
    GPDID: number
  }

  export type GPDMinAggregateOutputType = {
    GPDID: number
    departmentID: string | null
  }

  export type GPDMaxAggregateOutputType = {
    GPDID: number
    departmentID: string | null
  }

  export type GPDCountAggregateOutputType = {
    GPDID: number
    departmentID: number | null
    _all: number
  }


  export type GPDAvgAggregateInputType = {
    GPDID?: true
  }

  export type GPDSumAggregateInputType = {
    GPDID?: true
  }

  export type GPDMinAggregateInputType = {
    GPDID?: true
    departmentID?: true
  }

  export type GPDMaxAggregateInputType = {
    GPDID?: true
    departmentID?: true
  }

  export type GPDCountAggregateInputType = {
    GPDID?: true
    departmentID?: true
    _all?: true
  }

  export type GPDAggregateArgs = {
    /**
     * Filter which GPD to aggregate.
    **/
    where?: GPDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPDS to fetch.
    **/
    orderBy?: Enumerable<GPDOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GPDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPDS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPDS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPDS
    **/
    count?: true | GPDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GPDAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GPDSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GPDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GPDMaxAggregateInputType
  }

  export type GetGPDAggregateType<T extends GPDAggregateArgs> = {
    [P in keyof T & keyof AggregateGPD]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPD[P]>
      : GetScalarType<T[P], AggregateGPD[P]>
  }



  export type GPDSelect = {
    GPDID?: boolean
    departmentID?: boolean
    User?: boolean | UserArgs
    Department?: boolean | DepartmentArgs
    Comments?: boolean | CommentsFindManyArgs
  }

  export type GPDInclude = {
    User?: boolean | UserArgs
    Department?: boolean | DepartmentArgs
    Comments?: boolean | CommentsFindManyArgs
  }

  export type GPDGetPayload<
    S extends boolean | null | undefined | GPDArgs,
    U = keyof S
      > = S extends true
        ? GPD
    : S extends undefined
    ? never
    : S extends GPDArgs | GPDFindManyArgs
    ?'include' extends U
    ? GPD  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'Department'
        ? DepartmentGetPayload<S['include'][P]> :
        P extends 'Comments'
        ? Array < CommentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GPD ?GPD [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'Department'
        ? DepartmentGetPayload<S['select'][P]> :
        P extends 'Comments'
        ? Array < CommentsGetPayload<S['select'][P]>>  : never
  } 
    : GPD
  : GPD


  type GPDCountArgs = Merge<
    Omit<GPDFindManyArgs, 'select' | 'include'> & {
      select?: GPDCountAggregateInputType | true
    }
  >

  export interface GPDDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GPD that matches the filter.
     * @param {GPDFindUniqueArgs} args - Arguments to find a GPD
     * @example
     * // Get one GPD
     * const gPD = await prisma.gPD.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GPDFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GPDFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GPD'> extends True ? CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>> : CheckSelect<T, Prisma__GPDClient<GPD | null >, Prisma__GPDClient<GPDGetPayload<T> | null >>

    /**
     * Find the first GPD that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPDFindFirstArgs} args - Arguments to find a GPD
     * @example
     * // Get one GPD
     * const gPD = await prisma.gPD.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GPDFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GPDFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GPD'> extends True ? CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>> : CheckSelect<T, Prisma__GPDClient<GPD | null >, Prisma__GPDClient<GPDGetPayload<T> | null >>

    /**
     * Find zero or more GPDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPDFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPDS
     * const gPDS = await prisma.gPD.findMany()
     * 
     * // Get first 10 GPDS
     * const gPDS = await prisma.gPD.findMany({ take: 10 })
     * 
     * // Only select the `GPDID`
     * const gPDWithGPDIDOnly = await prisma.gPD.findMany({ select: { GPDID: true } })
     * 
    **/
    findMany<T extends GPDFindManyArgs>(
      args?: SelectSubset<T, GPDFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GPD>>, PrismaPromise<Array<GPDGetPayload<T>>>>

    /**
     * Create a GPD.
     * @param {GPDCreateArgs} args - Arguments to create a GPD.
     * @example
     * // Create one GPD
     * const GPD = await prisma.gPD.create({
     *   data: {
     *     // ... data to create a GPD
     *   }
     * })
     * 
    **/
    create<T extends GPDCreateArgs>(
      args: SelectSubset<T, GPDCreateArgs>
    ): CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>>

    /**
     * Delete a GPD.
     * @param {GPDDeleteArgs} args - Arguments to delete one GPD.
     * @example
     * // Delete one GPD
     * const GPD = await prisma.gPD.delete({
     *   where: {
     *     // ... filter to delete one GPD
     *   }
     * })
     * 
    **/
    delete<T extends GPDDeleteArgs>(
      args: SelectSubset<T, GPDDeleteArgs>
    ): CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>>

    /**
     * Update one GPD.
     * @param {GPDUpdateArgs} args - Arguments to update one GPD.
     * @example
     * // Update one GPD
     * const gPD = await prisma.gPD.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GPDUpdateArgs>(
      args: SelectSubset<T, GPDUpdateArgs>
    ): CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>>

    /**
     * Delete zero or more GPDS.
     * @param {GPDDeleteManyArgs} args - Arguments to filter GPDS to delete.
     * @example
     * // Delete a few GPDS
     * const { count } = await prisma.gPD.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GPDDeleteManyArgs>(
      args?: SelectSubset<T, GPDDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPDS
     * const gPD = await prisma.gPD.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GPDUpdateManyArgs>(
      args: SelectSubset<T, GPDUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GPD.
     * @param {GPDUpsertArgs} args - Arguments to update or create a GPD.
     * @example
     * // Update or create a GPD
     * const gPD = await prisma.gPD.upsert({
     *   create: {
     *     // ... data to create a GPD
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPD we want to update
     *   }
     * })
    **/
    upsert<T extends GPDUpsertArgs>(
      args: SelectSubset<T, GPDUpsertArgs>
    ): CheckSelect<T, Prisma__GPDClient<GPD>, Prisma__GPDClient<GPDGetPayload<T>>>

    /**
     * Count the number of GPDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPDCountArgs} args - Arguments to filter GPDS to count.
     * @example
     * // Count the number of GPDS
     * const count = await prisma.gPD.count({
     *   where: {
     *     // ... the filter for the GPDS we want to count
     *   }
     * })
    **/
    count<T extends GPDCountArgs>(
      args?: Subset<T, GPDCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPDAggregateArgs>(args: Subset<T, GPDAggregateArgs>): PrismaPromise<GetGPDAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for GPD.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GPDClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Department<T extends DepartmentArgs = {}>(args?: Subset<T, DepartmentArgs>): CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>;

    Comments<T extends CommentsFindManyArgs = {}>(args?: Subset<T, CommentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GPD findUnique
   */
  export type GPDFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * Throw an Error if a GPD can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GPD to fetch.
    **/
    where: GPDWhereUniqueInput
  }


  /**
   * GPD findFirst
   */
  export type GPDFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * Throw an Error if a GPD can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GPD to fetch.
    **/
    where?: GPDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPDS to fetch.
    **/
    orderBy?: Enumerable<GPDOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPDS.
    **/
    cursor?: GPDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPDS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPDS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPDS.
    **/
    distinct?: Enumerable<GPDScalarFieldEnum>
  }


  /**
   * GPD findMany
   */
  export type GPDFindManyArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * Filter, which GPDS to fetch.
    **/
    where?: GPDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPDS to fetch.
    **/
    orderBy?: Enumerable<GPDOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPDS.
    **/
    cursor?: GPDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPDS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPDS.
    **/
    skip?: number
    distinct?: Enumerable<GPDScalarFieldEnum>
  }


  /**
   * GPD create
   */
  export type GPDCreateArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * The data needed to create a GPD.
    **/
    data: XOR<GPDCreateInput, GPDUncheckedCreateInput>
  }


  /**
   * GPD update
   */
  export type GPDUpdateArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * The data needed to update a GPD.
    **/
    data: XOR<GPDUpdateInput, GPDUncheckedUpdateInput>
    /**
     * Choose, which GPD to update.
    **/
    where: GPDWhereUniqueInput
  }


  /**
   * GPD updateMany
   */
  export type GPDUpdateManyArgs = {
    data: XOR<GPDUpdateManyMutationInput, GPDUncheckedUpdateManyInput>
    where?: GPDWhereInput
  }


  /**
   * GPD upsert
   */
  export type GPDUpsertArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * The filter to search for the GPD to update in case it exists.
    **/
    where: GPDWhereUniqueInput
    /**
     * In case the GPD found by the `where` argument doesn't exist, create a new GPD with this data.
    **/
    create: XOR<GPDCreateInput, GPDUncheckedCreateInput>
    /**
     * In case the GPD was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GPDUpdateInput, GPDUncheckedUpdateInput>
  }


  /**
   * GPD delete
   */
  export type GPDDeleteArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
    /**
     * Filter which GPD to delete.
    **/
    where: GPDWhereUniqueInput
  }


  /**
   * GPD deleteMany
   */
  export type GPDDeleteManyArgs = {
    where?: GPDWhereInput
  }


  /**
   * GPD without action
   */
  export type GPDArgs = {
    /**
     * Select specific fields to fetch from the GPD
    **/
    select?: GPDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GPDInclude | null
  }



  /**
   * Model Grades
   */


  export type AggregateGrades = {
    count: GradesCountAggregateOutputType | null
    avg: GradesAvgAggregateOutputType | null
    sum: GradesSumAggregateOutputType | null
    min: GradesMinAggregateOutputType | null
    max: GradesMaxAggregateOutputType | null
  }

  export type GradesAvgAggregateOutputType = {
    studentID: number
  }

  export type GradesSumAggregateOutputType = {
    studentID: number
  }

  export type GradesMinAggregateOutputType = {
    studentID: number
    courseOfferingID: string | null
    grade: string | null
  }

  export type GradesMaxAggregateOutputType = {
    studentID: number
    courseOfferingID: string | null
    grade: string | null
  }

  export type GradesCountAggregateOutputType = {
    studentID: number
    courseOfferingID: number | null
    grade: number | null
    _all: number
  }


  export type GradesAvgAggregateInputType = {
    studentID?: true
  }

  export type GradesSumAggregateInputType = {
    studentID?: true
  }

  export type GradesMinAggregateInputType = {
    studentID?: true
    courseOfferingID?: true
    grade?: true
  }

  export type GradesMaxAggregateInputType = {
    studentID?: true
    courseOfferingID?: true
    grade?: true
  }

  export type GradesCountAggregateInputType = {
    studentID?: true
    courseOfferingID?: true
    grade?: true
    _all?: true
  }

  export type GradesAggregateArgs = {
    /**
     * Filter which Grades to aggregate.
    **/
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
    **/
    orderBy?: Enumerable<GradesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    count?: true | GradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GradesMaxAggregateInputType
  }

  export type GetGradesAggregateType<T extends GradesAggregateArgs> = {
    [P in keyof T & keyof AggregateGrades]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrades[P]>
      : GetScalarType<T[P], AggregateGrades[P]>
  }



  export type GradesSelect = {
    studentID?: boolean
    courseOfferingID?: boolean
    grade?: boolean
    Student?: boolean | StudentArgs
  }

  export type GradesInclude = {
    Student?: boolean | StudentArgs
  }

  export type GradesGetPayload<
    S extends boolean | null | undefined | GradesArgs,
    U = keyof S
      > = S extends true
        ? Grades
    : S extends undefined
    ? never
    : S extends GradesArgs | GradesFindManyArgs
    ?'include' extends U
    ? Grades  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Grades ?Grades [P]
  : 
          P extends 'Student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : Grades
  : Grades


  type GradesCountArgs = Merge<
    Omit<GradesFindManyArgs, 'select' | 'include'> & {
      select?: GradesCountAggregateInputType | true
    }
  >

  export interface GradesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Grades that matches the filter.
     * @param {GradesFindUniqueArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GradesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GradesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Grades'> extends True ? CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>> : CheckSelect<T, Prisma__GradesClient<Grades | null >, Prisma__GradesClient<GradesGetPayload<T> | null >>

    /**
     * Find the first Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesFindFirstArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GradesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GradesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Grades'> extends True ? CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>> : CheckSelect<T, Prisma__GradesClient<Grades | null >, Prisma__GradesClient<GradesGetPayload<T> | null >>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grades.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grades.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const gradesWithStudentIDOnly = await prisma.grades.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends GradesFindManyArgs>(
      args?: SelectSubset<T, GradesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Grades>>, PrismaPromise<Array<GradesGetPayload<T>>>>

    /**
     * Create a Grades.
     * @param {GradesCreateArgs} args - Arguments to create a Grades.
     * @example
     * // Create one Grades
     * const Grades = await prisma.grades.create({
     *   data: {
     *     // ... data to create a Grades
     *   }
     * })
     * 
    **/
    create<T extends GradesCreateArgs>(
      args: SelectSubset<T, GradesCreateArgs>
    ): CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>>

    /**
     * Delete a Grades.
     * @param {GradesDeleteArgs} args - Arguments to delete one Grades.
     * @example
     * // Delete one Grades
     * const Grades = await prisma.grades.delete({
     *   where: {
     *     // ... filter to delete one Grades
     *   }
     * })
     * 
    **/
    delete<T extends GradesDeleteArgs>(
      args: SelectSubset<T, GradesDeleteArgs>
    ): CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>>

    /**
     * Update one Grades.
     * @param {GradesUpdateArgs} args - Arguments to update one Grades.
     * @example
     * // Update one Grades
     * const grades = await prisma.grades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GradesUpdateArgs>(
      args: SelectSubset<T, GradesUpdateArgs>
    ): CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>>

    /**
     * Delete zero or more Grades.
     * @param {GradesDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GradesDeleteManyArgs>(
      args?: SelectSubset<T, GradesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grades = await prisma.grades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GradesUpdateManyArgs>(
      args: SelectSubset<T, GradesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Grades.
     * @param {GradesUpsertArgs} args - Arguments to update or create a Grades.
     * @example
     * // Update or create a Grades
     * const grades = await prisma.grades.upsert({
     *   create: {
     *     // ... data to create a Grades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grades we want to update
     *   }
     * })
    **/
    upsert<T extends GradesUpsertArgs>(
      args: SelectSubset<T, GradesUpsertArgs>
    ): CheckSelect<T, Prisma__GradesClient<Grades>, Prisma__GradesClient<GradesGetPayload<T>>>

    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grades.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradesCountArgs>(
      args?: Subset<T, GradesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradesAggregateArgs>(args: Subset<T, GradesAggregateArgs>): PrismaPromise<GetGradesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Grades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GradesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Grades findUnique
   */
  export type GradesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * Throw an Error if a Grades can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Grades to fetch.
    **/
    where: GradesWhereUniqueInput
  }


  /**
   * Grades findFirst
   */
  export type GradesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * Throw an Error if a Grades can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Grades to fetch.
    **/
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
    **/
    orderBy?: Enumerable<GradesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
    **/
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
    **/
    distinct?: Enumerable<GradesScalarFieldEnum>
  }


  /**
   * Grades findMany
   */
  export type GradesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * Filter, which Grades to fetch.
    **/
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
    **/
    orderBy?: Enumerable<GradesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
    **/
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
    **/
    skip?: number
    distinct?: Enumerable<GradesScalarFieldEnum>
  }


  /**
   * Grades create
   */
  export type GradesCreateArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * The data needed to create a Grades.
    **/
    data: XOR<GradesCreateInput, GradesUncheckedCreateInput>
  }


  /**
   * Grades update
   */
  export type GradesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * The data needed to update a Grades.
    **/
    data: XOR<GradesUpdateInput, GradesUncheckedUpdateInput>
    /**
     * Choose, which Grades to update.
    **/
    where: GradesWhereUniqueInput
  }


  /**
   * Grades updateMany
   */
  export type GradesUpdateManyArgs = {
    data: XOR<GradesUpdateManyMutationInput, GradesUncheckedUpdateManyInput>
    where?: GradesWhereInput
  }


  /**
   * Grades upsert
   */
  export type GradesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * The filter to search for the Grades to update in case it exists.
    **/
    where: GradesWhereUniqueInput
    /**
     * In case the Grades found by the `where` argument doesn't exist, create a new Grades with this data.
    **/
    create: XOR<GradesCreateInput, GradesUncheckedCreateInput>
    /**
     * In case the Grades was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GradesUpdateInput, GradesUncheckedUpdateInput>
  }


  /**
   * Grades delete
   */
  export type GradesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
    /**
     * Filter which Grades to delete.
    **/
    where: GradesWhereUniqueInput
  }


  /**
   * Grades deleteMany
   */
  export type GradesDeleteManyArgs = {
    where?: GradesWhereInput
  }


  /**
   * Grades without action
   */
  export type GradesArgs = {
    /**
     * Select specific fields to fetch from the Grades
    **/
    select?: GradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GradesInclude | null
  }



  /**
   * Model prerequisite
   */


  export type AggregatePrerequisite = {
    count: PrerequisiteCountAggregateOutputType | null
    min: PrerequisiteMinAggregateOutputType | null
    max: PrerequisiteMaxAggregateOutputType | null
  }

  export type PrerequisiteMinAggregateOutputType = {
    courseID: string | null
    prerequisiteID: string | null
  }

  export type PrerequisiteMaxAggregateOutputType = {
    courseID: string | null
    prerequisiteID: string | null
  }

  export type PrerequisiteCountAggregateOutputType = {
    courseID: number | null
    prerequisiteID: number | null
    _all: number
  }


  export type PrerequisiteMinAggregateInputType = {
    courseID?: true
    prerequisiteID?: true
  }

  export type PrerequisiteMaxAggregateInputType = {
    courseID?: true
    prerequisiteID?: true
  }

  export type PrerequisiteCountAggregateInputType = {
    courseID?: true
    prerequisiteID?: true
    _all?: true
  }

  export type PrerequisiteAggregateArgs = {
    /**
     * Filter which prerequisite to aggregate.
    **/
    where?: prerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prerequisites to fetch.
    **/
    orderBy?: Enumerable<prerequisiteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: prerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prerequisites from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prerequisites.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prerequisites
    **/
    count?: true | PrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PrerequisiteMaxAggregateInputType
  }

  export type GetPrerequisiteAggregateType<T extends PrerequisiteAggregateArgs> = {
    [P in keyof T & keyof AggregatePrerequisite]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrerequisite[P]>
      : GetScalarType<T[P], AggregatePrerequisite[P]>
  }



  export type prerequisiteSelect = {
    courseID?: boolean
    prerequisiteID?: boolean
    Course_CourseToprerequisite_courseID?: boolean | CourseArgs
    Course_CourseToprerequisite_prerequisiteID?: boolean | CourseArgs
  }

  export type prerequisiteInclude = {
    Course_CourseToprerequisite_courseID?: boolean | CourseArgs
    Course_CourseToprerequisite_prerequisiteID?: boolean | CourseArgs
  }

  export type prerequisiteGetPayload<
    S extends boolean | null | undefined | prerequisiteArgs,
    U = keyof S
      > = S extends true
        ? prerequisite
    : S extends undefined
    ? never
    : S extends prerequisiteArgs | prerequisiteFindManyArgs
    ?'include' extends U
    ? prerequisite  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course_CourseToprerequisite_courseID'
        ? CourseGetPayload<S['include'][P]> :
        P extends 'Course_CourseToprerequisite_prerequisiteID'
        ? CourseGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof prerequisite ?prerequisite [P]
  : 
          P extends 'Course_CourseToprerequisite_courseID'
        ? CourseGetPayload<S['select'][P]> :
        P extends 'Course_CourseToprerequisite_prerequisiteID'
        ? CourseGetPayload<S['select'][P]> : never
  } 
    : prerequisite
  : prerequisite


  type prerequisiteCountArgs = Merge<
    Omit<prerequisiteFindManyArgs, 'select' | 'include'> & {
      select?: PrerequisiteCountAggregateInputType | true
    }
  >

  export interface prerequisiteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Prerequisite that matches the filter.
     * @param {prerequisiteFindUniqueArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prerequisiteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, prerequisiteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'prerequisite'> extends True ? CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>> : CheckSelect<T, Prisma__prerequisiteClient<prerequisite | null >, Prisma__prerequisiteClient<prerequisiteGetPayload<T> | null >>

    /**
     * Find the first Prerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prerequisiteFindFirstArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prerequisiteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, prerequisiteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'prerequisite'> extends True ? CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>> : CheckSelect<T, Prisma__prerequisiteClient<prerequisite | null >, Prisma__prerequisiteClient<prerequisiteGetPayload<T> | null >>

    /**
     * Find zero or more Prerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prerequisiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany()
     * 
     * // Get first 10 Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany({ take: 10 })
     * 
     * // Only select the `courseID`
     * const prerequisiteWithCourseIDOnly = await prisma.prerequisite.findMany({ select: { courseID: true } })
     * 
    **/
    findMany<T extends prerequisiteFindManyArgs>(
      args?: SelectSubset<T, prerequisiteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<prerequisite>>, PrismaPromise<Array<prerequisiteGetPayload<T>>>>

    /**
     * Create a Prerequisite.
     * @param {prerequisiteCreateArgs} args - Arguments to create a Prerequisite.
     * @example
     * // Create one Prerequisite
     * const Prerequisite = await prisma.prerequisite.create({
     *   data: {
     *     // ... data to create a Prerequisite
     *   }
     * })
     * 
    **/
    create<T extends prerequisiteCreateArgs>(
      args: SelectSubset<T, prerequisiteCreateArgs>
    ): CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>>

    /**
     * Delete a Prerequisite.
     * @param {prerequisiteDeleteArgs} args - Arguments to delete one Prerequisite.
     * @example
     * // Delete one Prerequisite
     * const Prerequisite = await prisma.prerequisite.delete({
     *   where: {
     *     // ... filter to delete one Prerequisite
     *   }
     * })
     * 
    **/
    delete<T extends prerequisiteDeleteArgs>(
      args: SelectSubset<T, prerequisiteDeleteArgs>
    ): CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>>

    /**
     * Update one Prerequisite.
     * @param {prerequisiteUpdateArgs} args - Arguments to update one Prerequisite.
     * @example
     * // Update one Prerequisite
     * const prerequisite = await prisma.prerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prerequisiteUpdateArgs>(
      args: SelectSubset<T, prerequisiteUpdateArgs>
    ): CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>>

    /**
     * Delete zero or more Prerequisites.
     * @param {prerequisiteDeleteManyArgs} args - Arguments to filter Prerequisites to delete.
     * @example
     * // Delete a few Prerequisites
     * const { count } = await prisma.prerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prerequisiteDeleteManyArgs>(
      args?: SelectSubset<T, prerequisiteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prerequisites
     * const prerequisite = await prisma.prerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prerequisiteUpdateManyArgs>(
      args: SelectSubset<T, prerequisiteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Prerequisite.
     * @param {prerequisiteUpsertArgs} args - Arguments to update or create a Prerequisite.
     * @example
     * // Update or create a Prerequisite
     * const prerequisite = await prisma.prerequisite.upsert({
     *   create: {
     *     // ... data to create a Prerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prerequisite we want to update
     *   }
     * })
    **/
    upsert<T extends prerequisiteUpsertArgs>(
      args: SelectSubset<T, prerequisiteUpsertArgs>
    ): CheckSelect<T, Prisma__prerequisiteClient<prerequisite>, Prisma__prerequisiteClient<prerequisiteGetPayload<T>>>

    /**
     * Count the number of Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prerequisiteCountArgs} args - Arguments to filter Prerequisites to count.
     * @example
     * // Count the number of Prerequisites
     * const count = await prisma.prerequisite.count({
     *   where: {
     *     // ... the filter for the Prerequisites we want to count
     *   }
     * })
    **/
    count<T extends prerequisiteCountArgs>(
      args?: Subset<T, prerequisiteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrerequisiteAggregateArgs>(args: Subset<T, PrerequisiteAggregateArgs>): PrismaPromise<GetPrerequisiteAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for prerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prerequisiteClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course_CourseToprerequisite_courseID<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    Course_CourseToprerequisite_prerequisiteID<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * prerequisite findUnique
   */
  export type prerequisiteFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * Throw an Error if a prerequisite can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which prerequisite to fetch.
    **/
    where: prerequisiteWhereUniqueInput
  }


  /**
   * prerequisite findFirst
   */
  export type prerequisiteFindFirstArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * Throw an Error if a prerequisite can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which prerequisite to fetch.
    **/
    where?: prerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prerequisites to fetch.
    **/
    orderBy?: Enumerable<prerequisiteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prerequisites.
    **/
    cursor?: prerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prerequisites from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prerequisites.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prerequisites.
    **/
    distinct?: Enumerable<PrerequisiteScalarFieldEnum>
  }


  /**
   * prerequisite findMany
   */
  export type prerequisiteFindManyArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * Filter, which prerequisites to fetch.
    **/
    where?: prerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prerequisites to fetch.
    **/
    orderBy?: Enumerable<prerequisiteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prerequisites.
    **/
    cursor?: prerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prerequisites from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prerequisites.
    **/
    skip?: number
    distinct?: Enumerable<PrerequisiteScalarFieldEnum>
  }


  /**
   * prerequisite create
   */
  export type prerequisiteCreateArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * The data needed to create a prerequisite.
    **/
    data: XOR<prerequisiteCreateInput, prerequisiteUncheckedCreateInput>
  }


  /**
   * prerequisite update
   */
  export type prerequisiteUpdateArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * The data needed to update a prerequisite.
    **/
    data: XOR<prerequisiteUpdateInput, prerequisiteUncheckedUpdateInput>
    /**
     * Choose, which prerequisite to update.
    **/
    where: prerequisiteWhereUniqueInput
  }


  /**
   * prerequisite updateMany
   */
  export type prerequisiteUpdateManyArgs = {
    data: XOR<prerequisiteUpdateManyMutationInput, prerequisiteUncheckedUpdateManyInput>
    where?: prerequisiteWhereInput
  }


  /**
   * prerequisite upsert
   */
  export type prerequisiteUpsertArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * The filter to search for the prerequisite to update in case it exists.
    **/
    where: prerequisiteWhereUniqueInput
    /**
     * In case the prerequisite found by the `where` argument doesn't exist, create a new prerequisite with this data.
    **/
    create: XOR<prerequisiteCreateInput, prerequisiteUncheckedCreateInput>
    /**
     * In case the prerequisite was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<prerequisiteUpdateInput, prerequisiteUncheckedUpdateInput>
  }


  /**
   * prerequisite delete
   */
  export type prerequisiteDeleteArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
    /**
     * Filter which prerequisite to delete.
    **/
    where: prerequisiteWhereUniqueInput
  }


  /**
   * prerequisite deleteMany
   */
  export type prerequisiteDeleteManyArgs = {
    where?: prerequisiteWhereInput
  }


  /**
   * prerequisite without action
   */
  export type prerequisiteArgs = {
    /**
     * Select specific fields to fetch from the prerequisite
    **/
    select?: prerequisiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prerequisiteInclude | null
  }



  /**
   * Model proficiencyRequirement
   */


  export type AggregateProficiencyRequirement = {
    count: ProficiencyRequirementCountAggregateOutputType | null
    avg: ProficiencyRequirementAvgAggregateOutputType | null
    sum: ProficiencyRequirementSumAggregateOutputType | null
    min: ProficiencyRequirementMinAggregateOutputType | null
    max: ProficiencyRequirementMaxAggregateOutputType | null
  }

  export type ProficiencyRequirementAvgAggregateOutputType = {
    requirementID: number
  }

  export type ProficiencyRequirementSumAggregateOutputType = {
    requirementID: number
  }

  export type ProficiencyRequirementMinAggregateOutputType = {
    requirementID: number
    courseID: string | null
  }

  export type ProficiencyRequirementMaxAggregateOutputType = {
    requirementID: number
    courseID: string | null
  }

  export type ProficiencyRequirementCountAggregateOutputType = {
    requirementID: number
    courseID: number | null
    _all: number
  }


  export type ProficiencyRequirementAvgAggregateInputType = {
    requirementID?: true
  }

  export type ProficiencyRequirementSumAggregateInputType = {
    requirementID?: true
  }

  export type ProficiencyRequirementMinAggregateInputType = {
    requirementID?: true
    courseID?: true
  }

  export type ProficiencyRequirementMaxAggregateInputType = {
    requirementID?: true
    courseID?: true
  }

  export type ProficiencyRequirementCountAggregateInputType = {
    requirementID?: true
    courseID?: true
    _all?: true
  }

  export type ProficiencyRequirementAggregateArgs = {
    /**
     * Filter which proficiencyRequirement to aggregate.
    **/
    where?: proficiencyRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proficiencyRequirements to fetch.
    **/
    orderBy?: Enumerable<proficiencyRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: proficiencyRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proficiencyRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proficiencyRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proficiencyRequirements
    **/
    count?: true | ProficiencyRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProficiencyRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProficiencyRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProficiencyRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProficiencyRequirementMaxAggregateInputType
  }

  export type GetProficiencyRequirementAggregateType<T extends ProficiencyRequirementAggregateArgs> = {
    [P in keyof T & keyof AggregateProficiencyRequirement]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProficiencyRequirement[P]>
      : GetScalarType<T[P], AggregateProficiencyRequirement[P]>
  }



  export type proficiencyRequirementSelect = {
    requirementID?: boolean
    courseID?: boolean
    Course?: boolean | CourseArgs
    DegreeRequirement?: boolean | DegreeRequirementArgs
  }

  export type proficiencyRequirementInclude = {
    Course?: boolean | CourseArgs
    DegreeRequirement?: boolean | DegreeRequirementArgs
  }

  export type proficiencyRequirementGetPayload<
    S extends boolean | null | undefined | proficiencyRequirementArgs,
    U = keyof S
      > = S extends true
        ? proficiencyRequirement
    : S extends undefined
    ? never
    : S extends proficiencyRequirementArgs | proficiencyRequirementFindManyArgs
    ?'include' extends U
    ? proficiencyRequirement  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course'
        ? CourseGetPayload<S['include'][P]> :
        P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof proficiencyRequirement ?proficiencyRequirement [P]
  : 
          P extends 'Course'
        ? CourseGetPayload<S['select'][P]> :
        P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['select'][P]> : never
  } 
    : proficiencyRequirement
  : proficiencyRequirement


  type proficiencyRequirementCountArgs = Merge<
    Omit<proficiencyRequirementFindManyArgs, 'select' | 'include'> & {
      select?: ProficiencyRequirementCountAggregateInputType | true
    }
  >

  export interface proficiencyRequirementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProficiencyRequirement that matches the filter.
     * @param {proficiencyRequirementFindUniqueArgs} args - Arguments to find a ProficiencyRequirement
     * @example
     * // Get one ProficiencyRequirement
     * const proficiencyRequirement = await prisma.proficiencyRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proficiencyRequirementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, proficiencyRequirementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'proficiencyRequirement'> extends True ? CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>> : CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement | null >, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T> | null >>

    /**
     * Find the first ProficiencyRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proficiencyRequirementFindFirstArgs} args - Arguments to find a ProficiencyRequirement
     * @example
     * // Get one ProficiencyRequirement
     * const proficiencyRequirement = await prisma.proficiencyRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proficiencyRequirementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, proficiencyRequirementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'proficiencyRequirement'> extends True ? CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>> : CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement | null >, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T> | null >>

    /**
     * Find zero or more ProficiencyRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proficiencyRequirementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProficiencyRequirements
     * const proficiencyRequirements = await prisma.proficiencyRequirement.findMany()
     * 
     * // Get first 10 ProficiencyRequirements
     * const proficiencyRequirements = await prisma.proficiencyRequirement.findMany({ take: 10 })
     * 
     * // Only select the `requirementID`
     * const proficiencyRequirementWithRequirementIDOnly = await prisma.proficiencyRequirement.findMany({ select: { requirementID: true } })
     * 
    **/
    findMany<T extends proficiencyRequirementFindManyArgs>(
      args?: SelectSubset<T, proficiencyRequirementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<proficiencyRequirement>>, PrismaPromise<Array<proficiencyRequirementGetPayload<T>>>>

    /**
     * Create a ProficiencyRequirement.
     * @param {proficiencyRequirementCreateArgs} args - Arguments to create a ProficiencyRequirement.
     * @example
     * // Create one ProficiencyRequirement
     * const ProficiencyRequirement = await prisma.proficiencyRequirement.create({
     *   data: {
     *     // ... data to create a ProficiencyRequirement
     *   }
     * })
     * 
    **/
    create<T extends proficiencyRequirementCreateArgs>(
      args: SelectSubset<T, proficiencyRequirementCreateArgs>
    ): CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>>

    /**
     * Delete a ProficiencyRequirement.
     * @param {proficiencyRequirementDeleteArgs} args - Arguments to delete one ProficiencyRequirement.
     * @example
     * // Delete one ProficiencyRequirement
     * const ProficiencyRequirement = await prisma.proficiencyRequirement.delete({
     *   where: {
     *     // ... filter to delete one ProficiencyRequirement
     *   }
     * })
     * 
    **/
    delete<T extends proficiencyRequirementDeleteArgs>(
      args: SelectSubset<T, proficiencyRequirementDeleteArgs>
    ): CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>>

    /**
     * Update one ProficiencyRequirement.
     * @param {proficiencyRequirementUpdateArgs} args - Arguments to update one ProficiencyRequirement.
     * @example
     * // Update one ProficiencyRequirement
     * const proficiencyRequirement = await prisma.proficiencyRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proficiencyRequirementUpdateArgs>(
      args: SelectSubset<T, proficiencyRequirementUpdateArgs>
    ): CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>>

    /**
     * Delete zero or more ProficiencyRequirements.
     * @param {proficiencyRequirementDeleteManyArgs} args - Arguments to filter ProficiencyRequirements to delete.
     * @example
     * // Delete a few ProficiencyRequirements
     * const { count } = await prisma.proficiencyRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proficiencyRequirementDeleteManyArgs>(
      args?: SelectSubset<T, proficiencyRequirementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProficiencyRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proficiencyRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProficiencyRequirements
     * const proficiencyRequirement = await prisma.proficiencyRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proficiencyRequirementUpdateManyArgs>(
      args: SelectSubset<T, proficiencyRequirementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProficiencyRequirement.
     * @param {proficiencyRequirementUpsertArgs} args - Arguments to update or create a ProficiencyRequirement.
     * @example
     * // Update or create a ProficiencyRequirement
     * const proficiencyRequirement = await prisma.proficiencyRequirement.upsert({
     *   create: {
     *     // ... data to create a ProficiencyRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProficiencyRequirement we want to update
     *   }
     * })
    **/
    upsert<T extends proficiencyRequirementUpsertArgs>(
      args: SelectSubset<T, proficiencyRequirementUpsertArgs>
    ): CheckSelect<T, Prisma__proficiencyRequirementClient<proficiencyRequirement>, Prisma__proficiencyRequirementClient<proficiencyRequirementGetPayload<T>>>

    /**
     * Count the number of ProficiencyRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proficiencyRequirementCountArgs} args - Arguments to filter ProficiencyRequirements to count.
     * @example
     * // Count the number of ProficiencyRequirements
     * const count = await prisma.proficiencyRequirement.count({
     *   where: {
     *     // ... the filter for the ProficiencyRequirements we want to count
     *   }
     * })
    **/
    count<T extends proficiencyRequirementCountArgs>(
      args?: Subset<T, proficiencyRequirementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProficiencyRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProficiencyRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProficiencyRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProficiencyRequirementAggregateArgs>(args: Subset<T, ProficiencyRequirementAggregateArgs>): PrismaPromise<GetProficiencyRequirementAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for proficiencyRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__proficiencyRequirementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    DegreeRequirement<T extends DegreeRequirementArgs = {}>(args?: Subset<T, DegreeRequirementArgs>): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement | null >, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * proficiencyRequirement findUnique
   */
  export type proficiencyRequirementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * Throw an Error if a proficiencyRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which proficiencyRequirement to fetch.
    **/
    where: proficiencyRequirementWhereUniqueInput
  }


  /**
   * proficiencyRequirement findFirst
   */
  export type proficiencyRequirementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * Throw an Error if a proficiencyRequirement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which proficiencyRequirement to fetch.
    **/
    where?: proficiencyRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proficiencyRequirements to fetch.
    **/
    orderBy?: Enumerable<proficiencyRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proficiencyRequirements.
    **/
    cursor?: proficiencyRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proficiencyRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proficiencyRequirements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proficiencyRequirements.
    **/
    distinct?: Enumerable<ProficiencyRequirementScalarFieldEnum>
  }


  /**
   * proficiencyRequirement findMany
   */
  export type proficiencyRequirementFindManyArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * Filter, which proficiencyRequirements to fetch.
    **/
    where?: proficiencyRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proficiencyRequirements to fetch.
    **/
    orderBy?: Enumerable<proficiencyRequirementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proficiencyRequirements.
    **/
    cursor?: proficiencyRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proficiencyRequirements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proficiencyRequirements.
    **/
    skip?: number
    distinct?: Enumerable<ProficiencyRequirementScalarFieldEnum>
  }


  /**
   * proficiencyRequirement create
   */
  export type proficiencyRequirementCreateArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * The data needed to create a proficiencyRequirement.
    **/
    data: XOR<proficiencyRequirementCreateInput, proficiencyRequirementUncheckedCreateInput>
  }


  /**
   * proficiencyRequirement update
   */
  export type proficiencyRequirementUpdateArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * The data needed to update a proficiencyRequirement.
    **/
    data: XOR<proficiencyRequirementUpdateInput, proficiencyRequirementUncheckedUpdateInput>
    /**
     * Choose, which proficiencyRequirement to update.
    **/
    where: proficiencyRequirementWhereUniqueInput
  }


  /**
   * proficiencyRequirement updateMany
   */
  export type proficiencyRequirementUpdateManyArgs = {
    data: XOR<proficiencyRequirementUpdateManyMutationInput, proficiencyRequirementUncheckedUpdateManyInput>
    where?: proficiencyRequirementWhereInput
  }


  /**
   * proficiencyRequirement upsert
   */
  export type proficiencyRequirementUpsertArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * The filter to search for the proficiencyRequirement to update in case it exists.
    **/
    where: proficiencyRequirementWhereUniqueInput
    /**
     * In case the proficiencyRequirement found by the `where` argument doesn't exist, create a new proficiencyRequirement with this data.
    **/
    create: XOR<proficiencyRequirementCreateInput, proficiencyRequirementUncheckedCreateInput>
    /**
     * In case the proficiencyRequirement was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<proficiencyRequirementUpdateInput, proficiencyRequirementUncheckedUpdateInput>
  }


  /**
   * proficiencyRequirement delete
   */
  export type proficiencyRequirementDeleteArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
    /**
     * Filter which proficiencyRequirement to delete.
    **/
    where: proficiencyRequirementWhereUniqueInput
  }


  /**
   * proficiencyRequirement deleteMany
   */
  export type proficiencyRequirementDeleteManyArgs = {
    where?: proficiencyRequirementWhereInput
  }


  /**
   * proficiencyRequirement without action
   */
  export type proficiencyRequirementArgs = {
    /**
     * Select specific fields to fetch from the proficiencyRequirement
    **/
    select?: proficiencyRequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: proficiencyRequirementInclude | null
  }



  /**
   * Model requiredCourse
   */


  export type AggregateRequiredCourse = {
    count: RequiredCourseCountAggregateOutputType | null
    avg: RequiredCourseAvgAggregateOutputType | null
    sum: RequiredCourseSumAggregateOutputType | null
    min: RequiredCourseMinAggregateOutputType | null
    max: RequiredCourseMaxAggregateOutputType | null
  }

  export type RequiredCourseAvgAggregateOutputType = {
    requirementID: number
  }

  export type RequiredCourseSumAggregateOutputType = {
    requirementID: number
  }

  export type RequiredCourseMinAggregateOutputType = {
    requirementID: number
    courseID: string | null
  }

  export type RequiredCourseMaxAggregateOutputType = {
    requirementID: number
    courseID: string | null
  }

  export type RequiredCourseCountAggregateOutputType = {
    requirementID: number
    courseID: number | null
    _all: number
  }


  export type RequiredCourseAvgAggregateInputType = {
    requirementID?: true
  }

  export type RequiredCourseSumAggregateInputType = {
    requirementID?: true
  }

  export type RequiredCourseMinAggregateInputType = {
    requirementID?: true
    courseID?: true
  }

  export type RequiredCourseMaxAggregateInputType = {
    requirementID?: true
    courseID?: true
  }

  export type RequiredCourseCountAggregateInputType = {
    requirementID?: true
    courseID?: true
    _all?: true
  }

  export type RequiredCourseAggregateArgs = {
    /**
     * Filter which requiredCourse to aggregate.
    **/
    where?: requiredCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requiredCourses to fetch.
    **/
    orderBy?: Enumerable<requiredCourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: requiredCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requiredCourses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requiredCourses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requiredCourses
    **/
    count?: true | RequiredCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RequiredCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RequiredCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RequiredCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RequiredCourseMaxAggregateInputType
  }

  export type GetRequiredCourseAggregateType<T extends RequiredCourseAggregateArgs> = {
    [P in keyof T & keyof AggregateRequiredCourse]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequiredCourse[P]>
      : GetScalarType<T[P], AggregateRequiredCourse[P]>
  }



  export type requiredCourseSelect = {
    requirementID?: boolean
    courseID?: boolean
    Course?: boolean | CourseArgs
    DegreeRequirement?: boolean | DegreeRequirementArgs
  }

  export type requiredCourseInclude = {
    Course?: boolean | CourseArgs
    DegreeRequirement?: boolean | DegreeRequirementArgs
  }

  export type requiredCourseGetPayload<
    S extends boolean | null | undefined | requiredCourseArgs,
    U = keyof S
      > = S extends true
        ? requiredCourse
    : S extends undefined
    ? never
    : S extends requiredCourseArgs | requiredCourseFindManyArgs
    ?'include' extends U
    ? requiredCourse  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course'
        ? CourseGetPayload<S['include'][P]> :
        P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof requiredCourse ?requiredCourse [P]
  : 
          P extends 'Course'
        ? CourseGetPayload<S['select'][P]> :
        P extends 'DegreeRequirement'
        ? DegreeRequirementGetPayload<S['select'][P]> : never
  } 
    : requiredCourse
  : requiredCourse


  type requiredCourseCountArgs = Merge<
    Omit<requiredCourseFindManyArgs, 'select' | 'include'> & {
      select?: RequiredCourseCountAggregateInputType | true
    }
  >

  export interface requiredCourseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequiredCourse that matches the filter.
     * @param {requiredCourseFindUniqueArgs} args - Arguments to find a RequiredCourse
     * @example
     * // Get one RequiredCourse
     * const requiredCourse = await prisma.requiredCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requiredCourseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, requiredCourseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'requiredCourse'> extends True ? CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>> : CheckSelect<T, Prisma__requiredCourseClient<requiredCourse | null >, Prisma__requiredCourseClient<requiredCourseGetPayload<T> | null >>

    /**
     * Find the first RequiredCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requiredCourseFindFirstArgs} args - Arguments to find a RequiredCourse
     * @example
     * // Get one RequiredCourse
     * const requiredCourse = await prisma.requiredCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requiredCourseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, requiredCourseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'requiredCourse'> extends True ? CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>> : CheckSelect<T, Prisma__requiredCourseClient<requiredCourse | null >, Prisma__requiredCourseClient<requiredCourseGetPayload<T> | null >>

    /**
     * Find zero or more RequiredCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requiredCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequiredCourses
     * const requiredCourses = await prisma.requiredCourse.findMany()
     * 
     * // Get first 10 RequiredCourses
     * const requiredCourses = await prisma.requiredCourse.findMany({ take: 10 })
     * 
     * // Only select the `requirementID`
     * const requiredCourseWithRequirementIDOnly = await prisma.requiredCourse.findMany({ select: { requirementID: true } })
     * 
    **/
    findMany<T extends requiredCourseFindManyArgs>(
      args?: SelectSubset<T, requiredCourseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<requiredCourse>>, PrismaPromise<Array<requiredCourseGetPayload<T>>>>

    /**
     * Create a RequiredCourse.
     * @param {requiredCourseCreateArgs} args - Arguments to create a RequiredCourse.
     * @example
     * // Create one RequiredCourse
     * const RequiredCourse = await prisma.requiredCourse.create({
     *   data: {
     *     // ... data to create a RequiredCourse
     *   }
     * })
     * 
    **/
    create<T extends requiredCourseCreateArgs>(
      args: SelectSubset<T, requiredCourseCreateArgs>
    ): CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>>

    /**
     * Delete a RequiredCourse.
     * @param {requiredCourseDeleteArgs} args - Arguments to delete one RequiredCourse.
     * @example
     * // Delete one RequiredCourse
     * const RequiredCourse = await prisma.requiredCourse.delete({
     *   where: {
     *     // ... filter to delete one RequiredCourse
     *   }
     * })
     * 
    **/
    delete<T extends requiredCourseDeleteArgs>(
      args: SelectSubset<T, requiredCourseDeleteArgs>
    ): CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>>

    /**
     * Update one RequiredCourse.
     * @param {requiredCourseUpdateArgs} args - Arguments to update one RequiredCourse.
     * @example
     * // Update one RequiredCourse
     * const requiredCourse = await prisma.requiredCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requiredCourseUpdateArgs>(
      args: SelectSubset<T, requiredCourseUpdateArgs>
    ): CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>>

    /**
     * Delete zero or more RequiredCourses.
     * @param {requiredCourseDeleteManyArgs} args - Arguments to filter RequiredCourses to delete.
     * @example
     * // Delete a few RequiredCourses
     * const { count } = await prisma.requiredCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requiredCourseDeleteManyArgs>(
      args?: SelectSubset<T, requiredCourseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequiredCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requiredCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequiredCourses
     * const requiredCourse = await prisma.requiredCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requiredCourseUpdateManyArgs>(
      args: SelectSubset<T, requiredCourseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequiredCourse.
     * @param {requiredCourseUpsertArgs} args - Arguments to update or create a RequiredCourse.
     * @example
     * // Update or create a RequiredCourse
     * const requiredCourse = await prisma.requiredCourse.upsert({
     *   create: {
     *     // ... data to create a RequiredCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequiredCourse we want to update
     *   }
     * })
    **/
    upsert<T extends requiredCourseUpsertArgs>(
      args: SelectSubset<T, requiredCourseUpsertArgs>
    ): CheckSelect<T, Prisma__requiredCourseClient<requiredCourse>, Prisma__requiredCourseClient<requiredCourseGetPayload<T>>>

    /**
     * Count the number of RequiredCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requiredCourseCountArgs} args - Arguments to filter RequiredCourses to count.
     * @example
     * // Count the number of RequiredCourses
     * const count = await prisma.requiredCourse.count({
     *   where: {
     *     // ... the filter for the RequiredCourses we want to count
     *   }
     * })
    **/
    count<T extends requiredCourseCountArgs>(
      args?: Subset<T, requiredCourseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequiredCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequiredCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequiredCourseAggregateArgs>(args: Subset<T, RequiredCourseAggregateArgs>): PrismaPromise<GetRequiredCourseAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for requiredCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__requiredCourseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    DegreeRequirement<T extends DegreeRequirementArgs = {}>(args?: Subset<T, DegreeRequirementArgs>): CheckSelect<T, Prisma__DegreeRequirementClient<DegreeRequirement | null >, Prisma__DegreeRequirementClient<DegreeRequirementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * requiredCourse findUnique
   */
  export type requiredCourseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * Throw an Error if a requiredCourse can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requiredCourse to fetch.
    **/
    where: requiredCourseWhereUniqueInput
  }


  /**
   * requiredCourse findFirst
   */
  export type requiredCourseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * Throw an Error if a requiredCourse can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requiredCourse to fetch.
    **/
    where?: requiredCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requiredCourses to fetch.
    **/
    orderBy?: Enumerable<requiredCourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requiredCourses.
    **/
    cursor?: requiredCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requiredCourses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requiredCourses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requiredCourses.
    **/
    distinct?: Enumerable<RequiredCourseScalarFieldEnum>
  }


  /**
   * requiredCourse findMany
   */
  export type requiredCourseFindManyArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * Filter, which requiredCourses to fetch.
    **/
    where?: requiredCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requiredCourses to fetch.
    **/
    orderBy?: Enumerable<requiredCourseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requiredCourses.
    **/
    cursor?: requiredCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requiredCourses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requiredCourses.
    **/
    skip?: number
    distinct?: Enumerable<RequiredCourseScalarFieldEnum>
  }


  /**
   * requiredCourse create
   */
  export type requiredCourseCreateArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * The data needed to create a requiredCourse.
    **/
    data: XOR<requiredCourseCreateInput, requiredCourseUncheckedCreateInput>
  }


  /**
   * requiredCourse update
   */
  export type requiredCourseUpdateArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * The data needed to update a requiredCourse.
    **/
    data: XOR<requiredCourseUpdateInput, requiredCourseUncheckedUpdateInput>
    /**
     * Choose, which requiredCourse to update.
    **/
    where: requiredCourseWhereUniqueInput
  }


  /**
   * requiredCourse updateMany
   */
  export type requiredCourseUpdateManyArgs = {
    data: XOR<requiredCourseUpdateManyMutationInput, requiredCourseUncheckedUpdateManyInput>
    where?: requiredCourseWhereInput
  }


  /**
   * requiredCourse upsert
   */
  export type requiredCourseUpsertArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * The filter to search for the requiredCourse to update in case it exists.
    **/
    where: requiredCourseWhereUniqueInput
    /**
     * In case the requiredCourse found by the `where` argument doesn't exist, create a new requiredCourse with this data.
    **/
    create: XOR<requiredCourseCreateInput, requiredCourseUncheckedCreateInput>
    /**
     * In case the requiredCourse was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<requiredCourseUpdateInput, requiredCourseUncheckedUpdateInput>
  }


  /**
   * requiredCourse delete
   */
  export type requiredCourseDeleteArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
    /**
     * Filter which requiredCourse to delete.
    **/
    where: requiredCourseWhereUniqueInput
  }


  /**
   * requiredCourse deleteMany
   */
  export type requiredCourseDeleteManyArgs = {
    where?: requiredCourseWhereInput
  }


  /**
   * requiredCourse without action
   */
  export type requiredCourseArgs = {
    /**
     * Select specific fields to fetch from the requiredCourse
    **/
    select?: requiredCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: requiredCourseInclude | null
  }



  /**
   * Model RequiredStatus
   */


  export type AggregateRequiredStatus = {
    count: RequiredStatusCountAggregateOutputType | null
    avg: RequiredStatusAvgAggregateOutputType | null
    sum: RequiredStatusSumAggregateOutputType | null
    min: RequiredStatusMinAggregateOutputType | null
    max: RequiredStatusMaxAggregateOutputType | null
  }

  export type RequiredStatusAvgAggregateOutputType = {
    studentID: number
  }

  export type RequiredStatusSumAggregateOutputType = {
    studentID: number
  }

  export type RequiredStatusMinAggregateOutputType = {
    studentID: number
    courseID: string | null
    status: RequiredStatus_status | null
  }

  export type RequiredStatusMaxAggregateOutputType = {
    studentID: number
    courseID: string | null
    status: RequiredStatus_status | null
  }

  export type RequiredStatusCountAggregateOutputType = {
    studentID: number
    courseID: number | null
    status: number | null
    _all: number
  }


  export type RequiredStatusAvgAggregateInputType = {
    studentID?: true
  }

  export type RequiredStatusSumAggregateInputType = {
    studentID?: true
  }

  export type RequiredStatusMinAggregateInputType = {
    studentID?: true
    courseID?: true
    status?: true
  }

  export type RequiredStatusMaxAggregateInputType = {
    studentID?: true
    courseID?: true
    status?: true
  }

  export type RequiredStatusCountAggregateInputType = {
    studentID?: true
    courseID?: true
    status?: true
    _all?: true
  }

  export type RequiredStatusAggregateArgs = {
    /**
     * Filter which RequiredStatus to aggregate.
    **/
    where?: RequiredStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequiredStatuses to fetch.
    **/
    orderBy?: Enumerable<RequiredStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RequiredStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequiredStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequiredStatuses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequiredStatuses
    **/
    count?: true | RequiredStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RequiredStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RequiredStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RequiredStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RequiredStatusMaxAggregateInputType
  }

  export type GetRequiredStatusAggregateType<T extends RequiredStatusAggregateArgs> = {
    [P in keyof T & keyof AggregateRequiredStatus]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequiredStatus[P]>
      : GetScalarType<T[P], AggregateRequiredStatus[P]>
  }



  export type RequiredStatusSelect = {
    studentID?: boolean
    courseID?: boolean
    status?: boolean
    Course?: boolean | CourseArgs
    Student?: boolean | StudentArgs
  }

  export type RequiredStatusInclude = {
    Course?: boolean | CourseArgs
    Student?: boolean | StudentArgs
  }

  export type RequiredStatusGetPayload<
    S extends boolean | null | undefined | RequiredStatusArgs,
    U = keyof S
      > = S extends true
        ? RequiredStatus
    : S extends undefined
    ? never
    : S extends RequiredStatusArgs | RequiredStatusFindManyArgs
    ?'include' extends U
    ? RequiredStatus  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Course'
        ? CourseGetPayload<S['include'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RequiredStatus ?RequiredStatus [P]
  : 
          P extends 'Course'
        ? CourseGetPayload<S['select'][P]> :
        P extends 'Student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : RequiredStatus
  : RequiredStatus


  type RequiredStatusCountArgs = Merge<
    Omit<RequiredStatusFindManyArgs, 'select' | 'include'> & {
      select?: RequiredStatusCountAggregateInputType | true
    }
  >

  export interface RequiredStatusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequiredStatus that matches the filter.
     * @param {RequiredStatusFindUniqueArgs} args - Arguments to find a RequiredStatus
     * @example
     * // Get one RequiredStatus
     * const requiredStatus = await prisma.requiredStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequiredStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequiredStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequiredStatus'> extends True ? CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>> : CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus | null >, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T> | null >>

    /**
     * Find the first RequiredStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredStatusFindFirstArgs} args - Arguments to find a RequiredStatus
     * @example
     * // Get one RequiredStatus
     * const requiredStatus = await prisma.requiredStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequiredStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequiredStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequiredStatus'> extends True ? CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>> : CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus | null >, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T> | null >>

    /**
     * Find zero or more RequiredStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequiredStatuses
     * const requiredStatuses = await prisma.requiredStatus.findMany()
     * 
     * // Get first 10 RequiredStatuses
     * const requiredStatuses = await prisma.requiredStatus.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const requiredStatusWithStudentIDOnly = await prisma.requiredStatus.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends RequiredStatusFindManyArgs>(
      args?: SelectSubset<T, RequiredStatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequiredStatus>>, PrismaPromise<Array<RequiredStatusGetPayload<T>>>>

    /**
     * Create a RequiredStatus.
     * @param {RequiredStatusCreateArgs} args - Arguments to create a RequiredStatus.
     * @example
     * // Create one RequiredStatus
     * const RequiredStatus = await prisma.requiredStatus.create({
     *   data: {
     *     // ... data to create a RequiredStatus
     *   }
     * })
     * 
    **/
    create<T extends RequiredStatusCreateArgs>(
      args: SelectSubset<T, RequiredStatusCreateArgs>
    ): CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>>

    /**
     * Delete a RequiredStatus.
     * @param {RequiredStatusDeleteArgs} args - Arguments to delete one RequiredStatus.
     * @example
     * // Delete one RequiredStatus
     * const RequiredStatus = await prisma.requiredStatus.delete({
     *   where: {
     *     // ... filter to delete one RequiredStatus
     *   }
     * })
     * 
    **/
    delete<T extends RequiredStatusDeleteArgs>(
      args: SelectSubset<T, RequiredStatusDeleteArgs>
    ): CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>>

    /**
     * Update one RequiredStatus.
     * @param {RequiredStatusUpdateArgs} args - Arguments to update one RequiredStatus.
     * @example
     * // Update one RequiredStatus
     * const requiredStatus = await prisma.requiredStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequiredStatusUpdateArgs>(
      args: SelectSubset<T, RequiredStatusUpdateArgs>
    ): CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>>

    /**
     * Delete zero or more RequiredStatuses.
     * @param {RequiredStatusDeleteManyArgs} args - Arguments to filter RequiredStatuses to delete.
     * @example
     * // Delete a few RequiredStatuses
     * const { count } = await prisma.requiredStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequiredStatusDeleteManyArgs>(
      args?: SelectSubset<T, RequiredStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequiredStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequiredStatuses
     * const requiredStatus = await prisma.requiredStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequiredStatusUpdateManyArgs>(
      args: SelectSubset<T, RequiredStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequiredStatus.
     * @param {RequiredStatusUpsertArgs} args - Arguments to update or create a RequiredStatus.
     * @example
     * // Update or create a RequiredStatus
     * const requiredStatus = await prisma.requiredStatus.upsert({
     *   create: {
     *     // ... data to create a RequiredStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequiredStatus we want to update
     *   }
     * })
    **/
    upsert<T extends RequiredStatusUpsertArgs>(
      args: SelectSubset<T, RequiredStatusUpsertArgs>
    ): CheckSelect<T, Prisma__RequiredStatusClient<RequiredStatus>, Prisma__RequiredStatusClient<RequiredStatusGetPayload<T>>>

    /**
     * Count the number of RequiredStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredStatusCountArgs} args - Arguments to filter RequiredStatuses to count.
     * @example
     * // Count the number of RequiredStatuses
     * const count = await prisma.requiredStatus.count({
     *   where: {
     *     // ... the filter for the RequiredStatuses we want to count
     *   }
     * })
    **/
    count<T extends RequiredStatusCountArgs>(
      args?: Subset<T, RequiredStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequiredStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequiredStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequiredStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequiredStatusAggregateArgs>(args: Subset<T, RequiredStatusAggregateArgs>): PrismaPromise<GetRequiredStatusAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for RequiredStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequiredStatusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null >, Prisma__CourseClient<CourseGetPayload<T> | null >>;

    Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequiredStatus findUnique
   */
  export type RequiredStatusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * Throw an Error if a RequiredStatus can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequiredStatus to fetch.
    **/
    where: RequiredStatusWhereUniqueInput
  }


  /**
   * RequiredStatus findFirst
   */
  export type RequiredStatusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * Throw an Error if a RequiredStatus can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequiredStatus to fetch.
    **/
    where?: RequiredStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequiredStatuses to fetch.
    **/
    orderBy?: Enumerable<RequiredStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequiredStatuses.
    **/
    cursor?: RequiredStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequiredStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequiredStatuses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequiredStatuses.
    **/
    distinct?: Enumerable<RequiredStatusScalarFieldEnum>
  }


  /**
   * RequiredStatus findMany
   */
  export type RequiredStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * Filter, which RequiredStatuses to fetch.
    **/
    where?: RequiredStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequiredStatuses to fetch.
    **/
    orderBy?: Enumerable<RequiredStatusOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequiredStatuses.
    **/
    cursor?: RequiredStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequiredStatuses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequiredStatuses.
    **/
    skip?: number
    distinct?: Enumerable<RequiredStatusScalarFieldEnum>
  }


  /**
   * RequiredStatus create
   */
  export type RequiredStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * The data needed to create a RequiredStatus.
    **/
    data: XOR<RequiredStatusCreateInput, RequiredStatusUncheckedCreateInput>
  }


  /**
   * RequiredStatus update
   */
  export type RequiredStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * The data needed to update a RequiredStatus.
    **/
    data: XOR<RequiredStatusUpdateInput, RequiredStatusUncheckedUpdateInput>
    /**
     * Choose, which RequiredStatus to update.
    **/
    where: RequiredStatusWhereUniqueInput
  }


  /**
   * RequiredStatus updateMany
   */
  export type RequiredStatusUpdateManyArgs = {
    data: XOR<RequiredStatusUpdateManyMutationInput, RequiredStatusUncheckedUpdateManyInput>
    where?: RequiredStatusWhereInput
  }


  /**
   * RequiredStatus upsert
   */
  export type RequiredStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * The filter to search for the RequiredStatus to update in case it exists.
    **/
    where: RequiredStatusWhereUniqueInput
    /**
     * In case the RequiredStatus found by the `where` argument doesn't exist, create a new RequiredStatus with this data.
    **/
    create: XOR<RequiredStatusCreateInput, RequiredStatusUncheckedCreateInput>
    /**
     * In case the RequiredStatus was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RequiredStatusUpdateInput, RequiredStatusUncheckedUpdateInput>
  }


  /**
   * RequiredStatus delete
   */
  export type RequiredStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
    /**
     * Filter which RequiredStatus to delete.
    **/
    where: RequiredStatusWhereUniqueInput
  }


  /**
   * RequiredStatus deleteMany
   */
  export type RequiredStatusDeleteManyArgs = {
    where?: RequiredStatusWhereInput
  }


  /**
   * RequiredStatus without action
   */
  export type RequiredStatusArgs = {
    /**
     * Select specific fields to fetch from the RequiredStatus
    **/
    select?: RequiredStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RequiredStatusInclude | null
  }



  /**
   * Model Student
   */


  export type AggregateStudent = {
    count: StudentCountAggregateOutputType | null
    avg: StudentAvgAggregateOutputType | null
    sum: StudentSumAggregateOutputType | null
    min: StudentMinAggregateOutputType | null
    max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    studentID: number
    requirementID: number | null
    entryYear: number
    gradYear: number | null
    nSemestersInProgram: number
    gpa: Decimal | null
    totalCredits: number | null
  }

  export type StudentSumAggregateOutputType = {
    studentID: number
    requirementID: number | null
    entryYear: number
    gradYear: number | null
    nSemestersInProgram: number
    gpa: Decimal | null
    totalCredits: number | null
  }

  export type StudentMinAggregateOutputType = {
    studentID: number
    firstName: string | null
    lastName: string | null
    requirementID: number | null
    entrySemester: Student_entrySemester | null
    entryYear: number
    gradSemester: Student_gradSemester | null
    gradYear: number | null
    nSemestersInProgram: number
    gpa: Decimal | null
    totalCredits: number | null
    projectOption: string | null
    advisor: string | null
    hasGraduated: boolean | null
  }

  export type StudentMaxAggregateOutputType = {
    studentID: number
    firstName: string | null
    lastName: string | null
    requirementID: number | null
    entrySemester: Student_entrySemester | null
    entryYear: number
    gradSemester: Student_gradSemester | null
    gradYear: number | null
    nSemestersInProgram: number
    gpa: Decimal | null
    totalCredits: number | null
    projectOption: string | null
    advisor: string | null
    hasGraduated: boolean | null
  }

  export type StudentCountAggregateOutputType = {
    studentID: number
    firstName: number | null
    lastName: number | null
    requirementID: number | null
    entrySemester: number | null
    entryYear: number
    gradSemester: number | null
    gradYear: number | null
    nSemestersInProgram: number
    gpa: number | null
    totalCredits: number | null
    projectOption: number | null
    advisor: number | null
    hasGraduated: number | null
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    studentID?: true
    requirementID?: true
    entryYear?: true
    gradYear?: true
    nSemestersInProgram?: true
    gpa?: true
    totalCredits?: true
  }

  export type StudentSumAggregateInputType = {
    studentID?: true
    requirementID?: true
    entryYear?: true
    gradYear?: true
    nSemestersInProgram?: true
    gpa?: true
    totalCredits?: true
  }

  export type StudentMinAggregateInputType = {
    studentID?: true
    firstName?: true
    lastName?: true
    requirementID?: true
    entrySemester?: true
    entryYear?: true
    gradSemester?: true
    gradYear?: true
    nSemestersInProgram?: true
    gpa?: true
    totalCredits?: true
    projectOption?: true
    advisor?: true
    hasGraduated?: true
  }

  export type StudentMaxAggregateInputType = {
    studentID?: true
    firstName?: true
    lastName?: true
    requirementID?: true
    entrySemester?: true
    entryYear?: true
    gradSemester?: true
    gradYear?: true
    nSemestersInProgram?: true
    gpa?: true
    totalCredits?: true
    projectOption?: true
    advisor?: true
    hasGraduated?: true
  }

  export type StudentCountAggregateInputType = {
    studentID?: true
    firstName?: true
    lastName?: true
    requirementID?: true
    entrySemester?: true
    entryYear?: true
    gradSemester?: true
    gradYear?: true
    nSemestersInProgram?: true
    gpa?: true
    totalCredits?: true
    projectOption?: true
    advisor?: true
    hasGraduated?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which Student to aggregate.
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
    **/
    orderBy?: Enumerable<StudentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
    [P in keyof T & keyof AggregateStudent]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }



  export type StudentSelect = {
    studentID?: boolean
    firstName?: boolean
    lastName?: boolean
    requirementID?: boolean
    entrySemester?: boolean
    entryYear?: boolean
    gradSemester?: boolean
    gradYear?: boolean
    nSemestersInProgram?: boolean
    gpa?: boolean
    totalCredits?: boolean
    projectOption?: boolean
    advisor?: boolean
    hasGraduated?: boolean
    Comments?: boolean | CommentsFindManyArgs
    CoursePlan?: boolean | CoursePlanArgs
    ElectiveStatus?: boolean | ElectiveStatusFindManyArgs
    Grades?: boolean | GradesFindManyArgs
    RequiredStatus?: boolean | RequiredStatusFindManyArgs
  }

  export type StudentInclude = {
    Comments?: boolean | CommentsFindManyArgs
    CoursePlan?: boolean | CoursePlanArgs
    ElectiveStatus?: boolean | ElectiveStatusFindManyArgs
    Grades?: boolean | GradesFindManyArgs
    RequiredStatus?: boolean | RequiredStatusFindManyArgs
  }

  export type StudentGetPayload<
    S extends boolean | null | undefined | StudentArgs,
    U = keyof S
      > = S extends true
        ? Student
    : S extends undefined
    ? never
    : S extends StudentArgs | StudentFindManyArgs
    ?'include' extends U
    ? Student  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Comments'
        ? Array < CommentsGetPayload<S['include'][P]>>  :
        P extends 'CoursePlan'
        ? CoursePlanGetPayload<S['include'][P]> | null :
        P extends 'ElectiveStatus'
        ? Array < ElectiveStatusGetPayload<S['include'][P]>>  :
        P extends 'Grades'
        ? Array < GradesGetPayload<S['include'][P]>>  :
        P extends 'RequiredStatus'
        ? Array < RequiredStatusGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Student ?Student [P]
  : 
          P extends 'Comments'
        ? Array < CommentsGetPayload<S['select'][P]>>  :
        P extends 'CoursePlan'
        ? CoursePlanGetPayload<S['select'][P]> | null :
        P extends 'ElectiveStatus'
        ? Array < ElectiveStatusGetPayload<S['select'][P]>>  :
        P extends 'Grades'
        ? Array < GradesGetPayload<S['select'][P]>>  :
        P extends 'RequiredStatus'
        ? Array < RequiredStatusGetPayload<S['select'][P]>>  : never
  } 
    : Student
  : Student


  type StudentCountArgs = Merge<
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }
  >

  export interface StudentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Student'> extends True ? CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>> : CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Student'> extends True ? CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>> : CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `studentID`
     * const studentWithStudentIDOnly = await prisma.student.findMany({ select: { studentID: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): PrismaPromise<GetStudentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Comments<T extends CommentsFindManyArgs = {}>(args?: Subset<T, CommentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>;

    CoursePlan<T extends CoursePlanArgs = {}>(args?: Subset<T, CoursePlanArgs>): CheckSelect<T, Prisma__CoursePlanClient<CoursePlan | null >, Prisma__CoursePlanClient<CoursePlanGetPayload<T> | null >>;

    ElectiveStatus<T extends ElectiveStatusFindManyArgs = {}>(args?: Subset<T, ElectiveStatusFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ElectiveStatus>>, PrismaPromise<Array<ElectiveStatusGetPayload<T>>>>;

    Grades<T extends GradesFindManyArgs = {}>(args?: Subset<T, GradesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Grades>>, PrismaPromise<Array<GradesGetPayload<T>>>>;

    RequiredStatus<T extends RequiredStatusFindManyArgs = {}>(args?: Subset<T, RequiredStatusFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequiredStatus>>, PrismaPromise<Array<RequiredStatusGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * Throw an Error if a Student can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Student to fetch.
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * Throw an Error if a Student can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Student to fetch.
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
    **/
    orderBy?: Enumerable<StudentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
    **/
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * Filter, which Students to fetch.
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
    **/
    orderBy?: Enumerable<StudentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
    **/
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student create
   */
  export type StudentCreateArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * The data needed to create a Student.
    **/
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * The data needed to update a Student.
    **/
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs = {
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * The filter to search for the Student to update in case it exists.
    **/
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
    **/
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
    /**
     * Filter which Student to delete.
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs = {
    where?: StudentWhereInput
  }


  /**
   * Student without action
   */
  export type StudentArgs = {
    /**
     * Select specific fields to fetch from the Student
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StudentInclude | null
  }



  /**
   * Model SubArea
   */


  export type AggregateSubArea = {
    count: SubAreaCountAggregateOutputType | null
    avg: SubAreaAvgAggregateOutputType | null
    sum: SubAreaSumAggregateOutputType | null
    min: SubAreaMinAggregateOutputType | null
    max: SubAreaMaxAggregateOutputType | null
  }

  export type SubAreaAvgAggregateOutputType = {
    areaID: number
    minCourses: number | null
    minCredit: number | null
    maxCredit: number | null
    maxCourse: number | null
  }

  export type SubAreaSumAggregateOutputType = {
    areaID: number
    minCourses: number | null
    minCredit: number | null
    maxCredit: number | null
    maxCourse: number | null
  }

  export type SubAreaMinAggregateOutputType = {
    areaID: number
    minCourses: number | null
    minCredit: number | null
    maxCredit: number | null
    maxCourse: number | null
    name: string | null
  }

  export type SubAreaMaxAggregateOutputType = {
    areaID: number
    minCourses: number | null
    minCredit: number | null
    maxCredit: number | null
    maxCourse: number | null
    name: string | null
  }

  export type SubAreaCountAggregateOutputType = {
    areaID: number
    minCourses: number | null
    minCredit: number | null
    maxCredit: number | null
    maxCourse: number | null
    name: number | null
    _all: number
  }


  export type SubAreaAvgAggregateInputType = {
    areaID?: true
    minCourses?: true
    minCredit?: true
    maxCredit?: true
    maxCourse?: true
  }

  export type SubAreaSumAggregateInputType = {
    areaID?: true
    minCourses?: true
    minCredit?: true
    maxCredit?: true
    maxCourse?: true
  }

  export type SubAreaMinAggregateInputType = {
    areaID?: true
    minCourses?: true
    minCredit?: true
    maxCredit?: true
    maxCourse?: true
    name?: true
  }

  export type SubAreaMaxAggregateInputType = {
    areaID?: true
    minCourses?: true
    minCredit?: true
    maxCredit?: true
    maxCourse?: true
    name?: true
  }

  export type SubAreaCountAggregateInputType = {
    areaID?: true
    minCourses?: true
    minCredit?: true
    maxCredit?: true
    maxCourse?: true
    name?: true
    _all?: true
  }

  export type SubAreaAggregateArgs = {
    /**
     * Filter which SubArea to aggregate.
    **/
    where?: SubAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAreas to fetch.
    **/
    orderBy?: Enumerable<SubAreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SubAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAreas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAreas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAreas
    **/
    count?: true | SubAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SubAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SubAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SubAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SubAreaMaxAggregateInputType
  }

  export type GetSubAreaAggregateType<T extends SubAreaAggregateArgs> = {
    [P in keyof T & keyof AggregateSubArea]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubArea[P]>
      : GetScalarType<T[P], AggregateSubArea[P]>
  }



  export type SubAreaSelect = {
    areaID?: boolean
    minCourses?: boolean
    minCredit?: boolean
    maxCredit?: boolean
    maxCourse?: boolean
    name?: boolean
    Area?: boolean | AreaArgs
  }

  export type SubAreaInclude = {
    Area?: boolean | AreaArgs
  }

  export type SubAreaGetPayload<
    S extends boolean | null | undefined | SubAreaArgs,
    U = keyof S
      > = S extends true
        ? SubArea
    : S extends undefined
    ? never
    : S extends SubAreaArgs | SubAreaFindManyArgs
    ?'include' extends U
    ? SubArea  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Area'
        ? AreaGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SubArea ?SubArea [P]
  : 
          P extends 'Area'
        ? AreaGetPayload<S['select'][P]> : never
  } 
    : SubArea
  : SubArea


  type SubAreaCountArgs = Merge<
    Omit<SubAreaFindManyArgs, 'select' | 'include'> & {
      select?: SubAreaCountAggregateInputType | true
    }
  >

  export interface SubAreaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubArea that matches the filter.
     * @param {SubAreaFindUniqueArgs} args - Arguments to find a SubArea
     * @example
     * // Get one SubArea
     * const subArea = await prisma.subArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubAreaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubAreaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubArea'> extends True ? CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>> : CheckSelect<T, Prisma__SubAreaClient<SubArea | null >, Prisma__SubAreaClient<SubAreaGetPayload<T> | null >>

    /**
     * Find the first SubArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAreaFindFirstArgs} args - Arguments to find a SubArea
     * @example
     * // Get one SubArea
     * const subArea = await prisma.subArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubAreaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubAreaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubArea'> extends True ? CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>> : CheckSelect<T, Prisma__SubAreaClient<SubArea | null >, Prisma__SubAreaClient<SubAreaGetPayload<T> | null >>

    /**
     * Find zero or more SubAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAreaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAreas
     * const subAreas = await prisma.subArea.findMany()
     * 
     * // Get first 10 SubAreas
     * const subAreas = await prisma.subArea.findMany({ take: 10 })
     * 
     * // Only select the `areaID`
     * const subAreaWithAreaIDOnly = await prisma.subArea.findMany({ select: { areaID: true } })
     * 
    **/
    findMany<T extends SubAreaFindManyArgs>(
      args?: SelectSubset<T, SubAreaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubArea>>, PrismaPromise<Array<SubAreaGetPayload<T>>>>

    /**
     * Create a SubArea.
     * @param {SubAreaCreateArgs} args - Arguments to create a SubArea.
     * @example
     * // Create one SubArea
     * const SubArea = await prisma.subArea.create({
     *   data: {
     *     // ... data to create a SubArea
     *   }
     * })
     * 
    **/
    create<T extends SubAreaCreateArgs>(
      args: SelectSubset<T, SubAreaCreateArgs>
    ): CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>>

    /**
     * Delete a SubArea.
     * @param {SubAreaDeleteArgs} args - Arguments to delete one SubArea.
     * @example
     * // Delete one SubArea
     * const SubArea = await prisma.subArea.delete({
     *   where: {
     *     // ... filter to delete one SubArea
     *   }
     * })
     * 
    **/
    delete<T extends SubAreaDeleteArgs>(
      args: SelectSubset<T, SubAreaDeleteArgs>
    ): CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>>

    /**
     * Update one SubArea.
     * @param {SubAreaUpdateArgs} args - Arguments to update one SubArea.
     * @example
     * // Update one SubArea
     * const subArea = await prisma.subArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubAreaUpdateArgs>(
      args: SelectSubset<T, SubAreaUpdateArgs>
    ): CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>>

    /**
     * Delete zero or more SubAreas.
     * @param {SubAreaDeleteManyArgs} args - Arguments to filter SubAreas to delete.
     * @example
     * // Delete a few SubAreas
     * const { count } = await prisma.subArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubAreaDeleteManyArgs>(
      args?: SelectSubset<T, SubAreaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAreas
     * const subArea = await prisma.subArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubAreaUpdateManyArgs>(
      args: SelectSubset<T, SubAreaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubArea.
     * @param {SubAreaUpsertArgs} args - Arguments to update or create a SubArea.
     * @example
     * // Update or create a SubArea
     * const subArea = await prisma.subArea.upsert({
     *   create: {
     *     // ... data to create a SubArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubArea we want to update
     *   }
     * })
    **/
    upsert<T extends SubAreaUpsertArgs>(
      args: SelectSubset<T, SubAreaUpsertArgs>
    ): CheckSelect<T, Prisma__SubAreaClient<SubArea>, Prisma__SubAreaClient<SubAreaGetPayload<T>>>

    /**
     * Count the number of SubAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAreaCountArgs} args - Arguments to filter SubAreas to count.
     * @example
     * // Count the number of SubAreas
     * const count = await prisma.subArea.count({
     *   where: {
     *     // ... the filter for the SubAreas we want to count
     *   }
     * })
    **/
    count<T extends SubAreaCountArgs>(
      args?: Subset<T, SubAreaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAreaAggregateArgs>(args: Subset<T, SubAreaAggregateArgs>): PrismaPromise<GetSubAreaAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for SubArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubAreaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Area<T extends AreaArgs = {}>(args?: Subset<T, AreaArgs>): CheckSelect<T, Prisma__AreaClient<Area | null >, Prisma__AreaClient<AreaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubArea findUnique
   */
  export type SubAreaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * Throw an Error if a SubArea can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubArea to fetch.
    **/
    where: SubAreaWhereUniqueInput
  }


  /**
   * SubArea findFirst
   */
  export type SubAreaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * Throw an Error if a SubArea can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubArea to fetch.
    **/
    where?: SubAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAreas to fetch.
    **/
    orderBy?: Enumerable<SubAreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAreas.
    **/
    cursor?: SubAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAreas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAreas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAreas.
    **/
    distinct?: Enumerable<SubAreaScalarFieldEnum>
  }


  /**
   * SubArea findMany
   */
  export type SubAreaFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * Filter, which SubAreas to fetch.
    **/
    where?: SubAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAreas to fetch.
    **/
    orderBy?: Enumerable<SubAreaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAreas.
    **/
    cursor?: SubAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAreas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAreas.
    **/
    skip?: number
    distinct?: Enumerable<SubAreaScalarFieldEnum>
  }


  /**
   * SubArea create
   */
  export type SubAreaCreateArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * The data needed to create a SubArea.
    **/
    data: XOR<SubAreaCreateInput, SubAreaUncheckedCreateInput>
  }


  /**
   * SubArea update
   */
  export type SubAreaUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * The data needed to update a SubArea.
    **/
    data: XOR<SubAreaUpdateInput, SubAreaUncheckedUpdateInput>
    /**
     * Choose, which SubArea to update.
    **/
    where: SubAreaWhereUniqueInput
  }


  /**
   * SubArea updateMany
   */
  export type SubAreaUpdateManyArgs = {
    data: XOR<SubAreaUpdateManyMutationInput, SubAreaUncheckedUpdateManyInput>
    where?: SubAreaWhereInput
  }


  /**
   * SubArea upsert
   */
  export type SubAreaUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * The filter to search for the SubArea to update in case it exists.
    **/
    where: SubAreaWhereUniqueInput
    /**
     * In case the SubArea found by the `where` argument doesn't exist, create a new SubArea with this data.
    **/
    create: XOR<SubAreaCreateInput, SubAreaUncheckedCreateInput>
    /**
     * In case the SubArea was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SubAreaUpdateInput, SubAreaUncheckedUpdateInput>
  }


  /**
   * SubArea delete
   */
  export type SubAreaDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
    /**
     * Filter which SubArea to delete.
    **/
    where: SubAreaWhereUniqueInput
  }


  /**
   * SubArea deleteMany
   */
  export type SubAreaDeleteManyArgs = {
    where?: SubAreaWhereInput
  }


  /**
   * SubArea without action
   */
  export type SubAreaArgs = {
    /**
     * Select specific fields to fetch from the SubArea
    **/
    select?: SubAreaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubAreaInclude | null
  }



  /**
   * Model TimeSlotDay
   */


  export type AggregateTimeSlotDay = {
    count: TimeSlotDayCountAggregateOutputType | null
    min: TimeSlotDayMinAggregateOutputType | null
    max: TimeSlotDayMaxAggregateOutputType | null
  }

  export type TimeSlotDayMinAggregateOutputType = {
    CourseOfferingID: string | null
    day: TimeSlotDay_day | null
  }

  export type TimeSlotDayMaxAggregateOutputType = {
    CourseOfferingID: string | null
    day: TimeSlotDay_day | null
  }

  export type TimeSlotDayCountAggregateOutputType = {
    CourseOfferingID: number | null
    day: number | null
    _all: number
  }


  export type TimeSlotDayMinAggregateInputType = {
    CourseOfferingID?: true
    day?: true
  }

  export type TimeSlotDayMaxAggregateInputType = {
    CourseOfferingID?: true
    day?: true
  }

  export type TimeSlotDayCountAggregateInputType = {
    CourseOfferingID?: true
    day?: true
    _all?: true
  }

  export type TimeSlotDayAggregateArgs = {
    /**
     * Filter which TimeSlotDay to aggregate.
    **/
    where?: TimeSlotDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotDays to fetch.
    **/
    orderBy?: Enumerable<TimeSlotDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TimeSlotDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotDays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotDays.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlotDays
    **/
    count?: true | TimeSlotDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TimeSlotDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TimeSlotDayMaxAggregateInputType
  }

  export type GetTimeSlotDayAggregateType<T extends TimeSlotDayAggregateArgs> = {
    [P in keyof T & keyof AggregateTimeSlotDay]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlotDay[P]>
      : GetScalarType<T[P], AggregateTimeSlotDay[P]>
  }



  export type TimeSlotDaySelect = {
    CourseOfferingID?: boolean
    day?: boolean
    CourseOffering?: boolean | CourseOfferingArgs
  }

  export type TimeSlotDayInclude = {
    CourseOffering?: boolean | CourseOfferingArgs
  }

  export type TimeSlotDayGetPayload<
    S extends boolean | null | undefined | TimeSlotDayArgs,
    U = keyof S
      > = S extends true
        ? TimeSlotDay
    : S extends undefined
    ? never
    : S extends TimeSlotDayArgs | TimeSlotDayFindManyArgs
    ?'include' extends U
    ? TimeSlotDay  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CourseOffering'
        ? CourseOfferingGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TimeSlotDay ?TimeSlotDay [P]
  : 
          P extends 'CourseOffering'
        ? CourseOfferingGetPayload<S['select'][P]> : never
  } 
    : TimeSlotDay
  : TimeSlotDay


  type TimeSlotDayCountArgs = Merge<
    Omit<TimeSlotDayFindManyArgs, 'select' | 'include'> & {
      select?: TimeSlotDayCountAggregateInputType | true
    }
  >

  export interface TimeSlotDayDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TimeSlotDay that matches the filter.
     * @param {TimeSlotDayFindUniqueArgs} args - Arguments to find a TimeSlotDay
     * @example
     * // Get one TimeSlotDay
     * const timeSlotDay = await prisma.timeSlotDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TimeSlotDayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TimeSlotDayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TimeSlotDay'> extends True ? CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>> : CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay | null >, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T> | null >>

    /**
     * Find the first TimeSlotDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotDayFindFirstArgs} args - Arguments to find a TimeSlotDay
     * @example
     * // Get one TimeSlotDay
     * const timeSlotDay = await prisma.timeSlotDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TimeSlotDayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TimeSlotDayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TimeSlotDay'> extends True ? CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>> : CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay | null >, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T> | null >>

    /**
     * Find zero or more TimeSlotDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotDayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlotDays
     * const timeSlotDays = await prisma.timeSlotDay.findMany()
     * 
     * // Get first 10 TimeSlotDays
     * const timeSlotDays = await prisma.timeSlotDay.findMany({ take: 10 })
     * 
     * // Only select the `CourseOfferingID`
     * const timeSlotDayWithCourseOfferingIDOnly = await prisma.timeSlotDay.findMany({ select: { CourseOfferingID: true } })
     * 
    **/
    findMany<T extends TimeSlotDayFindManyArgs>(
      args?: SelectSubset<T, TimeSlotDayFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TimeSlotDay>>, PrismaPromise<Array<TimeSlotDayGetPayload<T>>>>

    /**
     * Create a TimeSlotDay.
     * @param {TimeSlotDayCreateArgs} args - Arguments to create a TimeSlotDay.
     * @example
     * // Create one TimeSlotDay
     * const TimeSlotDay = await prisma.timeSlotDay.create({
     *   data: {
     *     // ... data to create a TimeSlotDay
     *   }
     * })
     * 
    **/
    create<T extends TimeSlotDayCreateArgs>(
      args: SelectSubset<T, TimeSlotDayCreateArgs>
    ): CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>>

    /**
     * Delete a TimeSlotDay.
     * @param {TimeSlotDayDeleteArgs} args - Arguments to delete one TimeSlotDay.
     * @example
     * // Delete one TimeSlotDay
     * const TimeSlotDay = await prisma.timeSlotDay.delete({
     *   where: {
     *     // ... filter to delete one TimeSlotDay
     *   }
     * })
     * 
    **/
    delete<T extends TimeSlotDayDeleteArgs>(
      args: SelectSubset<T, TimeSlotDayDeleteArgs>
    ): CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>>

    /**
     * Update one TimeSlotDay.
     * @param {TimeSlotDayUpdateArgs} args - Arguments to update one TimeSlotDay.
     * @example
     * // Update one TimeSlotDay
     * const timeSlotDay = await prisma.timeSlotDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TimeSlotDayUpdateArgs>(
      args: SelectSubset<T, TimeSlotDayUpdateArgs>
    ): CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>>

    /**
     * Delete zero or more TimeSlotDays.
     * @param {TimeSlotDayDeleteManyArgs} args - Arguments to filter TimeSlotDays to delete.
     * @example
     * // Delete a few TimeSlotDays
     * const { count } = await prisma.timeSlotDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TimeSlotDayDeleteManyArgs>(
      args?: SelectSubset<T, TimeSlotDayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlotDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlotDays
     * const timeSlotDay = await prisma.timeSlotDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TimeSlotDayUpdateManyArgs>(
      args: SelectSubset<T, TimeSlotDayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeSlotDay.
     * @param {TimeSlotDayUpsertArgs} args - Arguments to update or create a TimeSlotDay.
     * @example
     * // Update or create a TimeSlotDay
     * const timeSlotDay = await prisma.timeSlotDay.upsert({
     *   create: {
     *     // ... data to create a TimeSlotDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlotDay we want to update
     *   }
     * })
    **/
    upsert<T extends TimeSlotDayUpsertArgs>(
      args: SelectSubset<T, TimeSlotDayUpsertArgs>
    ): CheckSelect<T, Prisma__TimeSlotDayClient<TimeSlotDay>, Prisma__TimeSlotDayClient<TimeSlotDayGetPayload<T>>>

    /**
     * Count the number of TimeSlotDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotDayCountArgs} args - Arguments to filter TimeSlotDays to count.
     * @example
     * // Count the number of TimeSlotDays
     * const count = await prisma.timeSlotDay.count({
     *   where: {
     *     // ... the filter for the TimeSlotDays we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotDayCountArgs>(
      args?: Subset<T, TimeSlotDayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlotDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotDayAggregateArgs>(args: Subset<T, TimeSlotDayAggregateArgs>): PrismaPromise<GetTimeSlotDayAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlotDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TimeSlotDayClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CourseOffering<T extends CourseOfferingArgs = {}>(args?: Subset<T, CourseOfferingArgs>): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering | null >, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TimeSlotDay findUnique
   */
  export type TimeSlotDayFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * Throw an Error if a TimeSlotDay can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TimeSlotDay to fetch.
    **/
    where: TimeSlotDayWhereUniqueInput
  }


  /**
   * TimeSlotDay findFirst
   */
  export type TimeSlotDayFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * Throw an Error if a TimeSlotDay can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TimeSlotDay to fetch.
    **/
    where?: TimeSlotDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotDays to fetch.
    **/
    orderBy?: Enumerable<TimeSlotDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlotDays.
    **/
    cursor?: TimeSlotDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotDays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotDays.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlotDays.
    **/
    distinct?: Enumerable<TimeSlotDayScalarFieldEnum>
  }


  /**
   * TimeSlotDay findMany
   */
  export type TimeSlotDayFindManyArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * Filter, which TimeSlotDays to fetch.
    **/
    where?: TimeSlotDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotDays to fetch.
    **/
    orderBy?: Enumerable<TimeSlotDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlotDays.
    **/
    cursor?: TimeSlotDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotDays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotDays.
    **/
    skip?: number
    distinct?: Enumerable<TimeSlotDayScalarFieldEnum>
  }


  /**
   * TimeSlotDay create
   */
  export type TimeSlotDayCreateArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * The data needed to create a TimeSlotDay.
    **/
    data: XOR<TimeSlotDayCreateInput, TimeSlotDayUncheckedCreateInput>
  }


  /**
   * TimeSlotDay update
   */
  export type TimeSlotDayUpdateArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * The data needed to update a TimeSlotDay.
    **/
    data: XOR<TimeSlotDayUpdateInput, TimeSlotDayUncheckedUpdateInput>
    /**
     * Choose, which TimeSlotDay to update.
    **/
    where: TimeSlotDayWhereUniqueInput
  }


  /**
   * TimeSlotDay updateMany
   */
  export type TimeSlotDayUpdateManyArgs = {
    data: XOR<TimeSlotDayUpdateManyMutationInput, TimeSlotDayUncheckedUpdateManyInput>
    where?: TimeSlotDayWhereInput
  }


  /**
   * TimeSlotDay upsert
   */
  export type TimeSlotDayUpsertArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * The filter to search for the TimeSlotDay to update in case it exists.
    **/
    where: TimeSlotDayWhereUniqueInput
    /**
     * In case the TimeSlotDay found by the `where` argument doesn't exist, create a new TimeSlotDay with this data.
    **/
    create: XOR<TimeSlotDayCreateInput, TimeSlotDayUncheckedCreateInput>
    /**
     * In case the TimeSlotDay was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TimeSlotDayUpdateInput, TimeSlotDayUncheckedUpdateInput>
  }


  /**
   * TimeSlotDay delete
   */
  export type TimeSlotDayDeleteArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
    /**
     * Filter which TimeSlotDay to delete.
    **/
    where: TimeSlotDayWhereUniqueInput
  }


  /**
   * TimeSlotDay deleteMany
   */
  export type TimeSlotDayDeleteManyArgs = {
    where?: TimeSlotDayWhereInput
  }


  /**
   * TimeSlotDay without action
   */
  export type TimeSlotDayArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotDay
    **/
    select?: TimeSlotDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotDayInclude | null
  }



  /**
   * Model TimeSlotTime
   */


  export type AggregateTimeSlotTime = {
    count: TimeSlotTimeCountAggregateOutputType | null
    min: TimeSlotTimeMinAggregateOutputType | null
    max: TimeSlotTimeMaxAggregateOutputType | null
  }

  export type TimeSlotTimeMinAggregateOutputType = {
    courseOfferingID: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type TimeSlotTimeMaxAggregateOutputType = {
    courseOfferingID: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type TimeSlotTimeCountAggregateOutputType = {
    courseOfferingID: number | null
    startTime: number | null
    endTime: number | null
    _all: number
  }


  export type TimeSlotTimeMinAggregateInputType = {
    courseOfferingID?: true
    startTime?: true
    endTime?: true
  }

  export type TimeSlotTimeMaxAggregateInputType = {
    courseOfferingID?: true
    startTime?: true
    endTime?: true
  }

  export type TimeSlotTimeCountAggregateInputType = {
    courseOfferingID?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type TimeSlotTimeAggregateArgs = {
    /**
     * Filter which TimeSlotTime to aggregate.
    **/
    where?: TimeSlotTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotTimes to fetch.
    **/
    orderBy?: Enumerable<TimeSlotTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TimeSlotTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotTimes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlotTimes
    **/
    count?: true | TimeSlotTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TimeSlotTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TimeSlotTimeMaxAggregateInputType
  }

  export type GetTimeSlotTimeAggregateType<T extends TimeSlotTimeAggregateArgs> = {
    [P in keyof T & keyof AggregateTimeSlotTime]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlotTime[P]>
      : GetScalarType<T[P], AggregateTimeSlotTime[P]>
  }



  export type TimeSlotTimeSelect = {
    courseOfferingID?: boolean
    startTime?: boolean
    endTime?: boolean
    CourseOffering?: boolean | CourseOfferingArgs
  }

  export type TimeSlotTimeInclude = {
    CourseOffering?: boolean | CourseOfferingArgs
  }

  export type TimeSlotTimeGetPayload<
    S extends boolean | null | undefined | TimeSlotTimeArgs,
    U = keyof S
      > = S extends true
        ? TimeSlotTime
    : S extends undefined
    ? never
    : S extends TimeSlotTimeArgs | TimeSlotTimeFindManyArgs
    ?'include' extends U
    ? TimeSlotTime  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CourseOffering'
        ? CourseOfferingGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TimeSlotTime ?TimeSlotTime [P]
  : 
          P extends 'CourseOffering'
        ? CourseOfferingGetPayload<S['select'][P]> : never
  } 
    : TimeSlotTime
  : TimeSlotTime


  type TimeSlotTimeCountArgs = Merge<
    Omit<TimeSlotTimeFindManyArgs, 'select' | 'include'> & {
      select?: TimeSlotTimeCountAggregateInputType | true
    }
  >

  export interface TimeSlotTimeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TimeSlotTime that matches the filter.
     * @param {TimeSlotTimeFindUniqueArgs} args - Arguments to find a TimeSlotTime
     * @example
     * // Get one TimeSlotTime
     * const timeSlotTime = await prisma.timeSlotTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TimeSlotTimeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TimeSlotTimeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TimeSlotTime'> extends True ? CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>> : CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime | null >, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T> | null >>

    /**
     * Find the first TimeSlotTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotTimeFindFirstArgs} args - Arguments to find a TimeSlotTime
     * @example
     * // Get one TimeSlotTime
     * const timeSlotTime = await prisma.timeSlotTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TimeSlotTimeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TimeSlotTimeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TimeSlotTime'> extends True ? CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>> : CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime | null >, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T> | null >>

    /**
     * Find zero or more TimeSlotTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotTimeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlotTimes
     * const timeSlotTimes = await prisma.timeSlotTime.findMany()
     * 
     * // Get first 10 TimeSlotTimes
     * const timeSlotTimes = await prisma.timeSlotTime.findMany({ take: 10 })
     * 
     * // Only select the `courseOfferingID`
     * const timeSlotTimeWithCourseOfferingIDOnly = await prisma.timeSlotTime.findMany({ select: { courseOfferingID: true } })
     * 
    **/
    findMany<T extends TimeSlotTimeFindManyArgs>(
      args?: SelectSubset<T, TimeSlotTimeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TimeSlotTime>>, PrismaPromise<Array<TimeSlotTimeGetPayload<T>>>>

    /**
     * Create a TimeSlotTime.
     * @param {TimeSlotTimeCreateArgs} args - Arguments to create a TimeSlotTime.
     * @example
     * // Create one TimeSlotTime
     * const TimeSlotTime = await prisma.timeSlotTime.create({
     *   data: {
     *     // ... data to create a TimeSlotTime
     *   }
     * })
     * 
    **/
    create<T extends TimeSlotTimeCreateArgs>(
      args: SelectSubset<T, TimeSlotTimeCreateArgs>
    ): CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>>

    /**
     * Delete a TimeSlotTime.
     * @param {TimeSlotTimeDeleteArgs} args - Arguments to delete one TimeSlotTime.
     * @example
     * // Delete one TimeSlotTime
     * const TimeSlotTime = await prisma.timeSlotTime.delete({
     *   where: {
     *     // ... filter to delete one TimeSlotTime
     *   }
     * })
     * 
    **/
    delete<T extends TimeSlotTimeDeleteArgs>(
      args: SelectSubset<T, TimeSlotTimeDeleteArgs>
    ): CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>>

    /**
     * Update one TimeSlotTime.
     * @param {TimeSlotTimeUpdateArgs} args - Arguments to update one TimeSlotTime.
     * @example
     * // Update one TimeSlotTime
     * const timeSlotTime = await prisma.timeSlotTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TimeSlotTimeUpdateArgs>(
      args: SelectSubset<T, TimeSlotTimeUpdateArgs>
    ): CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>>

    /**
     * Delete zero or more TimeSlotTimes.
     * @param {TimeSlotTimeDeleteManyArgs} args - Arguments to filter TimeSlotTimes to delete.
     * @example
     * // Delete a few TimeSlotTimes
     * const { count } = await prisma.timeSlotTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TimeSlotTimeDeleteManyArgs>(
      args?: SelectSubset<T, TimeSlotTimeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlotTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlotTimes
     * const timeSlotTime = await prisma.timeSlotTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TimeSlotTimeUpdateManyArgs>(
      args: SelectSubset<T, TimeSlotTimeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeSlotTime.
     * @param {TimeSlotTimeUpsertArgs} args - Arguments to update or create a TimeSlotTime.
     * @example
     * // Update or create a TimeSlotTime
     * const timeSlotTime = await prisma.timeSlotTime.upsert({
     *   create: {
     *     // ... data to create a TimeSlotTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlotTime we want to update
     *   }
     * })
    **/
    upsert<T extends TimeSlotTimeUpsertArgs>(
      args: SelectSubset<T, TimeSlotTimeUpsertArgs>
    ): CheckSelect<T, Prisma__TimeSlotTimeClient<TimeSlotTime>, Prisma__TimeSlotTimeClient<TimeSlotTimeGetPayload<T>>>

    /**
     * Count the number of TimeSlotTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotTimeCountArgs} args - Arguments to filter TimeSlotTimes to count.
     * @example
     * // Count the number of TimeSlotTimes
     * const count = await prisma.timeSlotTime.count({
     *   where: {
     *     // ... the filter for the TimeSlotTimes we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotTimeCountArgs>(
      args?: Subset<T, TimeSlotTimeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlotTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotTimeAggregateArgs>(args: Subset<T, TimeSlotTimeAggregateArgs>): PrismaPromise<GetTimeSlotTimeAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlotTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TimeSlotTimeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CourseOffering<T extends CourseOfferingArgs = {}>(args?: Subset<T, CourseOfferingArgs>): CheckSelect<T, Prisma__CourseOfferingClient<CourseOffering | null >, Prisma__CourseOfferingClient<CourseOfferingGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TimeSlotTime findUnique
   */
  export type TimeSlotTimeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * Throw an Error if a TimeSlotTime can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TimeSlotTime to fetch.
    **/
    where: TimeSlotTimeWhereUniqueInput
  }


  /**
   * TimeSlotTime findFirst
   */
  export type TimeSlotTimeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * Throw an Error if a TimeSlotTime can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TimeSlotTime to fetch.
    **/
    where?: TimeSlotTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotTimes to fetch.
    **/
    orderBy?: Enumerable<TimeSlotTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlotTimes.
    **/
    cursor?: TimeSlotTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotTimes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlotTimes.
    **/
    distinct?: Enumerable<TimeSlotTimeScalarFieldEnum>
  }


  /**
   * TimeSlotTime findMany
   */
  export type TimeSlotTimeFindManyArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * Filter, which TimeSlotTimes to fetch.
    **/
    where?: TimeSlotTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlotTimes to fetch.
    **/
    orderBy?: Enumerable<TimeSlotTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlotTimes.
    **/
    cursor?: TimeSlotTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlotTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlotTimes.
    **/
    skip?: number
    distinct?: Enumerable<TimeSlotTimeScalarFieldEnum>
  }


  /**
   * TimeSlotTime create
   */
  export type TimeSlotTimeCreateArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * The data needed to create a TimeSlotTime.
    **/
    data: XOR<TimeSlotTimeCreateInput, TimeSlotTimeUncheckedCreateInput>
  }


  /**
   * TimeSlotTime update
   */
  export type TimeSlotTimeUpdateArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * The data needed to update a TimeSlotTime.
    **/
    data: XOR<TimeSlotTimeUpdateInput, TimeSlotTimeUncheckedUpdateInput>
    /**
     * Choose, which TimeSlotTime to update.
    **/
    where: TimeSlotTimeWhereUniqueInput
  }


  /**
   * TimeSlotTime updateMany
   */
  export type TimeSlotTimeUpdateManyArgs = {
    data: XOR<TimeSlotTimeUpdateManyMutationInput, TimeSlotTimeUncheckedUpdateManyInput>
    where?: TimeSlotTimeWhereInput
  }


  /**
   * TimeSlotTime upsert
   */
  export type TimeSlotTimeUpsertArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * The filter to search for the TimeSlotTime to update in case it exists.
    **/
    where: TimeSlotTimeWhereUniqueInput
    /**
     * In case the TimeSlotTime found by the `where` argument doesn't exist, create a new TimeSlotTime with this data.
    **/
    create: XOR<TimeSlotTimeCreateInput, TimeSlotTimeUncheckedCreateInput>
    /**
     * In case the TimeSlotTime was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TimeSlotTimeUpdateInput, TimeSlotTimeUncheckedUpdateInput>
  }


  /**
   * TimeSlotTime delete
   */
  export type TimeSlotTimeDeleteArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
    /**
     * Filter which TimeSlotTime to delete.
    **/
    where: TimeSlotTimeWhereUniqueInput
  }


  /**
   * TimeSlotTime deleteMany
   */
  export type TimeSlotTimeDeleteManyArgs = {
    where?: TimeSlotTimeWhereInput
  }


  /**
   * TimeSlotTime without action
   */
  export type TimeSlotTimeArgs = {
    /**
     * Select specific fields to fetch from the TimeSlotTime
    **/
    select?: TimeSlotTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TimeSlotTimeInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userID: number
  }

  export type UserSumAggregateOutputType = {
    userID: number
  }

  export type UserMinAggregateOutputType = {
    userID: number
    username: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    userID: number
    username: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    userID: number
    username: number | null
    password: number | null
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userID?: true
  }

  export type UserSumAggregateInputType = {
    userID?: true
  }

  export type UserMinAggregateInputType = {
    userID?: true
    username?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    userID?: true
    username?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    userID?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type UserSelect = {
    userID?: boolean
    username?: boolean
    password?: boolean
    GPD?: boolean | GPDArgs
  }

  export type UserInclude = {
    GPD?: boolean | GPDArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'GPD'
        ? GPDGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'GPD'
        ? GPDGetPayload<S['select'][P]> | null : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    GPD<T extends GPDArgs = {}>(args?: Subset<T, GPDArgs>): CheckSelect<T, Prisma__GPDClient<GPD | null >, Prisma__GPDClient<GPDGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AreaScalarFieldEnum: {
    areaID: 'areaID',
    requirementID: 'requirementID',
    name: 'name'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const AreaRequirementScalarFieldEnum: {
    areaID: 'areaID',
    nSubAreas: 'nSubAreas',
    nCourses: 'nCourses',
    nCredits: 'nCredits'
  };

  export type AreaRequirementScalarFieldEnum = (typeof AreaRequirementScalarFieldEnum)[keyof typeof AreaRequirementScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    studentID: 'studentID',
    GPDID: 'GPDID',
    comment: 'comment',
    date: 'date'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    courseID: 'courseID',
    departID: 'departID',
    name: 'name',
    description: 'description',
    credits: 'credits',
    courseNum: 'courseNum'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseOfferingScalarFieldEnum: {
    courseOfferingID: 'courseOfferingID',
    courseID: 'courseID',
    semester: 'semester',
    year: 'year',
    section: 'section'
  };

  export type CourseOfferingScalarFieldEnum = (typeof CourseOfferingScalarFieldEnum)[keyof typeof CourseOfferingScalarFieldEnum]


  export const CoursePlanScalarFieldEnum: {
    studentID: 'studentID',
    valid: 'valid',
    complete: 'complete'
  };

  export type CoursePlanScalarFieldEnum = (typeof CoursePlanScalarFieldEnum)[keyof typeof CoursePlanScalarFieldEnum]


  export const DegreeRequirementScalarFieldEnum: {
    requirementID: 'requirementID',
    departID: 'departID',
    track: 'track',
    versionSemester: 'versionSemester',
    versionYear: 'versionYear',
    totalCredit: 'totalCredit',
    project: 'project',
    thesis: 'thesis',
    timeLimit: 'timeLimit',
    finalRecommended: 'finalRecommended',
    minGPA: 'minGPA'
  };

  export type DegreeRequirementScalarFieldEnum = (typeof DegreeRequirementScalarFieldEnum)[keyof typeof DegreeRequirementScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    departmentID: 'departmentID',
    departmentName: 'departmentName'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ElectiveStatusScalarFieldEnum: {
    studentID: 'studentID',
    areaID: 'areaID',
    status: 'status'
  };

  export type ElectiveStatusScalarFieldEnum = (typeof ElectiveStatusScalarFieldEnum)[keyof typeof ElectiveStatusScalarFieldEnum]


  export const GPDScalarFieldEnum: {
    GPDID: 'GPDID',
    departmentID: 'departmentID'
  };

  export type GPDScalarFieldEnum = (typeof GPDScalarFieldEnum)[keyof typeof GPDScalarFieldEnum]


  export const GradesScalarFieldEnum: {
    studentID: 'studentID',
    courseOfferingID: 'courseOfferingID',
    grade: 'grade'
  };

  export type GradesScalarFieldEnum = (typeof GradesScalarFieldEnum)[keyof typeof GradesScalarFieldEnum]


  export const PrerequisiteScalarFieldEnum: {
    courseID: 'courseID',
    prerequisiteID: 'prerequisiteID'
  };

  export type PrerequisiteScalarFieldEnum = (typeof PrerequisiteScalarFieldEnum)[keyof typeof PrerequisiteScalarFieldEnum]


  export const ProficiencyRequirementScalarFieldEnum: {
    requirementID: 'requirementID',
    courseID: 'courseID'
  };

  export type ProficiencyRequirementScalarFieldEnum = (typeof ProficiencyRequirementScalarFieldEnum)[keyof typeof ProficiencyRequirementScalarFieldEnum]


  export const RequiredCourseScalarFieldEnum: {
    requirementID: 'requirementID',
    courseID: 'courseID'
  };

  export type RequiredCourseScalarFieldEnum = (typeof RequiredCourseScalarFieldEnum)[keyof typeof RequiredCourseScalarFieldEnum]


  export const RequiredStatusScalarFieldEnum: {
    studentID: 'studentID',
    courseID: 'courseID',
    status: 'status'
  };

  export type RequiredStatusScalarFieldEnum = (typeof RequiredStatusScalarFieldEnum)[keyof typeof RequiredStatusScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    studentID: 'studentID',
    firstName: 'firstName',
    lastName: 'lastName',
    requirementID: 'requirementID',
    entrySemester: 'entrySemester',
    entryYear: 'entryYear',
    gradSemester: 'gradSemester',
    gradYear: 'gradYear',
    nSemestersInProgram: 'nSemestersInProgram',
    gpa: 'gpa',
    totalCredits: 'totalCredits',
    projectOption: 'projectOption',
    advisor: 'advisor',
    hasGraduated: 'hasGraduated'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const SubAreaScalarFieldEnum: {
    areaID: 'areaID',
    minCourses: 'minCourses',
    minCredit: 'minCredit',
    maxCredit: 'maxCredit',
    maxCourse: 'maxCourse',
    name: 'name'
  };

  export type SubAreaScalarFieldEnum = (typeof SubAreaScalarFieldEnum)[keyof typeof SubAreaScalarFieldEnum]


  export const TimeSlotDayScalarFieldEnum: {
    CourseOfferingID: 'CourseOfferingID',
    day: 'day'
  };

  export type TimeSlotDayScalarFieldEnum = (typeof TimeSlotDayScalarFieldEnum)[keyof typeof TimeSlotDayScalarFieldEnum]


  export const TimeSlotTimeScalarFieldEnum: {
    courseOfferingID: 'courseOfferingID',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type TimeSlotTimeScalarFieldEnum = (typeof TimeSlotTimeScalarFieldEnum)[keyof typeof TimeSlotTimeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    userID: 'userID',
    username: 'username',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AreaWhereInput = {
    AND?: Enumerable<AreaWhereInput>
    OR?: Enumerable<AreaWhereInput>
    NOT?: Enumerable<AreaWhereInput>
    areaID?: IntFilter | number
    requirementID?: IntFilter | number
    name?: StringNullableFilter | string | null
    DegreeRequirement?: XOR<DegreeRequirementRelationFilter, DegreeRequirementWhereInput>
    AreaRequirement?: XOR<AreaRequirementRelationFilter, AreaRequirementWhereInput> | null
    ElectiveStatus?: ElectiveStatusListRelationFilter
    SubArea?: XOR<SubAreaRelationFilter, SubAreaWhereInput> | null
  }

  export type AreaOrderByInput = {
    areaID?: SortOrder
    requirementID?: SortOrder
    name?: SortOrder
  }

  export type AreaWhereUniqueInput = {
    areaID_requirementID?: AreaAreaIDRequirementIDCompoundUniqueInput
  }

  export type AreaRequirementWhereInput = {
    AND?: Enumerable<AreaRequirementWhereInput>
    OR?: Enumerable<AreaRequirementWhereInput>
    NOT?: Enumerable<AreaRequirementWhereInput>
    areaID?: IntFilter | number
    nSubAreas?: IntNullableFilter | number | null
    nCourses?: IntNullableFilter | number | null
    nCredits?: IntNullableFilter | number | null
    Area?: XOR<AreaRelationFilter, AreaWhereInput>
  }

  export type AreaRequirementOrderByInput = {
    areaID?: SortOrder
    nSubAreas?: SortOrder
    nCourses?: SortOrder
    nCredits?: SortOrder
  }

  export type AreaRequirementWhereUniqueInput = {
    areaID?: number
  }

  export type CommentsWhereInput = {
    AND?: Enumerable<CommentsWhereInput>
    OR?: Enumerable<CommentsWhereInput>
    NOT?: Enumerable<CommentsWhereInput>
    studentID?: IntFilter | number
    GPDID?: IntFilter | number
    comment?: StringFilter | string
    date?: DateTimeNullableFilter | Date | string | null
    GPD?: XOR<GPDRelationFilter, GPDWhereInput>
    Student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CommentsOrderByInput = {
    studentID?: SortOrder
    GPDID?: SortOrder
    comment?: SortOrder
    date?: SortOrder
  }

  export type CommentsWhereUniqueInput = {
    studentID_GPDID_comment?: CommentsStudentIDGPDIDCommentCompoundUniqueInput
  }

  export type CourseWhereInput = {
    AND?: Enumerable<CourseWhereInput>
    OR?: Enumerable<CourseWhereInput>
    NOT?: Enumerable<CourseWhereInput>
    courseID?: StringFilter | string
    departID?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    credits?: IntNullableFilter | number | null
    courseNum?: IntNullableFilter | number | null
    Department?: XOR<DepartmentRelationFilter, DepartmentWhereInput> | null
    CourseOffering?: CourseOfferingListRelationFilter
    prerequisite_CourseToprerequisite_courseID?: PrerequisiteListRelationFilter
    prerequisite_CourseToprerequisite_prerequisiteID?: PrerequisiteListRelationFilter
    proficiencyRequirement?: ProficiencyRequirementListRelationFilter
    requiredCourse?: RequiredCourseListRelationFilter
    RequiredStatus?: RequiredStatusListRelationFilter
  }

  export type CourseOrderByInput = {
    courseID?: SortOrder
    departID?: SortOrder
    name?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    courseNum?: SortOrder
  }

  export type CourseWhereUniqueInput = {
    courseID?: string
  }

  export type CourseOfferingWhereInput = {
    AND?: Enumerable<CourseOfferingWhereInput>
    OR?: Enumerable<CourseOfferingWhereInput>
    NOT?: Enumerable<CourseOfferingWhereInput>
    courseOfferingID?: StringFilter | string
    courseID?: StringNullableFilter | string | null
    semester?: EnumCourseOffering_semesterNullableFilter | CourseOffering_semester | null
    year?: IntNullableFilter | number | null
    section?: StringNullableFilter | string | null
    Course?: XOR<CourseRelationFilter, CourseWhereInput> | null
    TimeSlotDay?: TimeSlotDayListRelationFilter
    TimeSlotTime?: XOR<TimeSlotTimeRelationFilter, TimeSlotTimeWhereInput> | null
  }

  export type CourseOfferingOrderByInput = {
    courseOfferingID?: SortOrder
    courseID?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    section?: SortOrder
  }

  export type CourseOfferingWhereUniqueInput = {
    courseOfferingID?: string
  }

  export type CoursePlanWhereInput = {
    AND?: Enumerable<CoursePlanWhereInput>
    OR?: Enumerable<CoursePlanWhereInput>
    NOT?: Enumerable<CoursePlanWhereInput>
    studentID?: IntFilter | number
    valid?: BoolNullableFilter | boolean | null
    complete?: BoolNullableFilter | boolean | null
    Student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CoursePlanOrderByInput = {
    studentID?: SortOrder
    valid?: SortOrder
    complete?: SortOrder
  }

  export type CoursePlanWhereUniqueInput = {
    studentID?: number
  }

  export type DegreeRequirementWhereInput = {
    AND?: Enumerable<DegreeRequirementWhereInput>
    OR?: Enumerable<DegreeRequirementWhereInput>
    NOT?: Enumerable<DegreeRequirementWhereInput>
    requirementID?: IntFilter | number
    departID?: StringNullableFilter | string | null
    track?: StringNullableFilter | string | null
    versionSemester?: EnumDegreeRequirement_versionSemesterNullableFilter | DegreeRequirement_versionSemester | null
    versionYear?: IntNullableFilter | number | null
    totalCredit?: IntNullableFilter | number | null
    project?: StringNullableFilter | string | null
    thesis?: StringNullableFilter | string | null
    timeLimit?: IntNullableFilter | number | null
    finalRecommended?: IntNullableFilter | number | null
    minGPA?: IntNullableFilter | number | null
    Department?: XOR<DepartmentRelationFilter, DepartmentWhereInput> | null
    Area?: AreaListRelationFilter
    proficiencyRequirement?: ProficiencyRequirementListRelationFilter
    requiredCourse?: RequiredCourseListRelationFilter
  }

  export type DegreeRequirementOrderByInput = {
    requirementID?: SortOrder
    departID?: SortOrder
    track?: SortOrder
    versionSemester?: SortOrder
    versionYear?: SortOrder
    totalCredit?: SortOrder
    project?: SortOrder
    thesis?: SortOrder
    timeLimit?: SortOrder
    finalRecommended?: SortOrder
    minGPA?: SortOrder
  }

  export type DegreeRequirementWhereUniqueInput = {
    requirementID?: number
  }

  export type DepartmentWhereInput = {
    AND?: Enumerable<DepartmentWhereInput>
    OR?: Enumerable<DepartmentWhereInput>
    NOT?: Enumerable<DepartmentWhereInput>
    departmentID?: StringFilter | string
    departmentName?: StringNullableFilter | string | null
    Course?: CourseListRelationFilter
    DegreeRequirement?: DegreeRequirementListRelationFilter
    GPD?: XOR<GPDRelationFilter, GPDWhereInput> | null
  }

  export type DepartmentOrderByInput = {
    departmentID?: SortOrder
    departmentName?: SortOrder
  }

  export type DepartmentWhereUniqueInput = {
    departmentID?: string
  }

  export type ElectiveStatusWhereInput = {
    AND?: Enumerable<ElectiveStatusWhereInput>
    OR?: Enumerable<ElectiveStatusWhereInput>
    NOT?: Enumerable<ElectiveStatusWhereInput>
    studentID?: IntFilter | number
    areaID?: IntFilter | number
    status?: EnumElectiveStatus_statusNullableFilter | ElectiveStatus_status | null
    Area?: XOR<AreaRelationFilter, AreaWhereInput>
    Student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ElectiveStatusOrderByInput = {
    studentID?: SortOrder
    areaID?: SortOrder
    status?: SortOrder
  }

  export type ElectiveStatusWhereUniqueInput = {
    studentID_areaID?: ElectiveStatusStudentIDAreaIDCompoundUniqueInput
  }

  export type GPDWhereInput = {
    AND?: Enumerable<GPDWhereInput>
    OR?: Enumerable<GPDWhereInput>
    NOT?: Enumerable<GPDWhereInput>
    GPDID?: IntFilter | number
    departmentID?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    Comments?: CommentsListRelationFilter
  }

  export type GPDOrderByInput = {
    GPDID?: SortOrder
    departmentID?: SortOrder
  }

  export type GPDWhereUniqueInput = {
    GPDID?: number
    departmentID?: string
  }

  export type GradesWhereInput = {
    AND?: Enumerable<GradesWhereInput>
    OR?: Enumerable<GradesWhereInput>
    NOT?: Enumerable<GradesWhereInput>
    studentID?: IntFilter | number
    courseOfferingID?: StringFilter | string
    grade?: StringNullableFilter | string | null
    Student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type GradesOrderByInput = {
    studentID?: SortOrder
    courseOfferingID?: SortOrder
    grade?: SortOrder
  }

  export type GradesWhereUniqueInput = {
    studentID_courseOfferingID?: GradesStudentIDCourseOfferingIDCompoundUniqueInput
  }

  export type prerequisiteWhereInput = {
    AND?: Enumerable<prerequisiteWhereInput>
    OR?: Enumerable<prerequisiteWhereInput>
    NOT?: Enumerable<prerequisiteWhereInput>
    courseID?: StringFilter | string
    prerequisiteID?: StringFilter | string
    Course_CourseToprerequisite_courseID?: XOR<CourseRelationFilter, CourseWhereInput>
    Course_CourseToprerequisite_prerequisiteID?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type prerequisiteOrderByInput = {
    courseID?: SortOrder
    prerequisiteID?: SortOrder
  }

  export type prerequisiteWhereUniqueInput = {
    courseID_prerequisiteID?: prerequisiteCourseIDPrerequisiteIDCompoundUniqueInput
  }

  export type proficiencyRequirementWhereInput = {
    AND?: Enumerable<proficiencyRequirementWhereInput>
    OR?: Enumerable<proficiencyRequirementWhereInput>
    NOT?: Enumerable<proficiencyRequirementWhereInput>
    requirementID?: IntFilter | number
    courseID?: StringFilter | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    DegreeRequirement?: XOR<DegreeRequirementRelationFilter, DegreeRequirementWhereInput>
  }

  export type proficiencyRequirementOrderByInput = {
    requirementID?: SortOrder
    courseID?: SortOrder
  }

  export type proficiencyRequirementWhereUniqueInput = {
    requirementID_courseID?: proficiencyRequirementRequirementIDCourseIDCompoundUniqueInput
  }

  export type requiredCourseWhereInput = {
    AND?: Enumerable<requiredCourseWhereInput>
    OR?: Enumerable<requiredCourseWhereInput>
    NOT?: Enumerable<requiredCourseWhereInput>
    requirementID?: IntFilter | number
    courseID?: StringFilter | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    DegreeRequirement?: XOR<DegreeRequirementRelationFilter, DegreeRequirementWhereInput>
  }

  export type requiredCourseOrderByInput = {
    requirementID?: SortOrder
    courseID?: SortOrder
  }

  export type requiredCourseWhereUniqueInput = {
    requirementID_courseID?: requiredCourseRequirementIDCourseIDCompoundUniqueInput
  }

  export type RequiredStatusWhereInput = {
    AND?: Enumerable<RequiredStatusWhereInput>
    OR?: Enumerable<RequiredStatusWhereInput>
    NOT?: Enumerable<RequiredStatusWhereInput>
    studentID?: IntFilter | number
    courseID?: StringFilter | string
    status?: EnumRequiredStatus_statusNullableFilter | RequiredStatus_status | null
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type RequiredStatusOrderByInput = {
    studentID?: SortOrder
    courseID?: SortOrder
    status?: SortOrder
  }

  export type RequiredStatusWhereUniqueInput = {
    studentID_courseID?: RequiredStatusStudentIDCourseIDCompoundUniqueInput
  }

  export type StudentWhereInput = {
    AND?: Enumerable<StudentWhereInput>
    OR?: Enumerable<StudentWhereInput>
    NOT?: Enumerable<StudentWhereInput>
    studentID?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    requirementID?: IntNullableFilter | number | null
    entrySemester?: EnumStudent_entrySemesterFilter | Student_entrySemester
    entryYear?: IntFilter | number
    gradSemester?: EnumStudent_gradSemesterNullableFilter | Student_gradSemester | null
    gradYear?: IntNullableFilter | number | null
    nSemestersInProgram?: IntFilter | number
    gpa?: DecimalNullableFilter | Decimal | number | string | null
    totalCredits?: IntNullableFilter | number | null
    projectOption?: StringNullableFilter | string | null
    advisor?: StringNullableFilter | string | null
    hasGraduated?: BoolNullableFilter | boolean | null
    Comments?: CommentsListRelationFilter
    CoursePlan?: XOR<CoursePlanRelationFilter, CoursePlanWhereInput> | null
    ElectiveStatus?: ElectiveStatusListRelationFilter
    Grades?: GradesListRelationFilter
    RequiredStatus?: RequiredStatusListRelationFilter
  }

  export type StudentOrderByInput = {
    studentID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    requirementID?: SortOrder
    entrySemester?: SortOrder
    entryYear?: SortOrder
    gradSemester?: SortOrder
    gradYear?: SortOrder
    nSemestersInProgram?: SortOrder
    gpa?: SortOrder
    totalCredits?: SortOrder
    projectOption?: SortOrder
    advisor?: SortOrder
    hasGraduated?: SortOrder
  }

  export type StudentWhereUniqueInput = {
    studentID?: number
  }

  export type SubAreaWhereInput = {
    AND?: Enumerable<SubAreaWhereInput>
    OR?: Enumerable<SubAreaWhereInput>
    NOT?: Enumerable<SubAreaWhereInput>
    areaID?: IntFilter | number
    minCourses?: IntNullableFilter | number | null
    minCredit?: IntNullableFilter | number | null
    maxCredit?: IntNullableFilter | number | null
    maxCourse?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    Area?: XOR<AreaRelationFilter, AreaWhereInput>
  }

  export type SubAreaOrderByInput = {
    areaID?: SortOrder
    minCourses?: SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    maxCourse?: SortOrder
    name?: SortOrder
  }

  export type SubAreaWhereUniqueInput = {
    areaID?: number
  }

  export type TimeSlotDayWhereInput = {
    AND?: Enumerable<TimeSlotDayWhereInput>
    OR?: Enumerable<TimeSlotDayWhereInput>
    NOT?: Enumerable<TimeSlotDayWhereInput>
    CourseOfferingID?: StringFilter | string
    day?: EnumTimeSlotDay_dayFilter | TimeSlotDay_day
    CourseOffering?: XOR<CourseOfferingRelationFilter, CourseOfferingWhereInput>
  }

  export type TimeSlotDayOrderByInput = {
    CourseOfferingID?: SortOrder
    day?: SortOrder
  }

  export type TimeSlotDayWhereUniqueInput = {
    CourseOfferingID_day?: TimeSlotDayCourseOfferingIDDayCompoundUniqueInput
  }

  export type TimeSlotTimeWhereInput = {
    AND?: Enumerable<TimeSlotTimeWhereInput>
    OR?: Enumerable<TimeSlotTimeWhereInput>
    NOT?: Enumerable<TimeSlotTimeWhereInput>
    courseOfferingID?: StringFilter | string
    startTime?: DateTimeNullableFilter | Date | string | null
    endTime?: DateTimeNullableFilter | Date | string | null
    CourseOffering?: XOR<CourseOfferingRelationFilter, CourseOfferingWhereInput>
  }

  export type TimeSlotTimeOrderByInput = {
    courseOfferingID?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type TimeSlotTimeWhereUniqueInput = {
    courseOfferingID?: string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    userID?: IntFilter | number
    username?: StringFilter | string
    password?: StringFilter | string
    GPD?: XOR<GPDRelationFilter, GPDWhereInput> | null
  }

  export type UserOrderByInput = {
    userID?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserWhereUniqueInput = {
    userID?: number
  }

  export type AreaCreateInput = {
    areaID: number
    name?: string | null
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutAreaInput
    AreaRequirement?: AreaRequirementCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaCreateNestedOneWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    areaID: number
    requirementID: number
    name?: string | null
    AreaRequirement?: AreaRequirementUncheckedCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaUncheckedCreateNestedOneWithoutAreaInput
  }

  export type AreaUpdateInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutAreaInput
    AreaRequirement?: AreaRequirementUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutAreaInput
    SubArea?: SubAreaUpdateOneWithoutAreaInput
  }

  export type AreaUncheckedUpdateInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    requirementID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AreaRequirement?: AreaRequirementUncheckedUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutAreaInput
    SubArea?: SubAreaUncheckedUpdateOneWithoutAreaInput
  }

  export type AreaUpdateManyMutationInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaUncheckedUpdateManyInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    requirementID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaRequirementCreateInput = {
    nSubAreas?: number | null
    nCourses?: number | null
    nCredits?: number | null
    Area: AreaCreateNestedOneWithoutAreaRequirementInput
  }

  export type AreaRequirementUncheckedCreateInput = {
    areaID: number
    nSubAreas?: number | null
    nCourses?: number | null
    nCredits?: number | null
  }

  export type AreaRequirementUpdateInput = {
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUpdateOneRequiredWithoutAreaRequirementInput
  }

  export type AreaRequirementUncheckedUpdateInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaRequirementUpdateManyMutationInput = {
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaRequirementUncheckedUpdateManyInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentsCreateInput = {
    comment: string
    date?: Date | string | null
    GPD: GPDCreateNestedOneWithoutCommentsInput
    Student: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateInput = {
    studentID: number
    GPDID: number
    comment: string
    date?: Date | string | null
  }

  export type CommentsUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GPD?: GPDUpdateOneRequiredWithoutCommentsInput
    Student?: StudentUpdateOneRequiredWithoutCommentsInput
  }

  export type CommentsUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    GPDID?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentsUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentsUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    GPDID?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type CourseUpdateManyMutationInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseUncheckedUpdateManyInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseOfferingCreateInput = {
    courseOfferingID: string
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    Course?: CourseCreateNestedOneWithoutCourseOfferingInput
    TimeSlotDay?: TimeSlotDayCreateNestedManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateInput = {
    courseOfferingID: string
    courseID?: string | null
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    TimeSlotDay?: TimeSlotDayUncheckedCreateNestedManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUncheckedCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUpdateInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateOneWithoutCourseOfferingInput
    TimeSlotDay?: TimeSlotDayUpdateManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedUpdateInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    courseID?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSlotDay?: TimeSlotDayUncheckedUpdateManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUncheckedUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUpdateManyMutationInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseOfferingUncheckedUpdateManyInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    courseID?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoursePlanCreateInput = {
    valid?: boolean | null
    complete?: boolean | null
    Student: StudentCreateNestedOneWithoutCoursePlanInput
  }

  export type CoursePlanUncheckedCreateInput = {
    studentID: number
    valid?: boolean | null
    complete?: boolean | null
  }

  export type CoursePlanUpdateInput = {
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Student?: StudentUpdateOneRequiredWithoutCoursePlanInput
  }

  export type CoursePlanUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CoursePlanUpdateManyMutationInput = {
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CoursePlanUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DegreeRequirementCreateInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Department?: DepartmentCreateNestedOneWithoutDegreeRequirementInput
    Area?: AreaCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedCreateInput = {
    requirementID: number
    departID?: string | null
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Area?: AreaUncheckedCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUpdateInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutDegreeRequirementInput
    Area?: AreaUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUncheckedUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUpdateManyMutationInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DegreeRequirementUncheckedUpdateManyInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DepartmentCreateInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseCreateNestedManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementCreateNestedManyWithoutDepartmentInput
    GPD?: GPDCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUncheckedCreateNestedManyWithoutDepartmentInput
    GPD?: GPDUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUpdateManyWithoutDepartmentInput
    GPD?: GPDUpdateOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedUpdateInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUncheckedUpdateManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUncheckedUpdateManyWithoutDepartmentInput
    GPD?: GPDUncheckedUpdateOneWithoutDepartmentInput
  }

  export type DepartmentUpdateManyMutationInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ElectiveStatusCreateInput = {
    status?: ElectiveStatus_status | null
    Area: AreaCreateNestedOneWithoutElectiveStatusInput
    Student: StudentCreateNestedOneWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedCreateInput = {
    studentID: number
    areaID: number
    status?: ElectiveStatus_status | null
  }

  export type ElectiveStatusUpdateInput = {
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
    Area?: AreaUpdateOneRequiredWithoutElectiveStatusInput
    Student?: StudentUpdateOneRequiredWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    areaID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type ElectiveStatusUpdateManyMutationInput = {
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type ElectiveStatusUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    areaID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type GPDCreateInput = {
    User: UserCreateNestedOneWithoutGPDInput
    Department: DepartmentCreateNestedOneWithoutGPDInput
    Comments?: CommentsCreateNestedManyWithoutGPDInput
  }

  export type GPDUncheckedCreateInput = {
    GPDID: number
    departmentID: string
    Comments?: CommentsUncheckedCreateNestedManyWithoutGPDInput
  }

  export type GPDUpdateInput = {
    User?: UserUpdateOneRequiredWithoutGPDInput
    Department?: DepartmentUpdateOneRequiredWithoutGPDInput
    Comments?: CommentsUpdateManyWithoutGPDInput
  }

  export type GPDUncheckedUpdateInput = {
    GPDID?: IntFieldUpdateOperationsInput | number
    departmentID?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUncheckedUpdateManyWithoutGPDInput
  }

  export type GPDUpdateManyMutationInput = {

  }

  export type GPDUncheckedUpdateManyInput = {
    GPDID?: IntFieldUpdateOperationsInput | number
    departmentID?: StringFieldUpdateOperationsInput | string
  }

  export type GradesCreateInput = {
    courseOfferingID: string
    grade?: string | null
    Student: StudentCreateNestedOneWithoutGradesInput
  }

  export type GradesUncheckedCreateInput = {
    studentID: number
    courseOfferingID: string
    grade?: string | null
  }

  export type GradesUpdateInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    Student?: StudentUpdateOneRequiredWithoutGradesInput
  }

  export type GradesUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradesUpdateManyMutationInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradesUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prerequisiteCreateInput = {
    Course_CourseToprerequisite_courseID: CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_courseIDInput
    Course_CourseToprerequisite_prerequisiteID: CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
  }

  export type prerequisiteUncheckedCreateInput = {
    courseID: string
    prerequisiteID: string
  }

  export type prerequisiteUpdateInput = {
    Course_CourseToprerequisite_courseID?: CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_courseIDInput
    Course_CourseToprerequisite_prerequisiteID?: CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
  }

  export type prerequisiteUncheckedUpdateInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    prerequisiteID?: StringFieldUpdateOperationsInput | string
  }

  export type prerequisiteUpdateManyMutationInput = {

  }

  export type prerequisiteUncheckedUpdateManyInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    prerequisiteID?: StringFieldUpdateOperationsInput | string
  }

  export type proficiencyRequirementCreateInput = {
    Course: CourseCreateNestedOneWithoutProficiencyRequirementInput
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedCreateInput = {
    requirementID: number
    courseID: string
  }

  export type proficiencyRequirementUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutProficiencyRequirementInput
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedUpdateInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type proficiencyRequirementUpdateManyMutationInput = {

  }

  export type proficiencyRequirementUncheckedUpdateManyInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type requiredCourseCreateInput = {
    Course: CourseCreateNestedOneWithoutRequiredCourseInput
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedCreateInput = {
    requirementID: number
    courseID: string
  }

  export type requiredCourseUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutRequiredCourseInput
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedUpdateInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type requiredCourseUpdateManyMutationInput = {

  }

  export type requiredCourseUncheckedUpdateManyInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type RequiredStatusCreateInput = {
    status?: RequiredStatus_status | null
    Course: CourseCreateNestedOneWithoutRequiredStatusInput
    Student: StudentCreateNestedOneWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedCreateInput = {
    studentID: number
    courseID: string
    status?: RequiredStatus_status | null
  }

  export type RequiredStatusUpdateInput = {
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
    Course?: CourseUpdateOneRequiredWithoutRequiredStatusInput
    Student?: StudentUpdateOneRequiredWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }

  export type RequiredStatusUpdateManyMutationInput = {
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }

  export type RequiredStatusUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    courseID?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }

  export type StudentCreateInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutStudentInput
    Grades?: GradesCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsUncheckedCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput
    Grades?: GradesUncheckedCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutStudentInput
    Grades?: GradesUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUncheckedUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutStudentInput
    Grades?: GradesUncheckedUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutStudentInput
  }

  export type StudentUpdateManyMutationInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentUncheckedUpdateManyInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubAreaCreateInput = {
    minCourses?: number | null
    minCredit?: number | null
    maxCredit?: number | null
    maxCourse?: number | null
    name?: string | null
    Area: AreaCreateNestedOneWithoutSubAreaInput
  }

  export type SubAreaUncheckedCreateInput = {
    areaID: number
    minCourses?: number | null
    minCredit?: number | null
    maxCredit?: number | null
    maxCourse?: number | null
    name?: string | null
  }

  export type SubAreaUpdateInput = {
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: AreaUpdateOneRequiredWithoutSubAreaInput
  }

  export type SubAreaUncheckedUpdateInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAreaUpdateManyMutationInput = {
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAreaUncheckedUpdateManyInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSlotDayCreateInput = {
    day: TimeSlotDay_day
    CourseOffering: CourseOfferingCreateNestedOneWithoutTimeSlotDayInput
  }

  export type TimeSlotDayUncheckedCreateInput = {
    CourseOfferingID: string
    day: TimeSlotDay_day
  }

  export type TimeSlotDayUpdateInput = {
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
    CourseOffering?: CourseOfferingUpdateOneRequiredWithoutTimeSlotDayInput
  }

  export type TimeSlotDayUncheckedUpdateInput = {
    CourseOfferingID?: StringFieldUpdateOperationsInput | string
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type TimeSlotDayUpdateManyMutationInput = {
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type TimeSlotDayUncheckedUpdateManyInput = {
    CourseOfferingID?: StringFieldUpdateOperationsInput | string
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type TimeSlotTimeCreateInput = {
    startTime?: Date | string | null
    endTime?: Date | string | null
    CourseOffering: CourseOfferingCreateNestedOneWithoutTimeSlotTimeInput
  }

  export type TimeSlotTimeUncheckedCreateInput = {
    courseOfferingID: string
    startTime?: Date | string | null
    endTime?: Date | string | null
  }

  export type TimeSlotTimeUpdateInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CourseOffering?: CourseOfferingUpdateOneRequiredWithoutTimeSlotTimeInput
  }

  export type TimeSlotTimeUncheckedUpdateInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeSlotTimeUpdateManyMutationInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeSlotTimeUncheckedUpdateManyInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    userID?: number
    username: string
    password: string
    GPD?: GPDCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userID?: number
    username: string
    password: string
    GPD?: GPDUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    GPD?: GPDUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    GPD?: GPDUncheckedUpdateOneWithoutUserInput
  }

  export type UserUpdateManyMutationInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DegreeRequirementRelationFilter = {
    is?: DegreeRequirementWhereInput
    isNot?: DegreeRequirementWhereInput
  }

  export type AreaRequirementRelationFilter = {
    is?: AreaRequirementWhereInput | null
    isNot?: AreaRequirementWhereInput | null
  }

  export type ElectiveStatusListRelationFilter = {
    every?: ElectiveStatusWhereInput
    some?: ElectiveStatusWhereInput
    none?: ElectiveStatusWhereInput
  }

  export type SubAreaRelationFilter = {
    is?: SubAreaWhereInput | null
    isNot?: SubAreaWhereInput | null
  }

  export type AreaAreaIDRequirementIDCompoundUniqueInput = {
    areaID: number
    requirementID: number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type AreaRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type GPDRelationFilter = {
    is?: GPDWhereInput | null
    isNot?: GPDWhereInput | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type CommentsStudentIDGPDIDCommentCompoundUniqueInput = {
    studentID: number
    GPDID: number
    comment: string
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type CourseOfferingListRelationFilter = {
    every?: CourseOfferingWhereInput
    some?: CourseOfferingWhereInput
    none?: CourseOfferingWhereInput
  }

  export type PrerequisiteListRelationFilter = {
    every?: prerequisiteWhereInput
    some?: prerequisiteWhereInput
    none?: prerequisiteWhereInput
  }

  export type ProficiencyRequirementListRelationFilter = {
    every?: proficiencyRequirementWhereInput
    some?: proficiencyRequirementWhereInput
    none?: proficiencyRequirementWhereInput
  }

  export type RequiredCourseListRelationFilter = {
    every?: requiredCourseWhereInput
    some?: requiredCourseWhereInput
    none?: requiredCourseWhereInput
  }

  export type RequiredStatusListRelationFilter = {
    every?: RequiredStatusWhereInput
    some?: RequiredStatusWhereInput
    none?: RequiredStatusWhereInput
  }

  export type EnumCourseOffering_semesterNullableFilter = {
    equals?: CourseOffering_semester | null
    in?: Enumerable<CourseOffering_semester> | null
    notIn?: Enumerable<CourseOffering_semester> | null
    not?: NestedEnumCourseOffering_semesterNullableFilter | CourseOffering_semester | null
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type TimeSlotDayListRelationFilter = {
    every?: TimeSlotDayWhereInput
    some?: TimeSlotDayWhereInput
    none?: TimeSlotDayWhereInput
  }

  export type TimeSlotTimeRelationFilter = {
    is?: TimeSlotTimeWhereInput | null
    isNot?: TimeSlotTimeWhereInput | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type EnumDegreeRequirement_versionSemesterNullableFilter = {
    equals?: DegreeRequirement_versionSemester | null
    in?: Enumerable<DegreeRequirement_versionSemester> | null
    notIn?: Enumerable<DegreeRequirement_versionSemester> | null
    not?: NestedEnumDegreeRequirement_versionSemesterNullableFilter | DegreeRequirement_versionSemester | null
  }

  export type AreaListRelationFilter = {
    every?: AreaWhereInput
    some?: AreaWhereInput
    none?: AreaWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type DegreeRequirementListRelationFilter = {
    every?: DegreeRequirementWhereInput
    some?: DegreeRequirementWhereInput
    none?: DegreeRequirementWhereInput
  }

  export type EnumElectiveStatus_statusNullableFilter = {
    equals?: ElectiveStatus_status | null
    in?: Enumerable<ElectiveStatus_status> | null
    notIn?: Enumerable<ElectiveStatus_status> | null
    not?: NestedEnumElectiveStatus_statusNullableFilter | ElectiveStatus_status | null
  }

  export type ElectiveStatusStudentIDAreaIDCompoundUniqueInput = {
    studentID: number
    areaID: number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type GradesStudentIDCourseOfferingIDCompoundUniqueInput = {
    studentID: number
    courseOfferingID: string
  }

  export type prerequisiteCourseIDPrerequisiteIDCompoundUniqueInput = {
    courseID: string
    prerequisiteID: string
  }

  export type proficiencyRequirementRequirementIDCourseIDCompoundUniqueInput = {
    requirementID: number
    courseID: string
  }

  export type requiredCourseRequirementIDCourseIDCompoundUniqueInput = {
    requirementID: number
    courseID: string
  }

  export type EnumRequiredStatus_statusNullableFilter = {
    equals?: RequiredStatus_status | null
    in?: Enumerable<RequiredStatus_status> | null
    notIn?: Enumerable<RequiredStatus_status> | null
    not?: NestedEnumRequiredStatus_statusNullableFilter | RequiredStatus_status | null
  }

  export type RequiredStatusStudentIDCourseIDCompoundUniqueInput = {
    studentID: number
    courseID: string
  }

  export type EnumStudent_entrySemesterFilter = {
    equals?: Student_entrySemester
    in?: Enumerable<Student_entrySemester>
    notIn?: Enumerable<Student_entrySemester>
    not?: NestedEnumStudent_entrySemesterFilter | Student_entrySemester
  }

  export type EnumStudent_gradSemesterNullableFilter = {
    equals?: Student_gradSemester | null
    in?: Enumerable<Student_gradSemester> | null
    notIn?: Enumerable<Student_gradSemester> | null
    not?: NestedEnumStudent_gradSemesterNullableFilter | Student_gradSemester | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type CoursePlanRelationFilter = {
    is?: CoursePlanWhereInput | null
    isNot?: CoursePlanWhereInput | null
  }

  export type GradesListRelationFilter = {
    every?: GradesWhereInput
    some?: GradesWhereInput
    none?: GradesWhereInput
  }

  export type EnumTimeSlotDay_dayFilter = {
    equals?: TimeSlotDay_day
    in?: Enumerable<TimeSlotDay_day>
    notIn?: Enumerable<TimeSlotDay_day>
    not?: NestedEnumTimeSlotDay_dayFilter | TimeSlotDay_day
  }

  export type CourseOfferingRelationFilter = {
    is?: CourseOfferingWhereInput
    isNot?: CourseOfferingWhereInput
  }

  export type TimeSlotDayCourseOfferingIDDayCompoundUniqueInput = {
    CourseOfferingID: string
    day: TimeSlotDay_day
  }

  export type DegreeRequirementCreateNestedOneWithoutAreaInput = {
    create?: XOR<DegreeRequirementCreateWithoutAreaInput, DegreeRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutAreaInput
    connect?: DegreeRequirementWhereUniqueInput
  }

  export type AreaRequirementCreateNestedOneWithoutAreaInput = {
    create?: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AreaRequirementCreateOrConnectWithoutAreaInput
    connect?: AreaRequirementWhereUniqueInput
  }

  export type ElectiveStatusCreateNestedManyWithoutAreaInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutAreaInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutAreaInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutAreaInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
  }

  export type SubAreaCreateNestedOneWithoutAreaInput = {
    create?: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
    connectOrCreate?: SubAreaCreateOrConnectWithoutAreaInput
    connect?: SubAreaWhereUniqueInput
  }

  export type AreaRequirementUncheckedCreateNestedOneWithoutAreaInput = {
    create?: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AreaRequirementCreateOrConnectWithoutAreaInput
    connect?: AreaRequirementWhereUniqueInput
  }

  export type ElectiveStatusUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutAreaInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutAreaInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutAreaInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
  }

  export type SubAreaUncheckedCreateNestedOneWithoutAreaInput = {
    create?: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
    connectOrCreate?: SubAreaCreateOrConnectWithoutAreaInput
    connect?: SubAreaWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DegreeRequirementUpdateOneRequiredWithoutAreaInput = {
    create?: XOR<DegreeRequirementCreateWithoutAreaInput, DegreeRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutAreaInput
    upsert?: DegreeRequirementUpsertWithoutAreaInput
    connect?: DegreeRequirementWhereUniqueInput
    update?: XOR<DegreeRequirementUpdateWithoutAreaInput, DegreeRequirementUncheckedUpdateWithoutAreaInput>
  }

  export type AreaRequirementUpdateOneWithoutAreaInput = {
    create?: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AreaRequirementCreateOrConnectWithoutAreaInput
    upsert?: AreaRequirementUpsertWithoutAreaInput
    connect?: AreaRequirementWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AreaRequirementUpdateWithoutAreaInput, AreaRequirementUncheckedUpdateWithoutAreaInput>
  }

  export type ElectiveStatusUpdateManyWithoutAreaInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutAreaInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutAreaInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutAreaInput>
    upsert?: Enumerable<ElectiveStatusUpsertWithWhereUniqueWithoutAreaInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
    set?: Enumerable<ElectiveStatusWhereUniqueInput>
    disconnect?: Enumerable<ElectiveStatusWhereUniqueInput>
    delete?: Enumerable<ElectiveStatusWhereUniqueInput>
    update?: Enumerable<ElectiveStatusUpdateWithWhereUniqueWithoutAreaInput>
    updateMany?: Enumerable<ElectiveStatusUpdateManyWithWhereWithoutAreaInput>
    deleteMany?: Enumerable<ElectiveStatusScalarWhereInput>
  }

  export type SubAreaUpdateOneWithoutAreaInput = {
    create?: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
    connectOrCreate?: SubAreaCreateOrConnectWithoutAreaInput
    upsert?: SubAreaUpsertWithoutAreaInput
    connect?: SubAreaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubAreaUpdateWithoutAreaInput, SubAreaUncheckedUpdateWithoutAreaInput>
  }

  export type AreaRequirementUncheckedUpdateOneWithoutAreaInput = {
    create?: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AreaRequirementCreateOrConnectWithoutAreaInput
    upsert?: AreaRequirementUpsertWithoutAreaInput
    connect?: AreaRequirementWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AreaRequirementUpdateWithoutAreaInput, AreaRequirementUncheckedUpdateWithoutAreaInput>
  }

  export type ElectiveStatusUncheckedUpdateManyWithoutAreaInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutAreaInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutAreaInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutAreaInput>
    upsert?: Enumerable<ElectiveStatusUpsertWithWhereUniqueWithoutAreaInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
    set?: Enumerable<ElectiveStatusWhereUniqueInput>
    disconnect?: Enumerable<ElectiveStatusWhereUniqueInput>
    delete?: Enumerable<ElectiveStatusWhereUniqueInput>
    update?: Enumerable<ElectiveStatusUpdateWithWhereUniqueWithoutAreaInput>
    updateMany?: Enumerable<ElectiveStatusUpdateManyWithWhereWithoutAreaInput>
    deleteMany?: Enumerable<ElectiveStatusScalarWhereInput>
  }

  export type SubAreaUncheckedUpdateOneWithoutAreaInput = {
    create?: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
    connectOrCreate?: SubAreaCreateOrConnectWithoutAreaInput
    upsert?: SubAreaUpsertWithoutAreaInput
    connect?: SubAreaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubAreaUpdateWithoutAreaInput, SubAreaUncheckedUpdateWithoutAreaInput>
  }

  export type AreaCreateNestedOneWithoutAreaRequirementInput = {
    create?: XOR<AreaCreateWithoutAreaRequirementInput, AreaUncheckedCreateWithoutAreaRequirementInput>
    connectOrCreate?: AreaCreateOrConnectWithoutAreaRequirementInput
    connect?: AreaWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AreaUpdateOneRequiredWithoutAreaRequirementInput = {
    create?: XOR<AreaCreateWithoutAreaRequirementInput, AreaUncheckedCreateWithoutAreaRequirementInput>
    connectOrCreate?: AreaCreateOrConnectWithoutAreaRequirementInput
    upsert?: AreaUpsertWithoutAreaRequirementInput
    connect?: AreaWhereUniqueInput
    update?: XOR<AreaUpdateWithoutAreaRequirementInput, AreaUncheckedUpdateWithoutAreaRequirementInput>
  }

  export type GPDCreateNestedOneWithoutCommentsInput = {
    create?: XOR<GPDCreateWithoutCommentsInput, GPDUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: GPDCreateOrConnectWithoutCommentsInput
    connect?: GPDWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCommentsInput
    connect?: StudentWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GPDUpdateOneRequiredWithoutCommentsInput = {
    create?: XOR<GPDCreateWithoutCommentsInput, GPDUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: GPDCreateOrConnectWithoutCommentsInput
    upsert?: GPDUpsertWithoutCommentsInput
    connect?: GPDWhereUniqueInput
    update?: XOR<GPDUpdateWithoutCommentsInput, GPDUncheckedUpdateWithoutCommentsInput>
  }

  export type StudentUpdateOneRequiredWithoutCommentsInput = {
    create?: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCommentsInput
    upsert?: StudentUpsertWithoutCommentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutCommentsInput, StudentUncheckedUpdateWithoutCommentsInput>
  }

  export type DepartmentCreateNestedOneWithoutCourseInput = {
    create?: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCourseInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CourseOfferingCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<CourseOfferingCreateWithoutCourseInput>, Enumerable<CourseOfferingUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<CourseOfferingCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<CourseOfferingWhereUniqueInput>
  }

  export type prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_courseIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
  }

  export type prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
  }

  export type proficiencyRequirementCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutCourseInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
  }

  export type requiredCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutCourseInput>, Enumerable<requiredCourseUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
  }

  export type RequiredStatusCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutCourseInput>, Enumerable<RequiredStatusUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<CourseOfferingCreateWithoutCourseInput>, Enumerable<CourseOfferingUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<CourseOfferingCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<CourseOfferingWhereUniqueInput>
  }

  export type prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_courseIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
  }

  export type prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
  }

  export type proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutCourseInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
  }

  export type requiredCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutCourseInput>, Enumerable<requiredCourseUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
  }

  export type RequiredStatusUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutCourseInput>, Enumerable<RequiredStatusUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutCourseInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
  }

  export type DepartmentUpdateOneWithoutCourseInput = {
    create?: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCourseInput
    upsert?: DepartmentUpsertWithoutCourseInput
    connect?: DepartmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<DepartmentUpdateWithoutCourseInput, DepartmentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseOfferingUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<CourseOfferingCreateWithoutCourseInput>, Enumerable<CourseOfferingUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<CourseOfferingCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<CourseOfferingUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<CourseOfferingWhereUniqueInput>
    set?: Enumerable<CourseOfferingWhereUniqueInput>
    disconnect?: Enumerable<CourseOfferingWhereUniqueInput>
    delete?: Enumerable<CourseOfferingWhereUniqueInput>
    update?: Enumerable<CourseOfferingUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<CourseOfferingUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<CourseOfferingScalarWhereInput>
  }

  export type prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_courseIDInput>
    upsert?: Enumerable<prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
    set?: Enumerable<prerequisiteWhereUniqueInput>
    disconnect?: Enumerable<prerequisiteWhereUniqueInput>
    delete?: Enumerable<prerequisiteWhereUniqueInput>
    update?: Enumerable<prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput>
    updateMany?: Enumerable<prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_courseIDInput>
    deleteMany?: Enumerable<prerequisiteScalarWhereInput>
  }

  export type prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    upsert?: Enumerable<prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
    set?: Enumerable<prerequisiteWhereUniqueInput>
    disconnect?: Enumerable<prerequisiteWhereUniqueInput>
    delete?: Enumerable<prerequisiteWhereUniqueInput>
    update?: Enumerable<prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    updateMany?: Enumerable<prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    deleteMany?: Enumerable<prerequisiteScalarWhereInput>
  }

  export type proficiencyRequirementUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutCourseInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<proficiencyRequirementUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    set?: Enumerable<proficiencyRequirementWhereUniqueInput>
    disconnect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    delete?: Enumerable<proficiencyRequirementWhereUniqueInput>
    update?: Enumerable<proficiencyRequirementUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<proficiencyRequirementUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<proficiencyRequirementScalarWhereInput>
  }

  export type requiredCourseUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutCourseInput>, Enumerable<requiredCourseUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<requiredCourseUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
    set?: Enumerable<requiredCourseWhereUniqueInput>
    disconnect?: Enumerable<requiredCourseWhereUniqueInput>
    delete?: Enumerable<requiredCourseWhereUniqueInput>
    update?: Enumerable<requiredCourseUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<requiredCourseUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<requiredCourseScalarWhereInput>
  }

  export type RequiredStatusUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutCourseInput>, Enumerable<RequiredStatusUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<RequiredStatusUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
    set?: Enumerable<RequiredStatusWhereUniqueInput>
    disconnect?: Enumerable<RequiredStatusWhereUniqueInput>
    delete?: Enumerable<RequiredStatusWhereUniqueInput>
    update?: Enumerable<RequiredStatusUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<RequiredStatusUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<RequiredStatusScalarWhereInput>
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<CourseOfferingCreateWithoutCourseInput>, Enumerable<CourseOfferingUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<CourseOfferingCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<CourseOfferingUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<CourseOfferingWhereUniqueInput>
    set?: Enumerable<CourseOfferingWhereUniqueInput>
    disconnect?: Enumerable<CourseOfferingWhereUniqueInput>
    delete?: Enumerable<CourseOfferingWhereUniqueInput>
    update?: Enumerable<CourseOfferingUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<CourseOfferingUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<CourseOfferingScalarWhereInput>
  }

  export type prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_courseIDInput>
    upsert?: Enumerable<prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
    set?: Enumerable<prerequisiteWhereUniqueInput>
    disconnect?: Enumerable<prerequisiteWhereUniqueInput>
    delete?: Enumerable<prerequisiteWhereUniqueInput>
    update?: Enumerable<prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput>
    updateMany?: Enumerable<prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_courseIDInput>
    deleteMany?: Enumerable<prerequisiteScalarWhereInput>
  }

  export type prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<Enumerable<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>, Enumerable<prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>>
    connectOrCreate?: Enumerable<prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    upsert?: Enumerable<prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    connect?: Enumerable<prerequisiteWhereUniqueInput>
    set?: Enumerable<prerequisiteWhereUniqueInput>
    disconnect?: Enumerable<prerequisiteWhereUniqueInput>
    delete?: Enumerable<prerequisiteWhereUniqueInput>
    update?: Enumerable<prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    updateMany?: Enumerable<prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    deleteMany?: Enumerable<prerequisiteScalarWhereInput>
  }

  export type proficiencyRequirementUncheckedUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutCourseInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<proficiencyRequirementUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    set?: Enumerable<proficiencyRequirementWhereUniqueInput>
    disconnect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    delete?: Enumerable<proficiencyRequirementWhereUniqueInput>
    update?: Enumerable<proficiencyRequirementUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<proficiencyRequirementUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<proficiencyRequirementScalarWhereInput>
  }

  export type requiredCourseUncheckedUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutCourseInput>, Enumerable<requiredCourseUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<requiredCourseUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
    set?: Enumerable<requiredCourseWhereUniqueInput>
    disconnect?: Enumerable<requiredCourseWhereUniqueInput>
    delete?: Enumerable<requiredCourseWhereUniqueInput>
    update?: Enumerable<requiredCourseUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<requiredCourseUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<requiredCourseScalarWhereInput>
  }

  export type RequiredStatusUncheckedUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutCourseInput>, Enumerable<RequiredStatusUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<RequiredStatusUpsertWithWhereUniqueWithoutCourseInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
    set?: Enumerable<RequiredStatusWhereUniqueInput>
    disconnect?: Enumerable<RequiredStatusWhereUniqueInput>
    delete?: Enumerable<RequiredStatusWhereUniqueInput>
    update?: Enumerable<RequiredStatusUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<RequiredStatusUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<RequiredStatusScalarWhereInput>
  }

  export type CourseCreateNestedOneWithoutCourseOfferingInput = {
    create?: XOR<CourseCreateWithoutCourseOfferingInput, CourseUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseOfferingInput
    connect?: CourseWhereUniqueInput
  }

  export type TimeSlotDayCreateNestedManyWithoutCourseOfferingInput = {
    create?: XOR<Enumerable<TimeSlotDayCreateWithoutCourseOfferingInput>, Enumerable<TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>>
    connectOrCreate?: Enumerable<TimeSlotDayCreateOrConnectWithoutCourseOfferingInput>
    connect?: Enumerable<TimeSlotDayWhereUniqueInput>
  }

  export type TimeSlotTimeCreateNestedOneWithoutCourseOfferingInput = {
    create?: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: TimeSlotTimeCreateOrConnectWithoutCourseOfferingInput
    connect?: TimeSlotTimeWhereUniqueInput
  }

  export type TimeSlotDayUncheckedCreateNestedManyWithoutCourseOfferingInput = {
    create?: XOR<Enumerable<TimeSlotDayCreateWithoutCourseOfferingInput>, Enumerable<TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>>
    connectOrCreate?: Enumerable<TimeSlotDayCreateOrConnectWithoutCourseOfferingInput>
    connect?: Enumerable<TimeSlotDayWhereUniqueInput>
  }

  export type TimeSlotTimeUncheckedCreateNestedOneWithoutCourseOfferingInput = {
    create?: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: TimeSlotTimeCreateOrConnectWithoutCourseOfferingInput
    connect?: TimeSlotTimeWhereUniqueInput
  }

  export type NullableEnumCourseOffering_semesterFieldUpdateOperationsInput = {
    set?: CourseOffering_semester | null
  }

  export type CourseUpdateOneWithoutCourseOfferingInput = {
    create?: XOR<CourseCreateWithoutCourseOfferingInput, CourseUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseOfferingInput
    upsert?: CourseUpsertWithoutCourseOfferingInput
    connect?: CourseWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CourseUpdateWithoutCourseOfferingInput, CourseUncheckedUpdateWithoutCourseOfferingInput>
  }

  export type TimeSlotDayUpdateManyWithoutCourseOfferingInput = {
    create?: XOR<Enumerable<TimeSlotDayCreateWithoutCourseOfferingInput>, Enumerable<TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>>
    connectOrCreate?: Enumerable<TimeSlotDayCreateOrConnectWithoutCourseOfferingInput>
    upsert?: Enumerable<TimeSlotDayUpsertWithWhereUniqueWithoutCourseOfferingInput>
    connect?: Enumerable<TimeSlotDayWhereUniqueInput>
    set?: Enumerable<TimeSlotDayWhereUniqueInput>
    disconnect?: Enumerable<TimeSlotDayWhereUniqueInput>
    delete?: Enumerable<TimeSlotDayWhereUniqueInput>
    update?: Enumerable<TimeSlotDayUpdateWithWhereUniqueWithoutCourseOfferingInput>
    updateMany?: Enumerable<TimeSlotDayUpdateManyWithWhereWithoutCourseOfferingInput>
    deleteMany?: Enumerable<TimeSlotDayScalarWhereInput>
  }

  export type TimeSlotTimeUpdateOneWithoutCourseOfferingInput = {
    create?: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: TimeSlotTimeCreateOrConnectWithoutCourseOfferingInput
    upsert?: TimeSlotTimeUpsertWithoutCourseOfferingInput
    connect?: TimeSlotTimeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TimeSlotTimeUpdateWithoutCourseOfferingInput, TimeSlotTimeUncheckedUpdateWithoutCourseOfferingInput>
  }

  export type TimeSlotDayUncheckedUpdateManyWithoutCourseOfferingInput = {
    create?: XOR<Enumerable<TimeSlotDayCreateWithoutCourseOfferingInput>, Enumerable<TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>>
    connectOrCreate?: Enumerable<TimeSlotDayCreateOrConnectWithoutCourseOfferingInput>
    upsert?: Enumerable<TimeSlotDayUpsertWithWhereUniqueWithoutCourseOfferingInput>
    connect?: Enumerable<TimeSlotDayWhereUniqueInput>
    set?: Enumerable<TimeSlotDayWhereUniqueInput>
    disconnect?: Enumerable<TimeSlotDayWhereUniqueInput>
    delete?: Enumerable<TimeSlotDayWhereUniqueInput>
    update?: Enumerable<TimeSlotDayUpdateWithWhereUniqueWithoutCourseOfferingInput>
    updateMany?: Enumerable<TimeSlotDayUpdateManyWithWhereWithoutCourseOfferingInput>
    deleteMany?: Enumerable<TimeSlotDayScalarWhereInput>
  }

  export type TimeSlotTimeUncheckedUpdateOneWithoutCourseOfferingInput = {
    create?: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
    connectOrCreate?: TimeSlotTimeCreateOrConnectWithoutCourseOfferingInput
    upsert?: TimeSlotTimeUpsertWithoutCourseOfferingInput
    connect?: TimeSlotTimeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TimeSlotTimeUpdateWithoutCourseOfferingInput, TimeSlotTimeUncheckedUpdateWithoutCourseOfferingInput>
  }

  export type StudentCreateNestedOneWithoutCoursePlanInput = {
    create?: XOR<StudentCreateWithoutCoursePlanInput, StudentUncheckedCreateWithoutCoursePlanInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCoursePlanInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type StudentUpdateOneRequiredWithoutCoursePlanInput = {
    create?: XOR<StudentCreateWithoutCoursePlanInput, StudentUncheckedCreateWithoutCoursePlanInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCoursePlanInput
    upsert?: StudentUpsertWithoutCoursePlanInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutCoursePlanInput, StudentUncheckedUpdateWithoutCoursePlanInput>
  }

  export type DepartmentCreateNestedOneWithoutDegreeRequirementInput = {
    create?: XOR<DepartmentCreateWithoutDegreeRequirementInput, DepartmentUncheckedCreateWithoutDegreeRequirementInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDegreeRequirementInput
    connect?: DepartmentWhereUniqueInput
  }

  export type AreaCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<AreaCreateWithoutDegreeRequirementInput>, Enumerable<AreaUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<AreaCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<AreaWhereUniqueInput>
  }

  export type proficiencyRequirementCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutDegreeRequirementInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
  }

  export type requiredCourseCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutDegreeRequirementInput>, Enumerable<requiredCourseUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
  }

  export type AreaUncheckedCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<AreaCreateWithoutDegreeRequirementInput>, Enumerable<AreaUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<AreaCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<AreaWhereUniqueInput>
  }

  export type proficiencyRequirementUncheckedCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutDegreeRequirementInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
  }

  export type requiredCourseUncheckedCreateNestedManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutDegreeRequirementInput>, Enumerable<requiredCourseUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutDegreeRequirementInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
  }

  export type NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput = {
    set?: DegreeRequirement_versionSemester | null
  }

  export type DepartmentUpdateOneWithoutDegreeRequirementInput = {
    create?: XOR<DepartmentCreateWithoutDegreeRequirementInput, DepartmentUncheckedCreateWithoutDegreeRequirementInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDegreeRequirementInput
    upsert?: DepartmentUpsertWithoutDegreeRequirementInput
    connect?: DepartmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<DepartmentUpdateWithoutDegreeRequirementInput, DepartmentUncheckedUpdateWithoutDegreeRequirementInput>
  }

  export type AreaUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<AreaCreateWithoutDegreeRequirementInput>, Enumerable<AreaUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<AreaCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<AreaUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<AreaWhereUniqueInput>
    set?: Enumerable<AreaWhereUniqueInput>
    disconnect?: Enumerable<AreaWhereUniqueInput>
    delete?: Enumerable<AreaWhereUniqueInput>
    update?: Enumerable<AreaUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<AreaUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<AreaScalarWhereInput>
  }

  export type proficiencyRequirementUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutDegreeRequirementInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<proficiencyRequirementUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    set?: Enumerable<proficiencyRequirementWhereUniqueInput>
    disconnect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    delete?: Enumerable<proficiencyRequirementWhereUniqueInput>
    update?: Enumerable<proficiencyRequirementUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<proficiencyRequirementUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<proficiencyRequirementScalarWhereInput>
  }

  export type requiredCourseUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutDegreeRequirementInput>, Enumerable<requiredCourseUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<requiredCourseUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
    set?: Enumerable<requiredCourseWhereUniqueInput>
    disconnect?: Enumerable<requiredCourseWhereUniqueInput>
    delete?: Enumerable<requiredCourseWhereUniqueInput>
    update?: Enumerable<requiredCourseUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<requiredCourseUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<requiredCourseScalarWhereInput>
  }

  export type AreaUncheckedUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<AreaCreateWithoutDegreeRequirementInput>, Enumerable<AreaUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<AreaCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<AreaUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<AreaWhereUniqueInput>
    set?: Enumerable<AreaWhereUniqueInput>
    disconnect?: Enumerable<AreaWhereUniqueInput>
    delete?: Enumerable<AreaWhereUniqueInput>
    update?: Enumerable<AreaUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<AreaUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<AreaScalarWhereInput>
  }

  export type proficiencyRequirementUncheckedUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<proficiencyRequirementCreateWithoutDegreeRequirementInput>, Enumerable<proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<proficiencyRequirementCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<proficiencyRequirementUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    set?: Enumerable<proficiencyRequirementWhereUniqueInput>
    disconnect?: Enumerable<proficiencyRequirementWhereUniqueInput>
    delete?: Enumerable<proficiencyRequirementWhereUniqueInput>
    update?: Enumerable<proficiencyRequirementUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<proficiencyRequirementUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<proficiencyRequirementScalarWhereInput>
  }

  export type requiredCourseUncheckedUpdateManyWithoutDegreeRequirementInput = {
    create?: XOR<Enumerable<requiredCourseCreateWithoutDegreeRequirementInput>, Enumerable<requiredCourseUncheckedCreateWithoutDegreeRequirementInput>>
    connectOrCreate?: Enumerable<requiredCourseCreateOrConnectWithoutDegreeRequirementInput>
    upsert?: Enumerable<requiredCourseUpsertWithWhereUniqueWithoutDegreeRequirementInput>
    connect?: Enumerable<requiredCourseWhereUniqueInput>
    set?: Enumerable<requiredCourseWhereUniqueInput>
    disconnect?: Enumerable<requiredCourseWhereUniqueInput>
    delete?: Enumerable<requiredCourseWhereUniqueInput>
    update?: Enumerable<requiredCourseUpdateWithWhereUniqueWithoutDegreeRequirementInput>
    updateMany?: Enumerable<requiredCourseUpdateManyWithWhereWithoutDegreeRequirementInput>
    deleteMany?: Enumerable<requiredCourseScalarWhereInput>
  }

  export type CourseCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<CourseCreateWithoutDepartmentInput>, Enumerable<CourseUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutDepartmentInput>
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type DegreeRequirementCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<DegreeRequirementCreateWithoutDepartmentInput>, Enumerable<DegreeRequirementUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<DegreeRequirementCreateOrConnectWithoutDepartmentInput>
    connect?: Enumerable<DegreeRequirementWhereUniqueInput>
  }

  export type GPDCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: GPDCreateOrConnectWithoutDepartmentInput
    connect?: GPDWhereUniqueInput
  }

  export type CourseUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<CourseCreateWithoutDepartmentInput>, Enumerable<CourseUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutDepartmentInput>
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type DegreeRequirementUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<DegreeRequirementCreateWithoutDepartmentInput>, Enumerable<DegreeRequirementUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<DegreeRequirementCreateOrConnectWithoutDepartmentInput>
    connect?: Enumerable<DegreeRequirementWhereUniqueInput>
  }

  export type GPDUncheckedCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: GPDCreateOrConnectWithoutDepartmentInput
    connect?: GPDWhereUniqueInput
  }

  export type CourseUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<CourseCreateWithoutDepartmentInput>, Enumerable<CourseUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type DegreeRequirementUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<DegreeRequirementCreateWithoutDepartmentInput>, Enumerable<DegreeRequirementUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<DegreeRequirementCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<DegreeRequirementUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<DegreeRequirementWhereUniqueInput>
    set?: Enumerable<DegreeRequirementWhereUniqueInput>
    disconnect?: Enumerable<DegreeRequirementWhereUniqueInput>
    delete?: Enumerable<DegreeRequirementWhereUniqueInput>
    update?: Enumerable<DegreeRequirementUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<DegreeRequirementUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<DegreeRequirementScalarWhereInput>
  }

  export type GPDUpdateOneWithoutDepartmentInput = {
    create?: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: GPDCreateOrConnectWithoutDepartmentInput
    upsert?: GPDUpsertWithoutDepartmentInput
    connect?: GPDWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GPDUpdateWithoutDepartmentInput, GPDUncheckedUpdateWithoutDepartmentInput>
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<CourseCreateWithoutDepartmentInput>, Enumerable<CourseUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type DegreeRequirementUncheckedUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<DegreeRequirementCreateWithoutDepartmentInput>, Enumerable<DegreeRequirementUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<DegreeRequirementCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<DegreeRequirementUpsertWithWhereUniqueWithoutDepartmentInput>
    connect?: Enumerable<DegreeRequirementWhereUniqueInput>
    set?: Enumerable<DegreeRequirementWhereUniqueInput>
    disconnect?: Enumerable<DegreeRequirementWhereUniqueInput>
    delete?: Enumerable<DegreeRequirementWhereUniqueInput>
    update?: Enumerable<DegreeRequirementUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<DegreeRequirementUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<DegreeRequirementScalarWhereInput>
  }

  export type GPDUncheckedUpdateOneWithoutDepartmentInput = {
    create?: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: GPDCreateOrConnectWithoutDepartmentInput
    upsert?: GPDUpsertWithoutDepartmentInput
    connect?: GPDWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GPDUpdateWithoutDepartmentInput, GPDUncheckedUpdateWithoutDepartmentInput>
  }

  export type AreaCreateNestedOneWithoutElectiveStatusInput = {
    create?: XOR<AreaCreateWithoutElectiveStatusInput, AreaUncheckedCreateWithoutElectiveStatusInput>
    connectOrCreate?: AreaCreateOrConnectWithoutElectiveStatusInput
    connect?: AreaWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutElectiveStatusInput = {
    create?: XOR<StudentCreateWithoutElectiveStatusInput, StudentUncheckedCreateWithoutElectiveStatusInput>
    connectOrCreate?: StudentCreateOrConnectWithoutElectiveStatusInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableEnumElectiveStatus_statusFieldUpdateOperationsInput = {
    set?: ElectiveStatus_status | null
  }

  export type AreaUpdateOneRequiredWithoutElectiveStatusInput = {
    create?: XOR<AreaCreateWithoutElectiveStatusInput, AreaUncheckedCreateWithoutElectiveStatusInput>
    connectOrCreate?: AreaCreateOrConnectWithoutElectiveStatusInput
    upsert?: AreaUpsertWithoutElectiveStatusInput
    connect?: AreaWhereUniqueInput
    update?: XOR<AreaUpdateWithoutElectiveStatusInput, AreaUncheckedUpdateWithoutElectiveStatusInput>
  }

  export type StudentUpdateOneRequiredWithoutElectiveStatusInput = {
    create?: XOR<StudentCreateWithoutElectiveStatusInput, StudentUncheckedCreateWithoutElectiveStatusInput>
    connectOrCreate?: StudentCreateOrConnectWithoutElectiveStatusInput
    upsert?: StudentUpsertWithoutElectiveStatusInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutElectiveStatusInput, StudentUncheckedUpdateWithoutElectiveStatusInput>
  }

  export type UserCreateNestedOneWithoutGPDInput = {
    create?: XOR<UserCreateWithoutGPDInput, UserUncheckedCreateWithoutGPDInput>
    connectOrCreate?: UserCreateOrConnectWithoutGPDInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutGPDInput = {
    create?: XOR<DepartmentCreateWithoutGPDInput, DepartmentUncheckedCreateWithoutGPDInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutGPDInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CommentsCreateNestedManyWithoutGPDInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutGPDInput>, Enumerable<CommentsUncheckedCreateWithoutGPDInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutGPDInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type CommentsUncheckedCreateNestedManyWithoutGPDInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutGPDInput>, Enumerable<CommentsUncheckedCreateWithoutGPDInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutGPDInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutGPDInput = {
    create?: XOR<UserCreateWithoutGPDInput, UserUncheckedCreateWithoutGPDInput>
    connectOrCreate?: UserCreateOrConnectWithoutGPDInput
    upsert?: UserUpsertWithoutGPDInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGPDInput, UserUncheckedUpdateWithoutGPDInput>
  }

  export type DepartmentUpdateOneRequiredWithoutGPDInput = {
    create?: XOR<DepartmentCreateWithoutGPDInput, DepartmentUncheckedCreateWithoutGPDInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutGPDInput
    upsert?: DepartmentUpsertWithoutGPDInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<DepartmentUpdateWithoutGPDInput, DepartmentUncheckedUpdateWithoutGPDInput>
  }

  export type CommentsUpdateManyWithoutGPDInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutGPDInput>, Enumerable<CommentsUncheckedCreateWithoutGPDInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutGPDInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutGPDInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutGPDInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutGPDInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type CommentsUncheckedUpdateManyWithoutGPDInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutGPDInput>, Enumerable<CommentsUncheckedCreateWithoutGPDInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutGPDInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutGPDInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutGPDInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutGPDInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type StudentCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutGradesInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    upsert?: StudentUpsertWithoutGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    create?: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_courseIDInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    create?: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_courseIDInput
    upsert?: CourseUpsertWithoutPrerequisite_CourseToprerequisite_courseIDInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
  }

  export type CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    create?: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
    upsert?: CourseUpsertWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
  }

  export type CourseCreateNestedOneWithoutProficiencyRequirementInput = {
    create?: XOR<CourseCreateWithoutProficiencyRequirementInput, CourseUncheckedCreateWithoutProficiencyRequirementInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProficiencyRequirementInput
    connect?: CourseWhereUniqueInput
  }

  export type DegreeRequirementCreateNestedOneWithoutProficiencyRequirementInput = {
    create?: XOR<DegreeRequirementCreateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedCreateWithoutProficiencyRequirementInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutProficiencyRequirementInput
    connect?: DegreeRequirementWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutProficiencyRequirementInput = {
    create?: XOR<CourseCreateWithoutProficiencyRequirementInput, CourseUncheckedCreateWithoutProficiencyRequirementInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProficiencyRequirementInput
    upsert?: CourseUpsertWithoutProficiencyRequirementInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutProficiencyRequirementInput, CourseUncheckedUpdateWithoutProficiencyRequirementInput>
  }

  export type DegreeRequirementUpdateOneRequiredWithoutProficiencyRequirementInput = {
    create?: XOR<DegreeRequirementCreateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedCreateWithoutProficiencyRequirementInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutProficiencyRequirementInput
    upsert?: DegreeRequirementUpsertWithoutProficiencyRequirementInput
    connect?: DegreeRequirementWhereUniqueInput
    update?: XOR<DegreeRequirementUpdateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedUpdateWithoutProficiencyRequirementInput>
  }

  export type CourseCreateNestedOneWithoutRequiredCourseInput = {
    create?: XOR<CourseCreateWithoutRequiredCourseInput, CourseUncheckedCreateWithoutRequiredCourseInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequiredCourseInput
    connect?: CourseWhereUniqueInput
  }

  export type DegreeRequirementCreateNestedOneWithoutRequiredCourseInput = {
    create?: XOR<DegreeRequirementCreateWithoutRequiredCourseInput, DegreeRequirementUncheckedCreateWithoutRequiredCourseInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutRequiredCourseInput
    connect?: DegreeRequirementWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutRequiredCourseInput = {
    create?: XOR<CourseCreateWithoutRequiredCourseInput, CourseUncheckedCreateWithoutRequiredCourseInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequiredCourseInput
    upsert?: CourseUpsertWithoutRequiredCourseInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutRequiredCourseInput, CourseUncheckedUpdateWithoutRequiredCourseInput>
  }

  export type DegreeRequirementUpdateOneRequiredWithoutRequiredCourseInput = {
    create?: XOR<DegreeRequirementCreateWithoutRequiredCourseInput, DegreeRequirementUncheckedCreateWithoutRequiredCourseInput>
    connectOrCreate?: DegreeRequirementCreateOrConnectWithoutRequiredCourseInput
    upsert?: DegreeRequirementUpsertWithoutRequiredCourseInput
    connect?: DegreeRequirementWhereUniqueInput
    update?: XOR<DegreeRequirementUpdateWithoutRequiredCourseInput, DegreeRequirementUncheckedUpdateWithoutRequiredCourseInput>
  }

  export type CourseCreateNestedOneWithoutRequiredStatusInput = {
    create?: XOR<CourseCreateWithoutRequiredStatusInput, CourseUncheckedCreateWithoutRequiredStatusInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequiredStatusInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutRequiredStatusInput = {
    create?: XOR<StudentCreateWithoutRequiredStatusInput, StudentUncheckedCreateWithoutRequiredStatusInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequiredStatusInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableEnumRequiredStatus_statusFieldUpdateOperationsInput = {
    set?: RequiredStatus_status | null
  }

  export type CourseUpdateOneRequiredWithoutRequiredStatusInput = {
    create?: XOR<CourseCreateWithoutRequiredStatusInput, CourseUncheckedCreateWithoutRequiredStatusInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRequiredStatusInput
    upsert?: CourseUpsertWithoutRequiredStatusInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutRequiredStatusInput, CourseUncheckedUpdateWithoutRequiredStatusInput>
  }

  export type StudentUpdateOneRequiredWithoutRequiredStatusInput = {
    create?: XOR<StudentCreateWithoutRequiredStatusInput, StudentUncheckedCreateWithoutRequiredStatusInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequiredStatusInput
    upsert?: StudentUpsertWithoutRequiredStatusInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutRequiredStatusInput, StudentUncheckedUpdateWithoutRequiredStatusInput>
  }

  export type CommentsCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutStudentInput>, Enumerable<CommentsUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type CoursePlanCreateNestedOneWithoutStudentInput = {
    create?: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
    connectOrCreate?: CoursePlanCreateOrConnectWithoutStudentInput
    connect?: CoursePlanWhereUniqueInput
  }

  export type ElectiveStatusCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutStudentInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
  }

  export type GradesCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<GradesCreateWithoutStudentInput>, Enumerable<GradesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<GradesCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<GradesWhereUniqueInput>
  }

  export type RequiredStatusCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutStudentInput>, Enumerable<RequiredStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
  }

  export type CommentsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutStudentInput>, Enumerable<CommentsUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type CoursePlanUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
    connectOrCreate?: CoursePlanCreateOrConnectWithoutStudentInput
    connect?: CoursePlanWhereUniqueInput
  }

  export type ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutStudentInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
  }

  export type GradesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<GradesCreateWithoutStudentInput>, Enumerable<GradesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<GradesCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<GradesWhereUniqueInput>
  }

  export type RequiredStatusUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutStudentInput>, Enumerable<RequiredStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
  }

  export type EnumStudent_entrySemesterFieldUpdateOperationsInput = {
    set?: Student_entrySemester
  }

  export type NullableEnumStudent_gradSemesterFieldUpdateOperationsInput = {
    set?: Student_gradSemester | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type CommentsUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutStudentInput>, Enumerable<CommentsUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type CoursePlanUpdateOneWithoutStudentInput = {
    create?: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
    connectOrCreate?: CoursePlanCreateOrConnectWithoutStudentInput
    upsert?: CoursePlanUpsertWithoutStudentInput
    connect?: CoursePlanWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CoursePlanUpdateWithoutStudentInput, CoursePlanUncheckedUpdateWithoutStudentInput>
  }

  export type ElectiveStatusUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutStudentInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<ElectiveStatusUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
    set?: Enumerable<ElectiveStatusWhereUniqueInput>
    disconnect?: Enumerable<ElectiveStatusWhereUniqueInput>
    delete?: Enumerable<ElectiveStatusWhereUniqueInput>
    update?: Enumerable<ElectiveStatusUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<ElectiveStatusUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<ElectiveStatusScalarWhereInput>
  }

  export type GradesUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<GradesCreateWithoutStudentInput>, Enumerable<GradesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<GradesCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<GradesUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<GradesWhereUniqueInput>
    set?: Enumerable<GradesWhereUniqueInput>
    disconnect?: Enumerable<GradesWhereUniqueInput>
    delete?: Enumerable<GradesWhereUniqueInput>
    update?: Enumerable<GradesUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<GradesUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<GradesScalarWhereInput>
  }

  export type RequiredStatusUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutStudentInput>, Enumerable<RequiredStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<RequiredStatusUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
    set?: Enumerable<RequiredStatusWhereUniqueInput>
    disconnect?: Enumerable<RequiredStatusWhereUniqueInput>
    delete?: Enumerable<RequiredStatusWhereUniqueInput>
    update?: Enumerable<RequiredStatusUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<RequiredStatusUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<RequiredStatusScalarWhereInput>
  }

  export type CommentsUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutStudentInput>, Enumerable<CommentsUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type CoursePlanUncheckedUpdateOneWithoutStudentInput = {
    create?: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
    connectOrCreate?: CoursePlanCreateOrConnectWithoutStudentInput
    upsert?: CoursePlanUpsertWithoutStudentInput
    connect?: CoursePlanWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CoursePlanUpdateWithoutStudentInput, CoursePlanUncheckedUpdateWithoutStudentInput>
  }

  export type ElectiveStatusUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<ElectiveStatusCreateWithoutStudentInput>, Enumerable<ElectiveStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<ElectiveStatusCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<ElectiveStatusUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<ElectiveStatusWhereUniqueInput>
    set?: Enumerable<ElectiveStatusWhereUniqueInput>
    disconnect?: Enumerable<ElectiveStatusWhereUniqueInput>
    delete?: Enumerable<ElectiveStatusWhereUniqueInput>
    update?: Enumerable<ElectiveStatusUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<ElectiveStatusUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<ElectiveStatusScalarWhereInput>
  }

  export type GradesUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<GradesCreateWithoutStudentInput>, Enumerable<GradesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<GradesCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<GradesUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<GradesWhereUniqueInput>
    set?: Enumerable<GradesWhereUniqueInput>
    disconnect?: Enumerable<GradesWhereUniqueInput>
    delete?: Enumerable<GradesWhereUniqueInput>
    update?: Enumerable<GradesUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<GradesUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<GradesScalarWhereInput>
  }

  export type RequiredStatusUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<RequiredStatusCreateWithoutStudentInput>, Enumerable<RequiredStatusUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<RequiredStatusCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<RequiredStatusUpsertWithWhereUniqueWithoutStudentInput>
    connect?: Enumerable<RequiredStatusWhereUniqueInput>
    set?: Enumerable<RequiredStatusWhereUniqueInput>
    disconnect?: Enumerable<RequiredStatusWhereUniqueInput>
    delete?: Enumerable<RequiredStatusWhereUniqueInput>
    update?: Enumerable<RequiredStatusUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<RequiredStatusUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<RequiredStatusScalarWhereInput>
  }

  export type AreaCreateNestedOneWithoutSubAreaInput = {
    create?: XOR<AreaCreateWithoutSubAreaInput, AreaUncheckedCreateWithoutSubAreaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutSubAreaInput
    connect?: AreaWhereUniqueInput
  }

  export type AreaUpdateOneRequiredWithoutSubAreaInput = {
    create?: XOR<AreaCreateWithoutSubAreaInput, AreaUncheckedCreateWithoutSubAreaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutSubAreaInput
    upsert?: AreaUpsertWithoutSubAreaInput
    connect?: AreaWhereUniqueInput
    update?: XOR<AreaUpdateWithoutSubAreaInput, AreaUncheckedUpdateWithoutSubAreaInput>
  }

  export type CourseOfferingCreateNestedOneWithoutTimeSlotDayInput = {
    create?: XOR<CourseOfferingCreateWithoutTimeSlotDayInput, CourseOfferingUncheckedCreateWithoutTimeSlotDayInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTimeSlotDayInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type EnumTimeSlotDay_dayFieldUpdateOperationsInput = {
    set?: TimeSlotDay_day
  }

  export type CourseOfferingUpdateOneRequiredWithoutTimeSlotDayInput = {
    create?: XOR<CourseOfferingCreateWithoutTimeSlotDayInput, CourseOfferingUncheckedCreateWithoutTimeSlotDayInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTimeSlotDayInput
    upsert?: CourseOfferingUpsertWithoutTimeSlotDayInput
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<CourseOfferingUpdateWithoutTimeSlotDayInput, CourseOfferingUncheckedUpdateWithoutTimeSlotDayInput>
  }

  export type CourseOfferingCreateNestedOneWithoutTimeSlotTimeInput = {
    create?: XOR<CourseOfferingCreateWithoutTimeSlotTimeInput, CourseOfferingUncheckedCreateWithoutTimeSlotTimeInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTimeSlotTimeInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type CourseOfferingUpdateOneRequiredWithoutTimeSlotTimeInput = {
    create?: XOR<CourseOfferingCreateWithoutTimeSlotTimeInput, CourseOfferingUncheckedCreateWithoutTimeSlotTimeInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTimeSlotTimeInput
    upsert?: CourseOfferingUpsertWithoutTimeSlotTimeInput
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<CourseOfferingUpdateWithoutTimeSlotTimeInput, CourseOfferingUncheckedUpdateWithoutTimeSlotTimeInput>
  }

  export type GPDCreateNestedOneWithoutUserInput = {
    create?: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
    connectOrCreate?: GPDCreateOrConnectWithoutUserInput
    connect?: GPDWhereUniqueInput
  }

  export type GPDUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
    connectOrCreate?: GPDCreateOrConnectWithoutUserInput
    connect?: GPDWhereUniqueInput
  }

  export type GPDUpdateOneWithoutUserInput = {
    create?: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
    connectOrCreate?: GPDCreateOrConnectWithoutUserInput
    upsert?: GPDUpsertWithoutUserInput
    connect?: GPDWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GPDUpdateWithoutUserInput, GPDUncheckedUpdateWithoutUserInput>
  }

  export type GPDUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
    connectOrCreate?: GPDCreateOrConnectWithoutUserInput
    upsert?: GPDUpsertWithoutUserInput
    connect?: GPDWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GPDUpdateWithoutUserInput, GPDUncheckedUpdateWithoutUserInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumCourseOffering_semesterNullableFilter = {
    equals?: CourseOffering_semester | null
    in?: Enumerable<CourseOffering_semester> | null
    notIn?: Enumerable<CourseOffering_semester> | null
    not?: NestedEnumCourseOffering_semesterNullableFilter | CourseOffering_semester | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedEnumDegreeRequirement_versionSemesterNullableFilter = {
    equals?: DegreeRequirement_versionSemester | null
    in?: Enumerable<DegreeRequirement_versionSemester> | null
    notIn?: Enumerable<DegreeRequirement_versionSemester> | null
    not?: NestedEnumDegreeRequirement_versionSemesterNullableFilter | DegreeRequirement_versionSemester | null
  }

  export type NestedEnumElectiveStatus_statusNullableFilter = {
    equals?: ElectiveStatus_status | null
    in?: Enumerable<ElectiveStatus_status> | null
    notIn?: Enumerable<ElectiveStatus_status> | null
    not?: NestedEnumElectiveStatus_statusNullableFilter | ElectiveStatus_status | null
  }

  export type NestedEnumRequiredStatus_statusNullableFilter = {
    equals?: RequiredStatus_status | null
    in?: Enumerable<RequiredStatus_status> | null
    notIn?: Enumerable<RequiredStatus_status> | null
    not?: NestedEnumRequiredStatus_statusNullableFilter | RequiredStatus_status | null
  }

  export type NestedEnumStudent_entrySemesterFilter = {
    equals?: Student_entrySemester
    in?: Enumerable<Student_entrySemester>
    notIn?: Enumerable<Student_entrySemester>
    not?: NestedEnumStudent_entrySemesterFilter | Student_entrySemester
  }

  export type NestedEnumStudent_gradSemesterNullableFilter = {
    equals?: Student_gradSemester | null
    in?: Enumerable<Student_gradSemester> | null
    notIn?: Enumerable<Student_gradSemester> | null
    not?: NestedEnumStudent_gradSemesterNullableFilter | Student_gradSemester | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type NestedEnumTimeSlotDay_dayFilter = {
    equals?: TimeSlotDay_day
    in?: Enumerable<TimeSlotDay_day>
    notIn?: Enumerable<TimeSlotDay_day>
    not?: NestedEnumTimeSlotDay_dayFilter | TimeSlotDay_day
  }

  export type DegreeRequirementCreateWithoutAreaInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Department?: DepartmentCreateNestedOneWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedCreateWithoutAreaInput = {
    requirementID: number
    departID?: string | null
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementCreateOrConnectWithoutAreaInput = {
    where: DegreeRequirementWhereUniqueInput
    create: XOR<DegreeRequirementCreateWithoutAreaInput, DegreeRequirementUncheckedCreateWithoutAreaInput>
  }

  export type AreaRequirementCreateWithoutAreaInput = {
    nSubAreas?: number | null
    nCourses?: number | null
    nCredits?: number | null
  }

  export type AreaRequirementUncheckedCreateWithoutAreaInput = {
    nSubAreas?: number | null
    nCourses?: number | null
    nCredits?: number | null
  }

  export type AreaRequirementCreateOrConnectWithoutAreaInput = {
    where: AreaRequirementWhereUniqueInput
    create: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
  }

  export type ElectiveStatusCreateWithoutAreaInput = {
    status?: ElectiveStatus_status | null
    Student: StudentCreateNestedOneWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedCreateWithoutAreaInput = {
    studentID: number
    status?: ElectiveStatus_status | null
  }

  export type ElectiveStatusCreateOrConnectWithoutAreaInput = {
    where: ElectiveStatusWhereUniqueInput
    create: XOR<ElectiveStatusCreateWithoutAreaInput, ElectiveStatusUncheckedCreateWithoutAreaInput>
  }

  export type SubAreaCreateWithoutAreaInput = {
    minCourses?: number | null
    minCredit?: number | null
    maxCredit?: number | null
    maxCourse?: number | null
    name?: string | null
  }

  export type SubAreaUncheckedCreateWithoutAreaInput = {
    minCourses?: number | null
    minCredit?: number | null
    maxCredit?: number | null
    maxCourse?: number | null
    name?: string | null
  }

  export type SubAreaCreateOrConnectWithoutAreaInput = {
    where: SubAreaWhereUniqueInput
    create: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
  }

  export type DegreeRequirementUpsertWithoutAreaInput = {
    update: XOR<DegreeRequirementUpdateWithoutAreaInput, DegreeRequirementUncheckedUpdateWithoutAreaInput>
    create: XOR<DegreeRequirementCreateWithoutAreaInput, DegreeRequirementUncheckedCreateWithoutAreaInput>
  }

  export type DegreeRequirementUpdateWithoutAreaInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateWithoutAreaInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutDegreeRequirementInput
  }

  export type AreaRequirementUpsertWithoutAreaInput = {
    update: XOR<AreaRequirementUpdateWithoutAreaInput, AreaRequirementUncheckedUpdateWithoutAreaInput>
    create: XOR<AreaRequirementCreateWithoutAreaInput, AreaRequirementUncheckedCreateWithoutAreaInput>
  }

  export type AreaRequirementUpdateWithoutAreaInput = {
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaRequirementUncheckedUpdateWithoutAreaInput = {
    nSubAreas?: NullableIntFieldUpdateOperationsInput | number | null
    nCourses?: NullableIntFieldUpdateOperationsInput | number | null
    nCredits?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ElectiveStatusUpsertWithWhereUniqueWithoutAreaInput = {
    where: ElectiveStatusWhereUniqueInput
    update: XOR<ElectiveStatusUpdateWithoutAreaInput, ElectiveStatusUncheckedUpdateWithoutAreaInput>
    create: XOR<ElectiveStatusCreateWithoutAreaInput, ElectiveStatusUncheckedCreateWithoutAreaInput>
  }

  export type ElectiveStatusUpdateWithWhereUniqueWithoutAreaInput = {
    where: ElectiveStatusWhereUniqueInput
    data: XOR<ElectiveStatusUpdateWithoutAreaInput, ElectiveStatusUncheckedUpdateWithoutAreaInput>
  }

  export type ElectiveStatusUpdateManyWithWhereWithoutAreaInput = {
    where: ElectiveStatusScalarWhereInput
    data: XOR<ElectiveStatusUpdateManyMutationInput, ElectiveStatusUncheckedUpdateManyWithoutElectiveStatusInput>
  }

  export type ElectiveStatusScalarWhereInput = {
    AND?: Enumerable<ElectiveStatusScalarWhereInput>
    OR?: Enumerable<ElectiveStatusScalarWhereInput>
    NOT?: Enumerable<ElectiveStatusScalarWhereInput>
    studentID?: IntFilter | number
    areaID?: IntFilter | number
    status?: EnumElectiveStatus_statusNullableFilter | ElectiveStatus_status | null
  }

  export type SubAreaUpsertWithoutAreaInput = {
    update: XOR<SubAreaUpdateWithoutAreaInput, SubAreaUncheckedUpdateWithoutAreaInput>
    create: XOR<SubAreaCreateWithoutAreaInput, SubAreaUncheckedCreateWithoutAreaInput>
  }

  export type SubAreaUpdateWithoutAreaInput = {
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAreaUncheckedUpdateWithoutAreaInput = {
    minCourses?: NullableIntFieldUpdateOperationsInput | number | null
    minCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    maxCourse?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaCreateWithoutAreaRequirementInput = {
    areaID: number
    name?: string | null
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaCreateNestedOneWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutAreaRequirementInput = {
    areaID: number
    requirementID: number
    name?: string | null
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaUncheckedCreateNestedOneWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutAreaRequirementInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutAreaRequirementInput, AreaUncheckedCreateWithoutAreaRequirementInput>
  }

  export type AreaUpsertWithoutAreaRequirementInput = {
    update: XOR<AreaUpdateWithoutAreaRequirementInput, AreaUncheckedUpdateWithoutAreaRequirementInput>
    create: XOR<AreaCreateWithoutAreaRequirementInput, AreaUncheckedCreateWithoutAreaRequirementInput>
  }

  export type AreaUpdateWithoutAreaRequirementInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutAreaInput
    SubArea?: SubAreaUpdateOneWithoutAreaInput
  }

  export type AreaUncheckedUpdateWithoutAreaRequirementInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    requirementID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutAreaInput
    SubArea?: SubAreaUncheckedUpdateOneWithoutAreaInput
  }

  export type GPDCreateWithoutCommentsInput = {
    User: UserCreateNestedOneWithoutGPDInput
    Department: DepartmentCreateNestedOneWithoutGPDInput
  }

  export type GPDUncheckedCreateWithoutCommentsInput = {
    GPDID: number
    departmentID: string
  }

  export type GPDCreateOrConnectWithoutCommentsInput = {
    where: GPDWhereUniqueInput
    create: XOR<GPDCreateWithoutCommentsInput, GPDUncheckedCreateWithoutCommentsInput>
  }

  export type StudentCreateWithoutCommentsInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    CoursePlan?: CoursePlanCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutStudentInput
    Grades?: GradesCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCommentsInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    CoursePlan?: CoursePlanUncheckedCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput
    Grades?: GradesUncheckedCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCommentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
  }

  export type GPDUpsertWithoutCommentsInput = {
    update: XOR<GPDUpdateWithoutCommentsInput, GPDUncheckedUpdateWithoutCommentsInput>
    create: XOR<GPDCreateWithoutCommentsInput, GPDUncheckedCreateWithoutCommentsInput>
  }

  export type GPDUpdateWithoutCommentsInput = {
    User?: UserUpdateOneRequiredWithoutGPDInput
    Department?: DepartmentUpdateOneRequiredWithoutGPDInput
  }

  export type GPDUncheckedUpdateWithoutCommentsInput = {
    GPDID?: IntFieldUpdateOperationsInput | number
    departmentID?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpsertWithoutCommentsInput = {
    update: XOR<StudentUpdateWithoutCommentsInput, StudentUncheckedUpdateWithoutCommentsInput>
    create: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
  }

  export type StudentUpdateWithoutCommentsInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CoursePlan?: CoursePlanUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutStudentInput
    Grades?: GradesUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutCommentsInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CoursePlan?: CoursePlanUncheckedUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutStudentInput
    Grades?: GradesUncheckedUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutStudentInput
  }

  export type DepartmentCreateWithoutCourseInput = {
    departmentID: string
    departmentName?: string | null
    DegreeRequirement?: DegreeRequirementCreateNestedManyWithoutDepartmentInput
    GPD?: GPDCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCourseInput = {
    departmentID: string
    departmentName?: string | null
    DegreeRequirement?: DegreeRequirementUncheckedCreateNestedManyWithoutDepartmentInput
    GPD?: GPDUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCourseInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingCreateWithoutCourseInput = {
    courseOfferingID: string
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    TimeSlotDay?: TimeSlotDayCreateNestedManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutCourseInput = {
    courseOfferingID: string
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    TimeSlotDay?: TimeSlotDayUncheckedCreateNestedManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUncheckedCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput = {
    Course_CourseToprerequisite_prerequisiteID: CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
  }

  export type prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput = {
    prerequisiteID: string
  }

  export type prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_courseIDInput = {
    where: prerequisiteWhereUniqueInput
    create: XOR<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput, prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>
  }

  export type prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    Course_CourseToprerequisite_courseID: CourseCreateNestedOneWithoutPrerequisite_CourseToprerequisite_courseIDInput
  }

  export type prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    courseID: string
  }

  export type prerequisiteCreateOrConnectWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    where: prerequisiteWhereUniqueInput
    create: XOR<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput, prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
  }

  export type proficiencyRequirementCreateWithoutCourseInput = {
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedCreateWithoutCourseInput = {
    requirementID: number
  }

  export type proficiencyRequirementCreateOrConnectWithoutCourseInput = {
    where: proficiencyRequirementWhereUniqueInput
    create: XOR<proficiencyRequirementCreateWithoutCourseInput, proficiencyRequirementUncheckedCreateWithoutCourseInput>
  }

  export type requiredCourseCreateWithoutCourseInput = {
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedCreateWithoutCourseInput = {
    requirementID: number
  }

  export type requiredCourseCreateOrConnectWithoutCourseInput = {
    where: requiredCourseWhereUniqueInput
    create: XOR<requiredCourseCreateWithoutCourseInput, requiredCourseUncheckedCreateWithoutCourseInput>
  }

  export type RequiredStatusCreateWithoutCourseInput = {
    status?: RequiredStatus_status | null
    Student: StudentCreateNestedOneWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedCreateWithoutCourseInput = {
    studentID: number
    status?: RequiredStatus_status | null
  }

  export type RequiredStatusCreateOrConnectWithoutCourseInput = {
    where: RequiredStatusWhereUniqueInput
    create: XOR<RequiredStatusCreateWithoutCourseInput, RequiredStatusUncheckedCreateWithoutCourseInput>
  }

  export type DepartmentUpsertWithoutCourseInput = {
    update: XOR<DepartmentUpdateWithoutCourseInput, DepartmentUncheckedUpdateWithoutCourseInput>
    create: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
  }

  export type DepartmentUpdateWithoutCourseInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUpdateManyWithoutDepartmentInput
    GPD?: GPDUpdateOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedUpdateWithoutCourseInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUncheckedUpdateManyWithoutDepartmentInput
    GPD?: GPDUncheckedUpdateOneWithoutDepartmentInput
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutCourseInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutCourseOfferingInput>
  }

  export type CourseOfferingScalarWhereInput = {
    AND?: Enumerable<CourseOfferingScalarWhereInput>
    OR?: Enumerable<CourseOfferingScalarWhereInput>
    NOT?: Enumerable<CourseOfferingScalarWhereInput>
    courseOfferingID?: StringFilter | string
    courseID?: StringNullableFilter | string | null
    semester?: EnumCourseOffering_semesterNullableFilter | CourseOffering_semester | null
    year?: IntNullableFilter | number | null
    section?: StringNullableFilter | string | null
  }

  export type prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput = {
    where: prerequisiteWhereUniqueInput
    update: XOR<prerequisiteUpdateWithoutCourse_CourseToprerequisite_courseIDInput, prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_courseIDInput>
    create: XOR<prerequisiteCreateWithoutCourse_CourseToprerequisite_courseIDInput, prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_courseIDInput>
  }

  export type prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_courseIDInput = {
    where: prerequisiteWhereUniqueInput
    data: XOR<prerequisiteUpdateWithoutCourse_CourseToprerequisite_courseIDInput, prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_courseIDInput>
  }

  export type prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_courseIDInput = {
    where: prerequisiteScalarWhereInput
    data: XOR<prerequisiteUpdateManyMutationInput, prerequisiteUncheckedUpdateManyWithoutPrerequisite_CourseToprerequisite_courseIDInput>
  }

  export type prerequisiteScalarWhereInput = {
    AND?: Enumerable<prerequisiteScalarWhereInput>
    OR?: Enumerable<prerequisiteScalarWhereInput>
    NOT?: Enumerable<prerequisiteScalarWhereInput>
    courseID?: StringFilter | string
    prerequisiteID?: StringFilter | string
  }

  export type prerequisiteUpsertWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    where: prerequisiteWhereUniqueInput
    update: XOR<prerequisiteUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput, prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
    create: XOR<prerequisiteCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput, prerequisiteUncheckedCreateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
  }

  export type prerequisiteUpdateWithWhereUniqueWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    where: prerequisiteWhereUniqueInput
    data: XOR<prerequisiteUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput, prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput>
  }

  export type prerequisiteUpdateManyWithWhereWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    where: prerequisiteScalarWhereInput
    data: XOR<prerequisiteUpdateManyMutationInput, prerequisiteUncheckedUpdateManyWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
  }

  export type proficiencyRequirementUpsertWithWhereUniqueWithoutCourseInput = {
    where: proficiencyRequirementWhereUniqueInput
    update: XOR<proficiencyRequirementUpdateWithoutCourseInput, proficiencyRequirementUncheckedUpdateWithoutCourseInput>
    create: XOR<proficiencyRequirementCreateWithoutCourseInput, proficiencyRequirementUncheckedCreateWithoutCourseInput>
  }

  export type proficiencyRequirementUpdateWithWhereUniqueWithoutCourseInput = {
    where: proficiencyRequirementWhereUniqueInput
    data: XOR<proficiencyRequirementUpdateWithoutCourseInput, proficiencyRequirementUncheckedUpdateWithoutCourseInput>
  }

  export type proficiencyRequirementUpdateManyWithWhereWithoutCourseInput = {
    where: proficiencyRequirementScalarWhereInput
    data: XOR<proficiencyRequirementUpdateManyMutationInput, proficiencyRequirementUncheckedUpdateManyWithoutProficiencyRequirementInput>
  }

  export type proficiencyRequirementScalarWhereInput = {
    AND?: Enumerable<proficiencyRequirementScalarWhereInput>
    OR?: Enumerable<proficiencyRequirementScalarWhereInput>
    NOT?: Enumerable<proficiencyRequirementScalarWhereInput>
    requirementID?: IntFilter | number
    courseID?: StringFilter | string
  }

  export type requiredCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: requiredCourseWhereUniqueInput
    update: XOR<requiredCourseUpdateWithoutCourseInput, requiredCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<requiredCourseCreateWithoutCourseInput, requiredCourseUncheckedCreateWithoutCourseInput>
  }

  export type requiredCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: requiredCourseWhereUniqueInput
    data: XOR<requiredCourseUpdateWithoutCourseInput, requiredCourseUncheckedUpdateWithoutCourseInput>
  }

  export type requiredCourseUpdateManyWithWhereWithoutCourseInput = {
    where: requiredCourseScalarWhereInput
    data: XOR<requiredCourseUpdateManyMutationInput, requiredCourseUncheckedUpdateManyWithoutRequiredCourseInput>
  }

  export type requiredCourseScalarWhereInput = {
    AND?: Enumerable<requiredCourseScalarWhereInput>
    OR?: Enumerable<requiredCourseScalarWhereInput>
    NOT?: Enumerable<requiredCourseScalarWhereInput>
    requirementID?: IntFilter | number
    courseID?: StringFilter | string
  }

  export type RequiredStatusUpsertWithWhereUniqueWithoutCourseInput = {
    where: RequiredStatusWhereUniqueInput
    update: XOR<RequiredStatusUpdateWithoutCourseInput, RequiredStatusUncheckedUpdateWithoutCourseInput>
    create: XOR<RequiredStatusCreateWithoutCourseInput, RequiredStatusUncheckedCreateWithoutCourseInput>
  }

  export type RequiredStatusUpdateWithWhereUniqueWithoutCourseInput = {
    where: RequiredStatusWhereUniqueInput
    data: XOR<RequiredStatusUpdateWithoutCourseInput, RequiredStatusUncheckedUpdateWithoutCourseInput>
  }

  export type RequiredStatusUpdateManyWithWhereWithoutCourseInput = {
    where: RequiredStatusScalarWhereInput
    data: XOR<RequiredStatusUpdateManyMutationInput, RequiredStatusUncheckedUpdateManyWithoutRequiredStatusInput>
  }

  export type RequiredStatusScalarWhereInput = {
    AND?: Enumerable<RequiredStatusScalarWhereInput>
    OR?: Enumerable<RequiredStatusScalarWhereInput>
    NOT?: Enumerable<RequiredStatusScalarWhereInput>
    studentID?: IntFilter | number
    courseID?: StringFilter | string
    status?: EnumRequiredStatus_statusNullableFilter | RequiredStatus_status | null
  }

  export type CourseCreateWithoutCourseOfferingInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseOfferingInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseOfferingInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseOfferingInput, CourseUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TimeSlotDayCreateWithoutCourseOfferingInput = {
    day: TimeSlotDay_day
  }

  export type TimeSlotDayUncheckedCreateWithoutCourseOfferingInput = {
    day: TimeSlotDay_day
  }

  export type TimeSlotDayCreateOrConnectWithoutCourseOfferingInput = {
    where: TimeSlotDayWhereUniqueInput
    create: XOR<TimeSlotDayCreateWithoutCourseOfferingInput, TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TimeSlotTimeCreateWithoutCourseOfferingInput = {
    startTime?: Date | string | null
    endTime?: Date | string | null
  }

  export type TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput = {
    startTime?: Date | string | null
    endTime?: Date | string | null
  }

  export type TimeSlotTimeCreateOrConnectWithoutCourseOfferingInput = {
    where: TimeSlotTimeWhereUniqueInput
    create: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
  }

  export type CourseUpsertWithoutCourseOfferingInput = {
    update: XOR<CourseUpdateWithoutCourseOfferingInput, CourseUncheckedUpdateWithoutCourseOfferingInput>
    create: XOR<CourseCreateWithoutCourseOfferingInput, CourseUncheckedCreateWithoutCourseOfferingInput>
  }

  export type CourseUpdateWithoutCourseOfferingInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutCourseOfferingInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type TimeSlotDayUpsertWithWhereUniqueWithoutCourseOfferingInput = {
    where: TimeSlotDayWhereUniqueInput
    update: XOR<TimeSlotDayUpdateWithoutCourseOfferingInput, TimeSlotDayUncheckedUpdateWithoutCourseOfferingInput>
    create: XOR<TimeSlotDayCreateWithoutCourseOfferingInput, TimeSlotDayUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TimeSlotDayUpdateWithWhereUniqueWithoutCourseOfferingInput = {
    where: TimeSlotDayWhereUniqueInput
    data: XOR<TimeSlotDayUpdateWithoutCourseOfferingInput, TimeSlotDayUncheckedUpdateWithoutCourseOfferingInput>
  }

  export type TimeSlotDayUpdateManyWithWhereWithoutCourseOfferingInput = {
    where: TimeSlotDayScalarWhereInput
    data: XOR<TimeSlotDayUpdateManyMutationInput, TimeSlotDayUncheckedUpdateManyWithoutTimeSlotDayInput>
  }

  export type TimeSlotDayScalarWhereInput = {
    AND?: Enumerable<TimeSlotDayScalarWhereInput>
    OR?: Enumerable<TimeSlotDayScalarWhereInput>
    NOT?: Enumerable<TimeSlotDayScalarWhereInput>
    CourseOfferingID?: StringFilter | string
    day?: EnumTimeSlotDay_dayFilter | TimeSlotDay_day
  }

  export type TimeSlotTimeUpsertWithoutCourseOfferingInput = {
    update: XOR<TimeSlotTimeUpdateWithoutCourseOfferingInput, TimeSlotTimeUncheckedUpdateWithoutCourseOfferingInput>
    create: XOR<TimeSlotTimeCreateWithoutCourseOfferingInput, TimeSlotTimeUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TimeSlotTimeUpdateWithoutCourseOfferingInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeSlotTimeUncheckedUpdateWithoutCourseOfferingInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudentCreateWithoutCoursePlanInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsCreateNestedManyWithoutStudentInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutStudentInput
    Grades?: GradesCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCoursePlanInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsUncheckedCreateNestedManyWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput
    Grades?: GradesUncheckedCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCoursePlanInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCoursePlanInput, StudentUncheckedCreateWithoutCoursePlanInput>
  }

  export type StudentUpsertWithoutCoursePlanInput = {
    update: XOR<StudentUpdateWithoutCoursePlanInput, StudentUncheckedUpdateWithoutCoursePlanInput>
    create: XOR<StudentCreateWithoutCoursePlanInput, StudentUncheckedCreateWithoutCoursePlanInput>
  }

  export type StudentUpdateWithoutCoursePlanInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUpdateManyWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutStudentInput
    Grades?: GradesUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutCoursePlanInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUncheckedUpdateManyWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutStudentInput
    Grades?: GradesUncheckedUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutStudentInput
  }

  export type DepartmentCreateWithoutDegreeRequirementInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseCreateNestedManyWithoutDepartmentInput
    GPD?: GPDCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDegreeRequirementInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    GPD?: GPDUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDegreeRequirementInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDegreeRequirementInput, DepartmentUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type AreaCreateWithoutDegreeRequirementInput = {
    areaID: number
    name?: string | null
    AreaRequirement?: AreaRequirementCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaCreateNestedOneWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutDegreeRequirementInput = {
    areaID: number
    name?: string | null
    AreaRequirement?: AreaRequirementUncheckedCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutAreaInput
    SubArea?: SubAreaUncheckedCreateNestedOneWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutDegreeRequirementInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutDegreeRequirementInput, AreaUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type proficiencyRequirementCreateWithoutDegreeRequirementInput = {
    Course: CourseCreateNestedOneWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput = {
    courseID: string
  }

  export type proficiencyRequirementCreateOrConnectWithoutDegreeRequirementInput = {
    where: proficiencyRequirementWhereUniqueInput
    create: XOR<proficiencyRequirementCreateWithoutDegreeRequirementInput, proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type requiredCourseCreateWithoutDegreeRequirementInput = {
    Course: CourseCreateNestedOneWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedCreateWithoutDegreeRequirementInput = {
    courseID: string
  }

  export type requiredCourseCreateOrConnectWithoutDegreeRequirementInput = {
    where: requiredCourseWhereUniqueInput
    create: XOR<requiredCourseCreateWithoutDegreeRequirementInput, requiredCourseUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type DepartmentUpsertWithoutDegreeRequirementInput = {
    update: XOR<DepartmentUpdateWithoutDegreeRequirementInput, DepartmentUncheckedUpdateWithoutDegreeRequirementInput>
    create: XOR<DepartmentCreateWithoutDegreeRequirementInput, DepartmentUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type DepartmentUpdateWithoutDegreeRequirementInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateManyWithoutDepartmentInput
    GPD?: GPDUpdateOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedUpdateWithoutDegreeRequirementInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUncheckedUpdateManyWithoutDepartmentInput
    GPD?: GPDUncheckedUpdateOneWithoutDepartmentInput
  }

  export type AreaUpsertWithWhereUniqueWithoutDegreeRequirementInput = {
    where: AreaWhereUniqueInput
    update: XOR<AreaUpdateWithoutDegreeRequirementInput, AreaUncheckedUpdateWithoutDegreeRequirementInput>
    create: XOR<AreaCreateWithoutDegreeRequirementInput, AreaUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type AreaUpdateWithWhereUniqueWithoutDegreeRequirementInput = {
    where: AreaWhereUniqueInput
    data: XOR<AreaUpdateWithoutDegreeRequirementInput, AreaUncheckedUpdateWithoutDegreeRequirementInput>
  }

  export type AreaUpdateManyWithWhereWithoutDegreeRequirementInput = {
    where: AreaScalarWhereInput
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyWithoutAreaInput>
  }

  export type AreaScalarWhereInput = {
    AND?: Enumerable<AreaScalarWhereInput>
    OR?: Enumerable<AreaScalarWhereInput>
    NOT?: Enumerable<AreaScalarWhereInput>
    areaID?: IntFilter | number
    requirementID?: IntFilter | number
    name?: StringNullableFilter | string | null
  }

  export type proficiencyRequirementUpsertWithWhereUniqueWithoutDegreeRequirementInput = {
    where: proficiencyRequirementWhereUniqueInput
    update: XOR<proficiencyRequirementUpdateWithoutDegreeRequirementInput, proficiencyRequirementUncheckedUpdateWithoutDegreeRequirementInput>
    create: XOR<proficiencyRequirementCreateWithoutDegreeRequirementInput, proficiencyRequirementUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type proficiencyRequirementUpdateWithWhereUniqueWithoutDegreeRequirementInput = {
    where: proficiencyRequirementWhereUniqueInput
    data: XOR<proficiencyRequirementUpdateWithoutDegreeRequirementInput, proficiencyRequirementUncheckedUpdateWithoutDegreeRequirementInput>
  }

  export type proficiencyRequirementUpdateManyWithWhereWithoutDegreeRequirementInput = {
    where: proficiencyRequirementScalarWhereInput
    data: XOR<proficiencyRequirementUpdateManyMutationInput, proficiencyRequirementUncheckedUpdateManyWithoutProficiencyRequirementInput>
  }

  export type requiredCourseUpsertWithWhereUniqueWithoutDegreeRequirementInput = {
    where: requiredCourseWhereUniqueInput
    update: XOR<requiredCourseUpdateWithoutDegreeRequirementInput, requiredCourseUncheckedUpdateWithoutDegreeRequirementInput>
    create: XOR<requiredCourseCreateWithoutDegreeRequirementInput, requiredCourseUncheckedCreateWithoutDegreeRequirementInput>
  }

  export type requiredCourseUpdateWithWhereUniqueWithoutDegreeRequirementInput = {
    where: requiredCourseWhereUniqueInput
    data: XOR<requiredCourseUpdateWithoutDegreeRequirementInput, requiredCourseUncheckedUpdateWithoutDegreeRequirementInput>
  }

  export type requiredCourseUpdateManyWithWhereWithoutDegreeRequirementInput = {
    where: requiredCourseScalarWhereInput
    data: XOR<requiredCourseUpdateManyMutationInput, requiredCourseUncheckedUpdateManyWithoutRequiredCourseInput>
  }

  export type CourseCreateWithoutDepartmentInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutDepartmentInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type DegreeRequirementCreateWithoutDepartmentInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Area?: AreaCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedCreateWithoutDepartmentInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Area?: AreaUncheckedCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementCreateOrConnectWithoutDepartmentInput = {
    where: DegreeRequirementWhereUniqueInput
    create: XOR<DegreeRequirementCreateWithoutDepartmentInput, DegreeRequirementUncheckedCreateWithoutDepartmentInput>
  }

  export type GPDCreateWithoutDepartmentInput = {
    User: UserCreateNestedOneWithoutGPDInput
    Comments?: CommentsCreateNestedManyWithoutGPDInput
  }

  export type GPDUncheckedCreateWithoutDepartmentInput = {
    GPDID: number
    Comments?: CommentsUncheckedCreateNestedManyWithoutGPDInput
  }

  export type GPDCreateOrConnectWithoutDepartmentInput = {
    where: GPDWhereUniqueInput
    create: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
  }

  export type CourseUpdateManyWithWhereWithoutDepartmentInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseScalarWhereInput = {
    AND?: Enumerable<CourseScalarWhereInput>
    OR?: Enumerable<CourseScalarWhereInput>
    NOT?: Enumerable<CourseScalarWhereInput>
    courseID?: StringFilter | string
    departID?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    credits?: IntNullableFilter | number | null
    courseNum?: IntNullableFilter | number | null
  }

  export type DegreeRequirementUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DegreeRequirementWhereUniqueInput
    update: XOR<DegreeRequirementUpdateWithoutDepartmentInput, DegreeRequirementUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DegreeRequirementCreateWithoutDepartmentInput, DegreeRequirementUncheckedCreateWithoutDepartmentInput>
  }

  export type DegreeRequirementUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DegreeRequirementWhereUniqueInput
    data: XOR<DegreeRequirementUpdateWithoutDepartmentInput, DegreeRequirementUncheckedUpdateWithoutDepartmentInput>
  }

  export type DegreeRequirementUpdateManyWithWhereWithoutDepartmentInput = {
    where: DegreeRequirementScalarWhereInput
    data: XOR<DegreeRequirementUpdateManyMutationInput, DegreeRequirementUncheckedUpdateManyWithoutDegreeRequirementInput>
  }

  export type DegreeRequirementScalarWhereInput = {
    AND?: Enumerable<DegreeRequirementScalarWhereInput>
    OR?: Enumerable<DegreeRequirementScalarWhereInput>
    NOT?: Enumerable<DegreeRequirementScalarWhereInput>
    requirementID?: IntFilter | number
    departID?: StringNullableFilter | string | null
    track?: StringNullableFilter | string | null
    versionSemester?: EnumDegreeRequirement_versionSemesterNullableFilter | DegreeRequirement_versionSemester | null
    versionYear?: IntNullableFilter | number | null
    totalCredit?: IntNullableFilter | number | null
    project?: StringNullableFilter | string | null
    thesis?: StringNullableFilter | string | null
    timeLimit?: IntNullableFilter | number | null
    finalRecommended?: IntNullableFilter | number | null
    minGPA?: IntNullableFilter | number | null
  }

  export type GPDUpsertWithoutDepartmentInput = {
    update: XOR<GPDUpdateWithoutDepartmentInput, GPDUncheckedUpdateWithoutDepartmentInput>
    create: XOR<GPDCreateWithoutDepartmentInput, GPDUncheckedCreateWithoutDepartmentInput>
  }

  export type GPDUpdateWithoutDepartmentInput = {
    User?: UserUpdateOneRequiredWithoutGPDInput
    Comments?: CommentsUpdateManyWithoutGPDInput
  }

  export type GPDUncheckedUpdateWithoutDepartmentInput = {
    GPDID?: IntFieldUpdateOperationsInput | number
    Comments?: CommentsUncheckedUpdateManyWithoutGPDInput
  }

  export type AreaCreateWithoutElectiveStatusInput = {
    areaID: number
    name?: string | null
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutAreaInput
    AreaRequirement?: AreaRequirementCreateNestedOneWithoutAreaInput
    SubArea?: SubAreaCreateNestedOneWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutElectiveStatusInput = {
    areaID: number
    requirementID: number
    name?: string | null
    AreaRequirement?: AreaRequirementUncheckedCreateNestedOneWithoutAreaInput
    SubArea?: SubAreaUncheckedCreateNestedOneWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutElectiveStatusInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutElectiveStatusInput, AreaUncheckedCreateWithoutElectiveStatusInput>
  }

  export type StudentCreateWithoutElectiveStatusInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanCreateNestedOneWithoutStudentInput
    Grades?: GradesCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutElectiveStatusInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsUncheckedCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedCreateNestedOneWithoutStudentInput
    Grades?: GradesUncheckedCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutElectiveStatusInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutElectiveStatusInput, StudentUncheckedCreateWithoutElectiveStatusInput>
  }

  export type AreaUpsertWithoutElectiveStatusInput = {
    update: XOR<AreaUpdateWithoutElectiveStatusInput, AreaUncheckedUpdateWithoutElectiveStatusInput>
    create: XOR<AreaCreateWithoutElectiveStatusInput, AreaUncheckedCreateWithoutElectiveStatusInput>
  }

  export type AreaUpdateWithoutElectiveStatusInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutAreaInput
    AreaRequirement?: AreaRequirementUpdateOneWithoutAreaInput
    SubArea?: SubAreaUpdateOneWithoutAreaInput
  }

  export type AreaUncheckedUpdateWithoutElectiveStatusInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    requirementID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AreaRequirement?: AreaRequirementUncheckedUpdateOneWithoutAreaInput
    SubArea?: SubAreaUncheckedUpdateOneWithoutAreaInput
  }

  export type StudentUpsertWithoutElectiveStatusInput = {
    update: XOR<StudentUpdateWithoutElectiveStatusInput, StudentUncheckedUpdateWithoutElectiveStatusInput>
    create: XOR<StudentCreateWithoutElectiveStatusInput, StudentUncheckedCreateWithoutElectiveStatusInput>
  }

  export type StudentUpdateWithoutElectiveStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUpdateOneWithoutStudentInput
    Grades?: GradesUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutElectiveStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUncheckedUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedUpdateOneWithoutStudentInput
    Grades?: GradesUncheckedUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutStudentInput
  }

  export type UserCreateWithoutGPDInput = {
    userID?: number
    username: string
    password: string
  }

  export type UserUncheckedCreateWithoutGPDInput = {
    userID?: number
    username: string
    password: string
  }

  export type UserCreateOrConnectWithoutGPDInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGPDInput, UserUncheckedCreateWithoutGPDInput>
  }

  export type DepartmentCreateWithoutGPDInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseCreateNestedManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutGPDInput = {
    departmentID: string
    departmentName?: string | null
    Course?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutGPDInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutGPDInput, DepartmentUncheckedCreateWithoutGPDInput>
  }

  export type CommentsCreateWithoutGPDInput = {
    comment: string
    date?: Date | string | null
    Student: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutGPDInput = {
    studentID: number
    comment: string
    date?: Date | string | null
  }

  export type CommentsCreateOrConnectWithoutGPDInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutGPDInput, CommentsUncheckedCreateWithoutGPDInput>
  }

  export type UserUpsertWithoutGPDInput = {
    update: XOR<UserUpdateWithoutGPDInput, UserUncheckedUpdateWithoutGPDInput>
    create: XOR<UserCreateWithoutGPDInput, UserUncheckedCreateWithoutGPDInput>
  }

  export type UserUpdateWithoutGPDInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateWithoutGPDInput = {
    userID?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUpsertWithoutGPDInput = {
    update: XOR<DepartmentUpdateWithoutGPDInput, DepartmentUncheckedUpdateWithoutGPDInput>
    create: XOR<DepartmentCreateWithoutGPDInput, DepartmentUncheckedCreateWithoutGPDInput>
  }

  export type DepartmentUpdateWithoutGPDInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUpdateManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedUpdateWithoutGPDInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    departmentName?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUncheckedUpdateManyWithoutDepartmentInput
    DegreeRequirement?: DegreeRequirementUncheckedUpdateManyWithoutDepartmentInput
  }

  export type CommentsUpsertWithWhereUniqueWithoutGPDInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutGPDInput, CommentsUncheckedUpdateWithoutGPDInput>
    create: XOR<CommentsCreateWithoutGPDInput, CommentsUncheckedCreateWithoutGPDInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutGPDInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutGPDInput, CommentsUncheckedUpdateWithoutGPDInput>
  }

  export type CommentsUpdateManyWithWhereWithoutGPDInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: Enumerable<CommentsScalarWhereInput>
    OR?: Enumerable<CommentsScalarWhereInput>
    NOT?: Enumerable<CommentsScalarWhereInput>
    studentID?: IntFilter | number
    GPDID?: IntFilter | number
    comment?: StringFilter | string
    date?: DateTimeNullableFilter | Date | string | null
  }

  export type StudentCreateWithoutGradesInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradesInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsUncheckedCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
  }

  export type StudentUpsertWithoutGradesInput = {
    update: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
  }

  export type StudentUpdateWithoutGradesInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutGradesInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUncheckedUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutStudentInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutStudentInput
  }

  export type CourseCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
  }

  export type CourseCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
  }

  export type CourseUpsertWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    update: XOR<CourseUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
    create: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_courseIDInput>
  }

  export type CourseUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type CourseUpsertWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    update: XOR<CourseUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
    create: XOR<CourseCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput, CourseUncheckedCreateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput>
  }

  export type CourseUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type CourseCreateWithoutProficiencyRequirementInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutProficiencyRequirementInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProficiencyRequirementInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProficiencyRequirementInput, CourseUncheckedCreateWithoutProficiencyRequirementInput>
  }

  export type DegreeRequirementCreateWithoutProficiencyRequirementInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Department?: DepartmentCreateNestedOneWithoutDegreeRequirementInput
    Area?: AreaCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedCreateWithoutProficiencyRequirementInput = {
    requirementID: number
    departID?: string | null
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Area?: AreaUncheckedCreateNestedManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementCreateOrConnectWithoutProficiencyRequirementInput = {
    where: DegreeRequirementWhereUniqueInput
    create: XOR<DegreeRequirementCreateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedCreateWithoutProficiencyRequirementInput>
  }

  export type CourseUpsertWithoutProficiencyRequirementInput = {
    update: XOR<CourseUpdateWithoutProficiencyRequirementInput, CourseUncheckedUpdateWithoutProficiencyRequirementInput>
    create: XOR<CourseCreateWithoutProficiencyRequirementInput, CourseUncheckedCreateWithoutProficiencyRequirementInput>
  }

  export type CourseUpdateWithoutProficiencyRequirementInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutProficiencyRequirementInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type DegreeRequirementUpsertWithoutProficiencyRequirementInput = {
    update: XOR<DegreeRequirementUpdateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedUpdateWithoutProficiencyRequirementInput>
    create: XOR<DegreeRequirementCreateWithoutProficiencyRequirementInput, DegreeRequirementUncheckedCreateWithoutProficiencyRequirementInput>
  }

  export type DegreeRequirementUpdateWithoutProficiencyRequirementInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutDegreeRequirementInput
    Area?: AreaUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateWithoutProficiencyRequirementInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUncheckedUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutDegreeRequirementInput
  }

  export type CourseCreateWithoutRequiredCourseInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutRequiredCourseInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutRequiredCourseInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutRequiredCourseInput, CourseUncheckedCreateWithoutRequiredCourseInput>
  }

  export type DegreeRequirementCreateWithoutRequiredCourseInput = {
    requirementID: number
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Department?: DepartmentCreateNestedOneWithoutDegreeRequirementInput
    Area?: AreaCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedCreateWithoutRequiredCourseInput = {
    requirementID: number
    departID?: string | null
    track?: string | null
    versionSemester?: DegreeRequirement_versionSemester | null
    versionYear?: number | null
    totalCredit?: number | null
    project?: string | null
    thesis?: string | null
    timeLimit?: number | null
    finalRecommended?: number | null
    minGPA?: number | null
    Area?: AreaUncheckedCreateNestedManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementCreateOrConnectWithoutRequiredCourseInput = {
    where: DegreeRequirementWhereUniqueInput
    create: XOR<DegreeRequirementCreateWithoutRequiredCourseInput, DegreeRequirementUncheckedCreateWithoutRequiredCourseInput>
  }

  export type CourseUpsertWithoutRequiredCourseInput = {
    update: XOR<CourseUpdateWithoutRequiredCourseInput, CourseUncheckedUpdateWithoutRequiredCourseInput>
    create: XOR<CourseCreateWithoutRequiredCourseInput, CourseUncheckedCreateWithoutRequiredCourseInput>
  }

  export type CourseUpdateWithoutRequiredCourseInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutRequiredCourseInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type DegreeRequirementUpsertWithoutRequiredCourseInput = {
    update: XOR<DegreeRequirementUpdateWithoutRequiredCourseInput, DegreeRequirementUncheckedUpdateWithoutRequiredCourseInput>
    create: XOR<DegreeRequirementCreateWithoutRequiredCourseInput, DegreeRequirementUncheckedCreateWithoutRequiredCourseInput>
  }

  export type DegreeRequirementUpdateWithoutRequiredCourseInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutDegreeRequirementInput
    Area?: AreaUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateWithoutRequiredCourseInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUncheckedUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutDegreeRequirementInput
  }

  export type CourseCreateWithoutRequiredStatusInput = {
    courseID: string
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    Department?: DepartmentCreateNestedOneWithoutCourseInput
    CourseOffering?: CourseOfferingCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutRequiredStatusInput = {
    courseID: string
    departID?: string | null
    name?: string | null
    description?: string | null
    credits?: number | null
    courseNum?: number | null
    CourseOffering?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedCreateNestedManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedCreateNestedManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutRequiredStatusInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutRequiredStatusInput, CourseUncheckedCreateWithoutRequiredStatusInput>
  }

  export type StudentCreateWithoutRequiredStatusInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutStudentInput
    Grades?: GradesCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutRequiredStatusInput = {
    studentID?: number
    firstName: string
    lastName: string
    requirementID?: number | null
    entrySemester: Student_entrySemester
    entryYear: number
    gradSemester?: Student_gradSemester | null
    gradYear?: number | null
    nSemestersInProgram: number
    gpa?: Decimal | number | string | null
    totalCredits?: number | null
    projectOption?: string | null
    advisor?: string | null
    hasGraduated?: boolean | null
    Comments?: CommentsUncheckedCreateNestedManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedCreateNestedOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutStudentInput
    Grades?: GradesUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutRequiredStatusInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutRequiredStatusInput, StudentUncheckedCreateWithoutRequiredStatusInput>
  }

  export type CourseUpsertWithoutRequiredStatusInput = {
    update: XOR<CourseUpdateWithoutRequiredStatusInput, CourseUncheckedUpdateWithoutRequiredStatusInput>
    create: XOR<CourseCreateWithoutRequiredStatusInput, CourseUncheckedCreateWithoutRequiredStatusInput>
  }

  export type CourseUpdateWithoutRequiredStatusInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    Department?: DepartmentUpdateOneWithoutCourseInput
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutRequiredStatusInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    departID?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
  }

  export type StudentUpsertWithoutRequiredStatusInput = {
    update: XOR<StudentUpdateWithoutRequiredStatusInput, StudentUncheckedUpdateWithoutRequiredStatusInput>
    create: XOR<StudentCreateWithoutRequiredStatusInput, StudentUncheckedCreateWithoutRequiredStatusInput>
  }

  export type StudentUpdateWithoutRequiredStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutStudentInput
    Grades?: GradesUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutRequiredStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    requirementID?: NullableIntFieldUpdateOperationsInput | number | null
    entrySemester?: EnumStudent_entrySemesterFieldUpdateOperationsInput | Student_entrySemester
    entryYear?: IntFieldUpdateOperationsInput | number
    gradSemester?: NullableEnumStudent_gradSemesterFieldUpdateOperationsInput | Student_gradSemester | null
    gradYear?: NullableIntFieldUpdateOperationsInput | number | null
    nSemestersInProgram?: IntFieldUpdateOperationsInput | number
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    projectOption?: NullableStringFieldUpdateOperationsInput | string | null
    advisor?: NullableStringFieldUpdateOperationsInput | string | null
    hasGraduated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Comments?: CommentsUncheckedUpdateManyWithoutStudentInput
    CoursePlan?: CoursePlanUncheckedUpdateOneWithoutStudentInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutStudentInput
    Grades?: GradesUncheckedUpdateManyWithoutStudentInput
  }

  export type CommentsCreateWithoutStudentInput = {
    comment: string
    date?: Date | string | null
    GPD: GPDCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutStudentInput = {
    GPDID: number
    comment: string
    date?: Date | string | null
  }

  export type CommentsCreateOrConnectWithoutStudentInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutStudentInput, CommentsUncheckedCreateWithoutStudentInput>
  }

  export type CoursePlanCreateWithoutStudentInput = {
    valid?: boolean | null
    complete?: boolean | null
  }

  export type CoursePlanUncheckedCreateWithoutStudentInput = {
    valid?: boolean | null
    complete?: boolean | null
  }

  export type CoursePlanCreateOrConnectWithoutStudentInput = {
    where: CoursePlanWhereUniqueInput
    create: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
  }

  export type ElectiveStatusCreateWithoutStudentInput = {
    status?: ElectiveStatus_status | null
    Area: AreaCreateNestedOneWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedCreateWithoutStudentInput = {
    areaID: number
    status?: ElectiveStatus_status | null
  }

  export type ElectiveStatusCreateOrConnectWithoutStudentInput = {
    where: ElectiveStatusWhereUniqueInput
    create: XOR<ElectiveStatusCreateWithoutStudentInput, ElectiveStatusUncheckedCreateWithoutStudentInput>
  }

  export type GradesCreateWithoutStudentInput = {
    courseOfferingID: string
    grade?: string | null
  }

  export type GradesUncheckedCreateWithoutStudentInput = {
    courseOfferingID: string
    grade?: string | null
  }

  export type GradesCreateOrConnectWithoutStudentInput = {
    where: GradesWhereUniqueInput
    create: XOR<GradesCreateWithoutStudentInput, GradesUncheckedCreateWithoutStudentInput>
  }

  export type RequiredStatusCreateWithoutStudentInput = {
    status?: RequiredStatus_status | null
    Course: CourseCreateNestedOneWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedCreateWithoutStudentInput = {
    courseID: string
    status?: RequiredStatus_status | null
  }

  export type RequiredStatusCreateOrConnectWithoutStudentInput = {
    where: RequiredStatusWhereUniqueInput
    create: XOR<RequiredStatusCreateWithoutStudentInput, RequiredStatusUncheckedCreateWithoutStudentInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutStudentInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutStudentInput, CommentsUncheckedUpdateWithoutStudentInput>
    create: XOR<CommentsCreateWithoutStudentInput, CommentsUncheckedCreateWithoutStudentInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutStudentInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutStudentInput, CommentsUncheckedUpdateWithoutStudentInput>
  }

  export type CommentsUpdateManyWithWhereWithoutStudentInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CoursePlanUpsertWithoutStudentInput = {
    update: XOR<CoursePlanUpdateWithoutStudentInput, CoursePlanUncheckedUpdateWithoutStudentInput>
    create: XOR<CoursePlanCreateWithoutStudentInput, CoursePlanUncheckedCreateWithoutStudentInput>
  }

  export type CoursePlanUpdateWithoutStudentInput = {
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CoursePlanUncheckedUpdateWithoutStudentInput = {
    valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ElectiveStatusUpsertWithWhereUniqueWithoutStudentInput = {
    where: ElectiveStatusWhereUniqueInput
    update: XOR<ElectiveStatusUpdateWithoutStudentInput, ElectiveStatusUncheckedUpdateWithoutStudentInput>
    create: XOR<ElectiveStatusCreateWithoutStudentInput, ElectiveStatusUncheckedCreateWithoutStudentInput>
  }

  export type ElectiveStatusUpdateWithWhereUniqueWithoutStudentInput = {
    where: ElectiveStatusWhereUniqueInput
    data: XOR<ElectiveStatusUpdateWithoutStudentInput, ElectiveStatusUncheckedUpdateWithoutStudentInput>
  }

  export type ElectiveStatusUpdateManyWithWhereWithoutStudentInput = {
    where: ElectiveStatusScalarWhereInput
    data: XOR<ElectiveStatusUpdateManyMutationInput, ElectiveStatusUncheckedUpdateManyWithoutElectiveStatusInput>
  }

  export type GradesUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradesWhereUniqueInput
    update: XOR<GradesUpdateWithoutStudentInput, GradesUncheckedUpdateWithoutStudentInput>
    create: XOR<GradesCreateWithoutStudentInput, GradesUncheckedCreateWithoutStudentInput>
  }

  export type GradesUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradesWhereUniqueInput
    data: XOR<GradesUpdateWithoutStudentInput, GradesUncheckedUpdateWithoutStudentInput>
  }

  export type GradesUpdateManyWithWhereWithoutStudentInput = {
    where: GradesScalarWhereInput
    data: XOR<GradesUpdateManyMutationInput, GradesUncheckedUpdateManyWithoutGradesInput>
  }

  export type GradesScalarWhereInput = {
    AND?: Enumerable<GradesScalarWhereInput>
    OR?: Enumerable<GradesScalarWhereInput>
    NOT?: Enumerable<GradesScalarWhereInput>
    studentID?: IntFilter | number
    courseOfferingID?: StringFilter | string
    grade?: StringNullableFilter | string | null
  }

  export type RequiredStatusUpsertWithWhereUniqueWithoutStudentInput = {
    where: RequiredStatusWhereUniqueInput
    update: XOR<RequiredStatusUpdateWithoutStudentInput, RequiredStatusUncheckedUpdateWithoutStudentInput>
    create: XOR<RequiredStatusCreateWithoutStudentInput, RequiredStatusUncheckedCreateWithoutStudentInput>
  }

  export type RequiredStatusUpdateWithWhereUniqueWithoutStudentInput = {
    where: RequiredStatusWhereUniqueInput
    data: XOR<RequiredStatusUpdateWithoutStudentInput, RequiredStatusUncheckedUpdateWithoutStudentInput>
  }

  export type RequiredStatusUpdateManyWithWhereWithoutStudentInput = {
    where: RequiredStatusScalarWhereInput
    data: XOR<RequiredStatusUpdateManyMutationInput, RequiredStatusUncheckedUpdateManyWithoutRequiredStatusInput>
  }

  export type AreaCreateWithoutSubAreaInput = {
    areaID: number
    name?: string | null
    DegreeRequirement: DegreeRequirementCreateNestedOneWithoutAreaInput
    AreaRequirement?: AreaRequirementCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutSubAreaInput = {
    areaID: number
    requirementID: number
    name?: string | null
    AreaRequirement?: AreaRequirementUncheckedCreateNestedOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutSubAreaInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutSubAreaInput, AreaUncheckedCreateWithoutSubAreaInput>
  }

  export type AreaUpsertWithoutSubAreaInput = {
    update: XOR<AreaUpdateWithoutSubAreaInput, AreaUncheckedUpdateWithoutSubAreaInput>
    create: XOR<AreaCreateWithoutSubAreaInput, AreaUncheckedCreateWithoutSubAreaInput>
  }

  export type AreaUpdateWithoutSubAreaInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutAreaInput
    AreaRequirement?: AreaRequirementUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutAreaInput
  }

  export type AreaUncheckedUpdateWithoutSubAreaInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    requirementID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AreaRequirement?: AreaRequirementUncheckedUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutAreaInput
  }

  export type CourseOfferingCreateWithoutTimeSlotDayInput = {
    courseOfferingID: string
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    Course?: CourseCreateNestedOneWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutTimeSlotDayInput = {
    courseOfferingID: string
    courseID?: string | null
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    TimeSlotTime?: TimeSlotTimeUncheckedCreateNestedOneWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutTimeSlotDayInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutTimeSlotDayInput, CourseOfferingUncheckedCreateWithoutTimeSlotDayInput>
  }

  export type CourseOfferingUpsertWithoutTimeSlotDayInput = {
    update: XOR<CourseOfferingUpdateWithoutTimeSlotDayInput, CourseOfferingUncheckedUpdateWithoutTimeSlotDayInput>
    create: XOR<CourseOfferingCreateWithoutTimeSlotDayInput, CourseOfferingUncheckedCreateWithoutTimeSlotDayInput>
  }

  export type CourseOfferingUpdateWithoutTimeSlotDayInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateOneWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedUpdateWithoutTimeSlotDayInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    courseID?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSlotTime?: TimeSlotTimeUncheckedUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateWithoutTimeSlotTimeInput = {
    courseOfferingID: string
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    Course?: CourseCreateNestedOneWithoutCourseOfferingInput
    TimeSlotDay?: TimeSlotDayCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutTimeSlotTimeInput = {
    courseOfferingID: string
    courseID?: string | null
    semester?: CourseOffering_semester | null
    year?: number | null
    section?: string | null
    TimeSlotDay?: TimeSlotDayUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutTimeSlotTimeInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutTimeSlotTimeInput, CourseOfferingUncheckedCreateWithoutTimeSlotTimeInput>
  }

  export type CourseOfferingUpsertWithoutTimeSlotTimeInput = {
    update: XOR<CourseOfferingUpdateWithoutTimeSlotTimeInput, CourseOfferingUncheckedUpdateWithoutTimeSlotTimeInput>
    create: XOR<CourseOfferingCreateWithoutTimeSlotTimeInput, CourseOfferingUncheckedCreateWithoutTimeSlotTimeInput>
  }

  export type CourseOfferingUpdateWithoutTimeSlotTimeInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    Course?: CourseUpdateOneWithoutCourseOfferingInput
    TimeSlotDay?: TimeSlotDayUpdateManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedUpdateWithoutTimeSlotTimeInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    courseID?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSlotDay?: TimeSlotDayUncheckedUpdateManyWithoutCourseOfferingInput
  }

  export type GPDCreateWithoutUserInput = {
    Department: DepartmentCreateNestedOneWithoutGPDInput
    Comments?: CommentsCreateNestedManyWithoutGPDInput
  }

  export type GPDUncheckedCreateWithoutUserInput = {
    departmentID: string
    Comments?: CommentsUncheckedCreateNestedManyWithoutGPDInput
  }

  export type GPDCreateOrConnectWithoutUserInput = {
    where: GPDWhereUniqueInput
    create: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
  }

  export type GPDUpsertWithoutUserInput = {
    update: XOR<GPDUpdateWithoutUserInput, GPDUncheckedUpdateWithoutUserInput>
    create: XOR<GPDCreateWithoutUserInput, GPDUncheckedCreateWithoutUserInput>
  }

  export type GPDUpdateWithoutUserInput = {
    Department?: DepartmentUpdateOneRequiredWithoutGPDInput
    Comments?: CommentsUpdateManyWithoutGPDInput
  }

  export type GPDUncheckedUpdateWithoutUserInput = {
    departmentID?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUncheckedUpdateManyWithoutGPDInput
  }

  export type ElectiveStatusUpdateWithoutAreaInput = {
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
    Student?: StudentUpdateOneRequiredWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedUpdateWithoutAreaInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type ElectiveStatusUncheckedUpdateManyWithoutElectiveStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type CourseOfferingUpdateWithoutCourseInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSlotDay?: TimeSlotDayUpdateManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedUpdateWithoutCourseInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSlotDay?: TimeSlotDayUncheckedUpdateManyWithoutCourseOfferingInput
    TimeSlotTime?: TimeSlotTimeUncheckedUpdateOneWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseOfferingInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    semester?: NullableEnumCourseOffering_semesterFieldUpdateOperationsInput | CourseOffering_semester | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prerequisiteUpdateWithoutCourse_CourseToprerequisite_courseIDInput = {
    Course_CourseToprerequisite_prerequisiteID?: CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput
  }

  export type prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_courseIDInput = {
    prerequisiteID?: StringFieldUpdateOperationsInput | string
  }

  export type prerequisiteUncheckedUpdateManyWithoutPrerequisite_CourseToprerequisite_courseIDInput = {
    prerequisiteID?: StringFieldUpdateOperationsInput | string
  }

  export type prerequisiteUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    Course_CourseToprerequisite_courseID?: CourseUpdateOneRequiredWithoutPrerequisite_CourseToprerequisite_courseIDInput
  }

  export type prerequisiteUncheckedUpdateWithoutCourse_CourseToprerequisite_prerequisiteIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type prerequisiteUncheckedUpdateManyWithoutPrerequisite_CourseToprerequisite_prerequisiteIDInput = {
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type proficiencyRequirementUpdateWithoutCourseInput = {
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedUpdateWithoutCourseInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
  }

  export type proficiencyRequirementUncheckedUpdateManyWithoutProficiencyRequirementInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
  }

  export type requiredCourseUpdateWithoutCourseInput = {
    DegreeRequirement?: DegreeRequirementUpdateOneRequiredWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedUpdateWithoutCourseInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
  }

  export type requiredCourseUncheckedUpdateManyWithoutRequiredCourseInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
  }

  export type RequiredStatusUpdateWithoutCourseInput = {
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
    Student?: StudentUpdateOneRequiredWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedUpdateWithoutCourseInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }

  export type RequiredStatusUncheckedUpdateManyWithoutRequiredStatusInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }

  export type TimeSlotDayUpdateWithoutCourseOfferingInput = {
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type TimeSlotDayUncheckedUpdateWithoutCourseOfferingInput = {
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type TimeSlotDayUncheckedUpdateManyWithoutTimeSlotDayInput = {
    day?: EnumTimeSlotDay_dayFieldUpdateOperationsInput | TimeSlotDay_day
  }

  export type AreaUpdateWithoutDegreeRequirementInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AreaRequirement?: AreaRequirementUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUpdateManyWithoutAreaInput
    SubArea?: SubAreaUpdateOneWithoutAreaInput
  }

  export type AreaUncheckedUpdateWithoutDegreeRequirementInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AreaRequirement?: AreaRequirementUncheckedUpdateOneWithoutAreaInput
    ElectiveStatus?: ElectiveStatusUncheckedUpdateManyWithoutAreaInput
    SubArea?: SubAreaUncheckedUpdateOneWithoutAreaInput
  }

  export type AreaUncheckedUpdateManyWithoutAreaInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proficiencyRequirementUpdateWithoutDegreeRequirementInput = {
    Course?: CourseUpdateOneRequiredWithoutProficiencyRequirementInput
  }

  export type proficiencyRequirementUncheckedUpdateWithoutDegreeRequirementInput = {
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type requiredCourseUpdateWithoutDegreeRequirementInput = {
    Course?: CourseUpdateOneRequiredWithoutRequiredCourseInput
  }

  export type requiredCourseUncheckedUpdateWithoutDegreeRequirementInput = {
    courseID?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUpdateWithoutDepartmentInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateWithoutDepartmentInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
    CourseOffering?: CourseOfferingUncheckedUpdateManyWithoutCourseInput
    prerequisite_CourseToprerequisite_courseID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_courseIDInput
    prerequisite_CourseToprerequisite_prerequisiteID?: prerequisiteUncheckedUpdateManyWithoutCourse_CourseToprerequisite_prerequisiteIDInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutCourseInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutCourseInput
    RequiredStatus?: RequiredStatusUncheckedUpdateManyWithoutCourseInput
  }

  export type CourseUncheckedUpdateManyWithoutCourseInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    courseNum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DegreeRequirementUpdateWithoutDepartmentInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateWithoutDepartmentInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUncheckedUpdateManyWithoutDegreeRequirementInput
    proficiencyRequirement?: proficiencyRequirementUncheckedUpdateManyWithoutDegreeRequirementInput
    requiredCourse?: requiredCourseUncheckedUpdateManyWithoutDegreeRequirementInput
  }

  export type DegreeRequirementUncheckedUpdateManyWithoutDegreeRequirementInput = {
    requirementID?: IntFieldUpdateOperationsInput | number
    track?: NullableStringFieldUpdateOperationsInput | string | null
    versionSemester?: NullableEnumDegreeRequirement_versionSemesterFieldUpdateOperationsInput | DegreeRequirement_versionSemester | null
    versionYear?: NullableIntFieldUpdateOperationsInput | number | null
    totalCredit?: NullableIntFieldUpdateOperationsInput | number | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    finalRecommended?: NullableIntFieldUpdateOperationsInput | number | null
    minGPA?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentsUpdateWithoutGPDInput = {
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Student?: StudentUpdateOneRequiredWithoutCommentsInput
  }

  export type CommentsUncheckedUpdateWithoutGPDInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentsUncheckedUpdateManyWithoutCommentsInput = {
    studentID?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentsUpdateWithoutStudentInput = {
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GPD?: GPDUpdateOneRequiredWithoutCommentsInput
  }

  export type CommentsUncheckedUpdateWithoutStudentInput = {
    GPDID?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ElectiveStatusUpdateWithoutStudentInput = {
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
    Area?: AreaUpdateOneRequiredWithoutElectiveStatusInput
  }

  export type ElectiveStatusUncheckedUpdateWithoutStudentInput = {
    areaID?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumElectiveStatus_statusFieldUpdateOperationsInput | ElectiveStatus_status | null
  }

  export type GradesUpdateWithoutStudentInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradesUncheckedUpdateWithoutStudentInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradesUncheckedUpdateManyWithoutGradesInput = {
    courseOfferingID?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequiredStatusUpdateWithoutStudentInput = {
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
    Course?: CourseUpdateOneRequiredWithoutRequiredStatusInput
  }

  export type RequiredStatusUncheckedUpdateWithoutStudentInput = {
    courseID?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumRequiredStatus_statusFieldUpdateOperationsInput | RequiredStatus_status | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}